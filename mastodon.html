<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mastodon Engine</title>
<style>
:root {
--bg-color: #1e1e1e;
--text-color: #d4d4d4;
--line-height: 24px;
--font-size: 15px;
--font-family: 'Menlo', 'Consolas', 'Monaco', 'Liberation Mono', 'Segoe UI Emoji', 'Apple Color Emoji', monospace;
--selection-bg: #264f78;
--cursor-color: #aeafad;
--line-num-bg: #1e1e1e;
--line-num-text: #858585;
--border-color: #333;
--c-comment: #6a9955;
--c-string: #ce9178;
--c-number: #b5cea8;
--c-keyword: #c586c0;
--c-function: #dcdcaa;
--c-tag: #569cd6;
--c-attr: #9cdcfe;
--c-selector: #d7ba7d;
--c-property: #9cdcfe;
--char-width: 9px;
}
body {
margin: 0;
overflow: hidden;
background: var(--bg-color);
color: var(--text-color);
font-family: var(--font-family);
}
#editor {
position: relative;
top: 40px;
width: 100vw;
height: calc(100vh - 80px);
overflow: auto;
outline: none;
cursor: text;
}
#scroll-phantom {
position: absolute;
top: 0;
left: 0;
z-index: -1;
width: 1px;
height: 1px;
}
#view-port {
position: absolute;
top: 0;
left: 0;
min-width: 100%;
pointer-events: none;
will-change: transform;
z-index: 5;
}
.line {
height: var(--line-height);
line-height: var(--line-height);
font-size: var(--font-size);
font-family: 'Menlo', 'Consolas', 'Monaco', monospace !important;
white-space: pre;
padding-left: 0;
width: 100%;
box-sizing: border-box;
display: flex;
position: relative;
font-variant-ligatures: none;
letter-spacing: 0px;
}
:not(pre) > code[class*="language-"], pre[class*="language-"] {
background: transparent !important;
text-shadow: none !important;
padding: 0 !important;
margin: 0 !important;
}
.line-number {
position: sticky;
left: 0;
top: 0;
bottom: 0;
width: 60px;
min-width: 60px;
text-align: right;
color: var(--line-num-text);
background: var(--line-num-bg);
padding-right: 10px;
border-right: 1px solid var(--border-color);
box-sizing: border-box;
user-select: none;
z-index: 20;
}
.selection-layer {
position: absolute;
left: 65px;
top: 0;
bottom: 0;
background-color: transparent;
z-index: 1;
pointer-events: none;
}
.is-selected {
background-color: var(--selection-bg);
}
.line-content {
padding-left: 5px;
position: relative;
z-index: 2;
pointer-events: none;
}
#cursor {
position: absolute;
width: 1ch;
height: var(--line-height);
background-color: #6a9955;
border-radius: 3px;
opacity: 0.5;
z-index: 4;
pointer-events: none;
}
.blink {
animation: blink 1s step-end infinite;
}
#toolbar {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 40px;
background: #0a0807;
border-bottom: 1px solid #1a1614;
display: flex;
align-items: center;
justify-content: center;
padding: 0 10px;
box-sizing: border-box;
z-index: 100;
font-size: 13px;
gap: 10px;
}
#toolbar input {
background: #1e1e1e;
border: 1px solid #333;
color: #d4d4d4;
padding: 4px 8px;
border-radius: 3px;
outline: none;
font-family: sans-serif;
}
#toolbar input:focus {
border-color: #007acc;
}
#toolbar button {
background: #2d2d2d;
border: 1px solid #333;
color: #d4d4d4;
padding: 4px 10px;
border-radius: 3px;
cursor: pointer;
font-size: 12px;
}
#toolbar button:hover {
background: #3d3d3d;
}
#toolbar button:active {
background: #007acc;
color: white;
}
#search-stats {
color: #858585;
font-size: 12px;
position: absolute;
right: 20px;
white-space: nowrap;
}
#statusbar {
position: fixed;
bottom: 0;
left: 0;
width: 100%;
height: 40px;
background: #0a0807;
color: #524b48;
font-size: 14px;
padding: 0 10px;
font-family: sans-serif;
z-index: 100;
display: flex;
justify-content: space-between;
align-items: center;
box-sizing: border-box;
border-top: 1px solid #1a1614;
}
#file-status {
flex: 1;
text-align: left;
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
}
#message-area {
flex: 1;
text-align: right;
white-space: nowrap;
overflow: hidden;
text-overflow: ellipsis;
}
#shortcuts {
flex: 0 0 auto;
display: flex;
gap: 5px;
}
#shortcuts button {
background: #2d2d2d;
border: 1px solid #333;
color: #d4d4d4;
padding: 4px 10px;
border-radius: 3px;
cursor: pointer;
font-size: 12px;
}
#shortcuts button:hover {
background: #3d3d3d;
}
#shortcuts button:active {
background: #007acc;
color: white;
}
@keyframes blink {
0%,
100% {
opacity: 1;
}
50% {
opacity: 0;
}
}
.modal-overlay {
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(0, 0, 0, 0.6);
backdrop-filter: blur(2px);
z-index: 1000;
display: none;
justify-content: center;
align-items: center;
}
.modal-box {
background: #252526;
color: #cccccc;
width: 480px;
max-width: 90%;
border: 1px solid #454545;
border-radius: 8px;
box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
padding: 0;
overflow: hidden;
animation: modalFadeIn 0.3s ease-out;
}
.modal-header {
background: #2d2d2d;
padding: 15px 20px;
border-bottom: 1px solid #333;
font-size: 28px;
font-weight: 600;
color: #fff;
}
.modal-body {
padding: 20px;
font-size: 14px;
line-height: 1.6;
}
.modal-body h3 {
color: #4fc1ff;
margin-top: 0;
font-size: 15px;
}
.modal-body ul {
padding-left: 20px;
margin-bottom: 20px;
}
.modal-body li {
margin-bottom: 8px;
}
.modal-footer {
padding: 15px 20px;
background: #2d2d2d;
border-top: 1px solid #333;
display: flex;
justify-content: space-between;
align-items: center;
}
.modal-btn {
background: #007acc;
color: white;
border: none;
padding: 8px 16px;
border-radius: 4px;
cursor: pointer;
font-size: 13px;
transition: background 0.2s;
}
.modal-btn:hover {
background: #005f9e;
}
.modal-checkbox-label {
font-size: 13px;
color: #999;
cursor: pointer;
display: flex;
align-items: center;
gap: 8px;
user-select: none;
}
@keyframes modalFadeIn {
from {
opacity: 0;
transform: translateY(-20px);
}
to {
opacity: 1;
transform: translateY(0);
}
}
.token.comment { color: #6a9955; }
.token.string { color: #ce9178; }
.token.number { color: #b5cea8; }
.token.html-tag { color: #569cd6; }
.token.attr-name { color: #9cdcfe; }
.token.selector { color: #d7ba7d; }
.token.property { color: #9cdcfe; }
.token.keyword { color: #c586c0; }
.token.function { color: #dcdcaa; }
.token.trailing-space { background-color: rgba(255, 0, 0, 0.3); border-radius: 2px; }
.token.emoji {
display: inline-block;
width: calc(var(--char-width) * 2) !important;
text-align: center;
vertical-align: middle;
box-sizing: content-box;
}
#measure-line {
position: absolute;
visibility: hidden;
height: auto;
width: auto;
white-space: pre;
font-family: 'Menlo', 'Consolas', 'Monaco', 'Liberation Mono', monospace !important;
font-size: var(--font-size);
font-variant-ligatures: none;
letter-spacing: 0px;
padding-left: 0;
z-index: -100;
}
::-webkit-scrollbar {
width: 8px;
height: 8px;
}
::-webkit-scrollbar-track {
background: transparent;
}
::-webkit-scrollbar-thumb {
background-color: #424242;
border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover {
background-color: #5a5a5a;
}
::-webkit-scrollbar-corner {
background: transparent;
}
</style>
</head>
<body>
<div id="intro-modal" class="modal-overlay">
<div class="modal-box">
<div class="modal-header">
<big>ðŸ¦£</big>&nbsp;&nbsp;Mastodon Engine 0.2
</div>
<div class="modal-body">
<p>You are now using a specialized code editor tailored for building and optimizing
<strong>Single-File Web Applications</strong>.</p>
<h3>Key Features:</h3>
<ul>
<li>
<strong>Unrivaled Performance:</strong> Engineered to handle massive files that choke standard editors.
Capable of processing <strong>650,000+ lines</strong> on entry-level hardware.
</li>
<li>
<strong>Syntax Highlighting:</strong> Custom-built highlighting specifically tuned for mixed-mode
development (HTML/JS/CSS).
</li>
<p>&copy; 2025 Johnny Heggelund</p>
</ul>
</div>
<div class="modal-footer">
<label class="modal-checkbox-label">
<input type="checkbox" id="dont-show-again"> Don't show again
</label>
<button class="modal-btn" onclick="closeIntroModal()">Start coding</button>
</div>
</div>
</div>
<div id="toolbar">
<input type="text" id="find-input" placeholder="Find..." style="width: 150px;">
<input type="text" id="replace-input" placeholder="Replace..." style="width: 150px;">
<button onclick="editor.search.findNext()">Next</button>
<button onclick="editor.search.replace()">Replace</button>
<button onclick="editor.search.replaceAll()">All</button>
<span id="search-stats"></span>
</div>
<div id="editor" tabindex="0">
<div id="scroll-phantom"></div>
<div id="view-port"></div>
<div id="cursor" class="blink"></div>
</div>
<div id="statusbar">
<span id="file-status">Untitled.txt</span>
<div id="shortcuts">
<button onclick="editor.openFile()" title="Open File (Alt+O)">Open</button>
<button onclick="editor.saveFile()" title="Save File (Alt+S)">Save</button>
<button onclick="editor.newFile()" style="margin-right: 0;" title="New File (Alt+N)">New</button>
<button onclick="editor.previewFile()" title="Preview in new tab (Alt+P)">Preview</button>
<button onclick="editor.smartIndent()" title="Flatten Code (Alt+I)" style="margin-left: 10px;">â®œBOOM</button>
<button onclick="editor.cycleNext('comment')" title="Jump to next comment (Alt+C)" style="margin-left: 10px;">â†» Comment</button>
<button onclick="editor.cycleNext('whitespace')" title="Jump to next trailing whitespace (Alt+W)">â†» Whitespace</button>
<button onclick="editor.cycleNext('empty')" title="Jump to next empty line (Alt+L)">â†» Empty Line</button>
<button onclick="editor.cycleNext('function')" title="Jump to next function definition (Alt+.)">â†» Function</button>
<button onclick="editor.removeComments()" title="Remove Comments (Alt+R)" style="margin-left: 10px;">Rx Comm</button>
<button onclick="editor.removeEmptyLines()" title="Remove Empty Lines (Alt+E)">Rx Empty</button>
<button onclick="editor.removeTrailingWhitespace()" title="Remove Trailing Whitespace (Alt+T)">Rx Trail</button>
</div>
<span id="message-area">Mastodon Engine</span>
</div>
<script>
"use strict";
function checkIntroModal() {
const hide = localStorage.getItem('mastodon_hide_intro');
if (!hide) {
document.getElementById('intro-modal').style.display = 'flex';
}
}
function closeIntroModal() {
const checkbox = document.getElementById('dont-show-again');
if (checkbox.checked) {
localStorage.setItem('mastodon_hide_intro', 'true');
}
document.getElementById('intro-modal').style.display = 'none';
if (window.editor && window.editor.dom) {
window.editor.dom.editor.focus();
}
}
class SyntaxHighlighter {
constructor() {
this.lineModes = [];
}
analyze(lines) {
let mode = 'html';
this.lineModes = new Array(lines.length);
for (let i = 0; i < lines.length; i++) {
const line = lines[i];
let thisLineMode = mode;
if (mode === 'html') {
if (line.match(/<script/i)) {
thisLineMode = 'html';
if (!line.match(/<\/script/i)) mode = 'javascript';
}
else if (line.match(/<style/i)) {
thisLineMode = 'html';
if (!line.match(/<\/style/i)) mode = 'css';
}
}
else if (mode === 'javascript') {
if (line.match(/<\/script/i)) {
thisLineMode = 'html';
mode = 'html';
} else {
thisLineMode = 'javascript';
}
}
else if (mode === 'css') {
if (line.match(/<\/style/i)) {
thisLineMode = 'html';
mode = 'html';
} else {
thisLineMode = 'css';
}
}
this.lineModes[i] = thisLineMode;
}
}
highlight(text, rowIndex) {
if (!text) return '&nbsp;';
const mode = (this.lineModes && this.lineModes[rowIndex]) ? this.lineModes[rowIndex] : 'html';
let escaped = this.escapeHTML(text);
let result = '';
if (mode === 'javascript') {
result = this.highlightJS(escaped);
} else if (mode === 'css') {
result = this.highlightCSS(escaped);
} else {
result = this.highlightHTMLLine(escaped);
}
return result.replace(/([\uD800-\uDBFF][\uDC00-\uDFFF])/g, '<span class="token emoji">$1</span>');
}
escapeHTML(str) {
return str.replace(/&/g, '&amp;')
.replace(/</g, '&lt;')
.replace(/>/g, '&gt;');
}
highlightJS(code) {
const pattern = /(".*?"|'.*?'|`[\s\S]*?`|\/\/.*)|(\b(?:const|let|var|function|return|if|else|for|while|class|new|this|async|await|import|export|from|try|catch)\b)|(\b\d+\.?\d*\b)|(\b[a-zA-Z_$][a-zA-Z0-9_$]*(?=\())/g;
return code.replace(pattern, (match, string, keyword, number, func) => {
if (string) {
return string.startsWith('//')
? `<span class="token comment">${string}</span>`
: `<span class="token string">${string}</span>`;
}
if (keyword) return `<span class="token keyword">${keyword}</span>`;
if (number) return `<span class="token number">${number}</span>`;
if (func) return `<span class="token function">${func}</span>`;
return match;
});
}
highlightCSS(code) {
try {
const p = /(\/\*[\s\S]*?\*\/)|(".*?"|'.*?')|((-?\d+\.?\d*|\.\d+)[a-zA-Z%]*)|([\.#][\w-]+|(?<=[\}\s]|^)[a-zA-Z][\w-]*(?=\s*[\{\,\.#]))|([a-zA-Z-]+)(?=:)|(@[\w-]+)/g;
return code.replace(p, (m, c, s, n, d, sel, prop, at) => {
if (c) return `<span class="token comment">${c}</span>`;
if (s) return `<span class="token string">${s}</span>`;
if (n) return `<span class="token number">${n}</span>`;
if (sel) return `<span class="token selector">${sel}</span>`;
if (prop) return `<span class="token property">${prop}</span>`;
if (at) return `<span class="token keyword">${at}</span>`;
return m;
});
} catch (e) {
return code;
}
}
highlightHTMLLine(code) {
let output = code;
output = output.replace(/(&lt;!--[\s\S]*?--&gt;)/g, '<span class="token comment">$1</span>');
output = output.replace(/(&lt;\/?)(\w+)([^&]*?)(&gt;)/g, (m, bracket, tag, attrs, close) => {
const styledAttrs = attrs.replace(/([a-zA-Z-]+)(=)(".*?"|'.*?')/g,
'<span class="token attr-name">$1</span>=$3'
);
return `${bracket}<span class="token html-tag">${tag}</span>${styledAttrs}${close}`;
});
return output;
}
}
class HistoryManager {
constructor(editor) {
this.editor = editor;
this.undoStack = [];
this.redoStack = [];
this.lastEditTime = 0;
}
record(op) {
const now = Date.now();
const isTyping = op.text.length === 1 && op.oldText.length === 0;
const isDel = op.oldText.length === 1 && op.text.length === 0;
if (this.undoStack.length > 0 && (now - this.lastEditTime) < 500) {
const last = this.undoStack[this.undoStack.length - 1];
if (isTyping && last.type === 'ins' && last.endRow === op.startRow && last.endCol === op.startCol) {
last.text += op.text; last.endCol += op.text.length; last.cursorAfter = op.cursorAfter;
this.lastEditTime = now; return;
}
if (isDel && last.type === 'del' && op.endRow === last.startRow && op.endCol === last.startCol) {
last.oldText = op.oldText + last.oldText; last.startCol = op.startCol; last.cursorAfter = op.cursorAfter;
this.lastEditTime = now; return;
}
}
op.type = isTyping ? 'ins' : (isDel ? 'del' : 'blk');
this.undoStack.push(op);
this.redoStack = [];
this.lastEditTime = now;
if (this.undoStack.length > 300) this.undoStack.shift();
}
undo() {
if (this.undoStack.length === 0) return;
const op = this.undoStack.pop();
this.redoStack.push(op);
this.editor.applyEditInternal(op.startRow, op.startCol, op.cursorAfter.row, op.cursorAfter.col, op.oldText, false);
this.editor.state.cursor = { ...op.cursorBefore };
this.editor.finalizeUpdate();
}
redo() {
if (this.redoStack.length === 0) return;
const op = this.redoStack.pop();
this.undoStack.push(op);
this.editor.applyEditInternal(op.startRow, op.startCol, op.endRow, op.endCol, op.text, false);
this.editor.state.cursor = { ...op.cursorAfter };
this.editor.finalizeUpdate();
}
}
class SearchManager {
constructor(editor) {
this.editor = editor;
this.matches = [];
this.currentIndex = -1;
this.lastQuery = "";
}
find(query) {
if (!query) return;
if (query.toLowerCase() === this.lastQuery.toLowerCase() && this.matches.length > 0) return;
this.matches = [];
const lines = this.editor.state.lines;
const lowerQuery = query.toLowerCase();
for (let r = 0; r < lines.length; r++) {
const line = lines[r];
const lowerLine = line.toLowerCase();
let pos = lowerLine.indexOf(lowerQuery);
while (pos !== -1) {
this.matches.push({ row: r, col: pos, len: query.length });
pos = lowerLine.indexOf(lowerQuery, pos + 1);
}
}
this.lastQuery = query;
this.currentIndex = -1;
const statEl = document.getElementById('search-stats');
if (this.matches.length === 0) {
statEl.textContent = "No matches";
} else {
statEl.textContent = `Found ${this.matches.length}`;
this.findNext();
}
}
findNext() {
const inputVal = document.getElementById('find-input').value;
if (inputVal !== this.lastQuery) this.find(inputVal);
if (this.matches.length === 0) return;
this.currentIndex = (this.currentIndex + 1) % this.matches.length;
const m = this.matches[this.currentIndex];
document.getElementById('search-stats').textContent = `${this.currentIndex + 1} of ${this.matches.length}`;
this.editor.state.selectionAnchor = { row: m.row, col: m.col };
this.editor.state.cursor = { row: m.row, col: m.col + m.len };
this.editor.state.desiredCol = m.col + m.len;
const lh = this.editor.config.lineHeight;
const targetRow = m.row;
const paddingLines = 8;
const desiredBottomPixel = (targetRow + paddingLines) * lh;
let newScrollTop = desiredBottomPixel - this.editor.state.viewportHeight;
newScrollTop = Math.max(0, newScrollTop);
if (newScrollTop > targetRow * lh) {
newScrollTop = targetRow * lh;
}
this.editor.dom.editor.scrollTop = newScrollTop;
this.editor.finalizeUpdate();
}
replace() {
if (this.matches.length === 0) return;
const replacement = document.getElementById('replace-input').value;
const m = this.matches[this.currentIndex];
const cursor = this.editor.state.cursor;
const anchor = this.editor.state.selectionAnchor;
if (anchor && cursor.row === m.row && Math.abs(cursor.col - anchor.col) === m.len) {
this.editor.applyChange(replacement);
this.lastQuery = "";
this.findNext();
} else {
this.findNext();
}
}
replaceAll() {
const query = document.getElementById('find-input').value;
const replacement = document.getElementById('replace-input').value;
if (!query) return;
if (!confirm(`Replace all occurrences of "${query}"?`)) return;
const lines = this.editor.state.lines;
let count = 0;
const newLines = lines.map(line => {
if (line.includes(query)) {
const parts = line.split(query);
count += parts.length - 1;
return parts.join(replacement);
}
return line;
});
if (count > 0) {
const newText = newLines.join('\n');
this.editor.applyEditInternal(0, 0, lines.length - 1, lines[lines.length - 1].length, newText, true);
this.editor.setStatus(`Replaced ${count} occurrences`);
this.matches = [];
this.lastQuery = "";
document.getElementById('search-stats').textContent = "";
} else {
this.editor.setStatus("Nothing found");
}
}
}
class EditorEngine {
constructor() {
this.config = {
lineHeight: 24,
charWidth: 9,
xOffset: 65,
viewBuffer: 15
};
this.state = {
lines: [""],
cursor: { row: 0, col: 0 },
selectionAnchor: null,
isDragging: false,
clickCount: 0,
lastClickTime: 0,
scrollTop: 0,
viewportHeight: 0,
fileName: 'Untitled.txt',
fileHandle: null,
isDirty: false,
desiredCol: 0
};
this.dom = {
editor: document.getElementById('editor'),
phantom: document.getElementById('scroll-phantom'),
viewport: document.getElementById('view-port'),
cursor: document.getElementById('cursor'),
fileStatus: document.getElementById('file-status'),
messageArea: document.getElementById('message-area')
};
this.history = new HistoryManager(this);
this.search = new SearchManager(this);
this.highlighter = new SyntaxHighlighter();
this.ticking = false;
this.init();
}
init() {
const measureLine = document.createElement('div');
measureLine.id = 'measure-line';
document.body.appendChild(measureLine);
this.dom.measureLine = measureLine;
document.getElementById('find-input').addEventListener('keydown', (e) => {
if (e.key === 'Enter') this.search.findNext();
if (e.key === 'Escape') {
e.preventDefault();
this.dom.editor.focus();
}
});
document.getElementById('replace-input').addEventListener('keydown', (e) => {
if (e.key === 'Enter') this.search.replace();
if (e.key === 'Escape') {
e.preventDefault();
this.dom.editor.focus();
}
});
this.state.viewportHeight = this.dom.editor.clientHeight;
document.fonts.ready.then(() => {
this.recalculateLayout();
});
window.addEventListener('beforeunload', (e) => {
if (this.state.isDirty) { e.preventDefault(); e.returnValue = ''; }
});
this.dom.editor.addEventListener('scroll', () => this.onScroll());
this.dom.editor.addEventListener('keydown', (e) => this.handleInput(e));
this.dom.editor.addEventListener('paste', (e) => this.handlePaste(e));
this.dom.editor.addEventListener('copy', (e) => this.handleCopyCut(e, false));
this.dom.editor.addEventListener('cut', (e) => this.handleCopyCut(e, true));
this.dom.editor.addEventListener('mousedown', (e) => this.handleMouseDown(e));
window.addEventListener('mousemove', (e) => this.handleMouseMove(e));
window.addEventListener('mouseup', (e) => this.handleMouseUp(e));
window.addEventListener('resize', () => {
this.state.viewportHeight = this.dom.editor.clientHeight;
this.recalculateLayout();
});
document.addEventListener('keydown', (e) => this.handleGlobalShortcuts(e));
this.dom.editor.focus();
this.highlighter.analyze(this.state.lines);
this.finalizeUpdate();
}
validateCursorPosition() {
const { row, col } = this.state.cursor;
const line = this.state.lines[row];
if (!line) return;
if (col > 0 && col < line.length) {
const high = line.charCodeAt(col - 1);
const low = line.charCodeAt(col);
if (high >= 0xD800 && high <= 0xDBFF && low >= 0xDC00 && low <= 0xDFFF) {
this.state.cursor.col += 1;
this.state.desiredCol = this.state.cursor.col;
}
}
}
removeEmptyLines() {
const lines = this.state.lines;
const newLines = [];
let inBackticks = false;
for (let i = 0; i < lines.length; i++) {
let line = lines[i];
let content = line.trim();
if (inBackticks) {
newLines.push(line);
let escaped = false;
for (let char of line) {
if (escaped) { escaped = false; continue; }
if (char === '\\') { escaped = true; continue; }
if (char === '`') inBackticks = !inBackticks;
}
continue;
}
let localInBackticks = false;
let inSingleQuote = false;
let inDoubleQuote = false;
let charEscaped = false;
for (let j = 0; j < line.length; j++) {
const char = line[j];
if (charEscaped) { charEscaped = false; continue; }
if (char === '\\') { charEscaped = true; continue; }
if (!inSingleQuote && !inDoubleQuote) {
if (char === '/' && line[j+1] === '/') {
break;
}
}
if (!localInBackticks) {
if (char === "'" && !inDoubleQuote) { inSingleQuote = !inSingleQuote; continue; }
if (char === '"' && !inSingleQuote) { inDoubleQuote = !inDoubleQuote; continue; }
}
if (inSingleQuote || inDoubleQuote) continue;
if (char === '`') {
localInBackticks = !localInBackticks;
}
}
if (content.length > 0) {
newLines.push(line);
}
if (localInBackticks) inBackticks = true;
}
const newText = newLines.join('\n');
if (newText !== lines.join('\n')) {
this.applyEditInternal(0, 0, lines.length - 1, lines[lines.length - 1].length, newText, true);
this.setStatus("Empty lines removed");
} else {
this.setStatus("No empty lines found");
}
}
removeTrailingWhitespace() {
const lines = this.state.lines;
const newLines = [];
let inBackticks = false;
for (let i = 0; i < lines.length; i++) {
let line = lines[i];
let endOfLineBackticks = inBackticks;
let inSingleQuote = false;
let inDoubleQuote = false;
let inRegex = false;
let inRegexClass = false;
let charEscaped = false;
let lastRealChar = '';
for (let j = 0; j < line.length; j++) {
const char = line[j];
const nextChar = line[j + 1];
if (charEscaped) {
charEscaped = false;
if (/\S/.test(char)) lastRealChar = char;
continue;
}
if (char === '\\') { charEscaped = true; continue; }
if (endOfLineBackticks) {
if (char === '`') endOfLineBackticks = false;
continue;
}
if (inRegex) {
if (inRegexClass) {
if (char === ']') inRegexClass = false;
} else {
if (char === '[') inRegexClass = true;
else if (char === '/') inRegex = false;
}
if (/\S/.test(char)) lastRealChar = char;
continue;
}
if (!inSingleQuote && !inDoubleQuote) {
if (char === "'") { inSingleQuote = true; continue; }
if (char === '"') { inDoubleQuote = true; continue; }
if (char === '`') { endOfLineBackticks = true; continue; }
if (char === '/' && nextChar === '/') break;
if (char === '/') {
const regexStarters = ['(', '=', ',', ':', '?', '[', '{', '!', '&', '|', 'return', 'case', 'throw'];
if (regexStarters.includes(lastRealChar) || lastRealChar === '') {
inRegex = true;
}
}
if (/\S/.test(char)) lastRealChar = char;
} else {
if (inSingleQuote && char === "'") inSingleQuote = false;
if (inDoubleQuote && char === '"') inDoubleQuote = false;
}
}
if (endOfLineBackticks) {
newLines.push(line);
} else {
newLines.push(line.trimEnd());
}
inBackticks = endOfLineBackticks;
}
const newText = newLines.join('\n');
if (newText !== lines.join('\n')) {
this.applyEditInternal(0, 0, lines.length - 1, lines[lines.length - 1].length, newText, true);
this.setStatus("Trailing whitespace removed");
} else {
this.setStatus("No trailing whitespace");
}
}
removeComments() {
const lines = this.state.lines;
const newLines = [];
let inBackticks = false;
let inBlockComment = false;
for (let i = 0; i < lines.length; i++) {
let line = lines[i];
let builtLine = "";
let inSingleQuote = false;
let inDoubleQuote = false;
let inRegex = false;
let inRegexClass = false;
let charEscaped = false;
let lastRealChar = '';
for (let j = 0; j < line.length; j++) {
const char = line[j];
const nextChar = line[j + 1];
if (charEscaped) {
charEscaped = false;
if (!inBlockComment) builtLine += char;
if (/\S/.test(char)) lastRealChar = char;
continue;
}
if (char === '\\') {
charEscaped = true;
if (!inBlockComment) builtLine += char;
continue;
}
if (inBackticks) {
builtLine += char;
if (char === '`') inBackticks = false;
continue;
}
if (inBlockComment) {
if (char === '*' && nextChar === '/') {
inBlockComment = false;
j++;
}
continue;
}
if (inRegex) {
builtLine += char;
if (inRegexClass) {
if (char === ']') inRegexClass = false;
} else {
if (char === '[') inRegexClass = true;
else if (char === '/') {
inRegex = false;
}
}
if (/\S/.test(char)) lastRealChar = char;
continue;
}
if (!inSingleQuote && !inDoubleQuote) {
if (char === "'") { inSingleQuote = true; builtLine += char; continue; }
if (char === '"') { inDoubleQuote = true; builtLine += char; continue; }
if (char === '`') { inBackticks = true; builtLine += char; continue; }
if (char === '/') {
if (nextChar === '*') {
inBlockComment = true;
j++;
continue;
}
if (nextChar === '/') {
break;
}
const regexStarters = ['(', '=', ',', ':', '?', '[', '{', '!', '&', '|', 'return', 'case', 'throw'];
if (regexStarters.includes(lastRealChar) || builtLine.trim().length === 0) {
inRegex = true;
builtLine += char;
continue;
}
}
}
else {
if (inSingleQuote && char === "'") inSingleQuote = false;
if (inDoubleQuote && char === '"') inDoubleQuote = false;
}
builtLine += char;
if (/\S/.test(char)) lastRealChar = char;
}
newLines.push(builtLine);
}
const newText = newLines.join('\n');
if (newText !== lines.join('\n')) {
this.applyEditInternal(0, 0, lines.length - 1, lines[lines.length - 1].length, newText, true);
this.setStatus("Comments removed");
} else {
this.setStatus("No comments found");
}
}
smartIndent() {
const lines = this.state.lines;
const currentCursorRow = this.state.cursor.row;
const newLines = new Array(lines.length);
let hasChanges = false;
let inBacktickBlock = false;
let inBlockComment = false;
let inHtmlPre = false;
for (let i = 0; i < lines.length; i++) {
const line = lines[i];
if (inBacktickBlock || inBlockComment || inHtmlPre) {
newLines[i] = line;
} else {
newLines[i] = line.replace(/^\s+/, '');
}
if (newLines[i] !== line) hasChanges = true;
let inSingleQuote = false;
let inDoubleQuote = false;
let inRegex = false;
let charEscaped = false;
for (let j = 0; j < line.length; j++) {
const char = line[j];
const nextChar = line[j+1] || '';
if (charEscaped) { charEscaped = false; continue; }
if (char === '\\') { charEscaped = true; continue; }
if (char === '`' && !inSingleQuote && !inDoubleQuote && !inRegex && !inBlockComment) {
inBacktickBlock = !inBacktickBlock;
continue;
}
if (!inSingleQuote && !inDoubleQuote && !inRegex && !inBacktickBlock) {
if (char === '/' && nextChar === '*') { inBlockComment = true; j++; continue; }
if (char === '*' && nextChar === '/') { inBlockComment = false; j++; continue; }
}
if (inBlockComment) continue;
if (char === '<' && !inSingleQuote && !inDoubleQuote && !inRegex && !inBacktickBlock) {
const rest = line.slice(j);
if (/^<(pre|textarea)(\s|>)/i.test(rest)) inHtmlPre = true;
if (/^<\/(pre|textarea)>/i.test(rest)) inHtmlPre = false;
}
if (char === '/' && !inSingleQuote && !inDoubleQuote && !inRegex && !inBacktickBlock) {
if (nextChar === '/') break;
}
if (inRegex) {
if (char === '/' && line[j-1] !== '\\') inRegex = false;
continue;
}
if (inSingleQuote) { if (char === "'") inSingleQuote = false; continue; }
if (inDoubleQuote) { if (char === '"') inDoubleQuote = false; continue; }
if (char === "'") inSingleQuote = true;
else if (char === '"') inDoubleQuote = true;
else if (char === '/' && !inBacktickBlock) {
const lastRealChar = line.substring(0, j).trim().slice(-1);
const regexStarters = ['(', '=', ',', ':', '?', '[', '{', '!', '&', '|', 'return', 'case', 'throw'];
if (regexStarters.includes(lastRealChar) || lastRealChar === '') {
inRegex = true;
}
}
}
}
if (!hasChanges) {
this.setStatus("Already flat.");
return;
}
const newText = newLines.join('\n');
this.applyEditInternal(0, 0, lines.length - 1, lines[lines.length - 1].length, newText, true);
const safeRow = Math.min(currentCursorRow, newLines.length - 1);
this.state.cursor = { row: safeRow, col: 0 };
this.state.selectionAnchor = null;
this.finalizeUpdate();
this.setStatus("Safe BOOM! ðŸ›¡ï¸");
}
cycleNext(type) {
const lines = this.state.lines;
const currentLineIdx = this.state.cursor.row;
let found = null;
const check = (r) => {
const line = lines[r];
const mode = (this.highlighter.lineModes && this.highlighter.lineModes[r]) ? this.highlighter.lineModes[r] : 'html';
if (type === 'comment') {
let lineComMatch = null;
let inString = false;
let stringChar = '';
for (let i = 0; i < line.length - 1; i++) {
const char = line[i];
if (inString) {
if (char === stringChar && line[i - 1] !== '\\') {
inString = false;
}
} else {
if (char === '"' || char === "'" || char === '`') {
inString = true;
stringChar = char;
}
else if (char === '/' && line[i + 1] === '/') {
lineComMatch = { index: i, 0: line.substring(i) };
break;
}
}
}
const blockComMatch = line.match(/\/\*/);
if (lineComMatch && (!blockComMatch || lineComMatch.index < blockComMatch.index)) {
return {
start: { r, c: lineComMatch.index },
end: { r, c: lineComMatch.index + lineComMatch[0].length },
select: true
};
}
if (blockComMatch) {
const startCol = blockComMatch.index;
for (let k = r; k < lines.length; k++) {
const offset = (k === r) ? startCol + 2 : 0;
const closeIdx = lines[k].indexOf('*/', offset);
if (closeIdx !== -1) {
return {
start: { r, c: startCol },
end: { r: k, c: closeIdx + 2 },
select: true
};
}
}
return { start: { r, c: startCol }, end: { r, c: line.length }, select: true };
}
}
else if (type === 'whitespace') {
const m = line.match(/[ \t]+$/);
if (m && m[0].length > 0) {
return {
start: { r, c: m.index },
end: { r, c: m.index + m[0].length },
select: true
};
}
}
else if (type === 'empty') {
if (/^\s*$/.test(line)) {
return { start: { r, c: 0 }, end: { r, c: line.length }, select: false };
}
}
else if (type === 'function') {
if (mode !== 'javascript') return null;
const functionRegex = /(?:^|\s)(?:export\s+)?(?:async\s+)?(?:function|class)\s+\w+|^\s*(?:static\s+|async\s+|get\s+|set\s+)?(?!if|for|while|switch|catch|return|await)\w+\s*\(.*?\)\s*\{/;
const m = line.match(functionRegex);
if (m) {
return { start: { r, c: m.index }, end: { r, c: m.index }, select: false };
}
}
return null;
};
for (let i = currentLineIdx + 1; i < lines.length; i++) {
found = check(i);
if (found) break;
}
if (!found) {
for (let i = 0; i <= currentLineIdx; i++) {
found = check(i);
if (found) break;
}
}
if (found) {
if (found.select) {
this.state.selectionAnchor = { row: found.start.r, col: found.start.c };
this.state.cursor = { row: found.end.r, col: found.end.c };
} else {
this.state.selectionAnchor = null;
this.state.cursor = { row: found.start.r, col: found.start.c };
}
this.state.desiredCol = this.state.cursor.col;
const lh = this.config.lineHeight;
const targetRow = this.state.cursor.row;
const desiredBottomPixel = (targetRow + 9) * lh;
let newScrollTop = desiredBottomPixel - this.state.viewportHeight;
newScrollTop = Math.max(0, newScrollTop);
if (newScrollTop > targetRow * lh) {
newScrollTop = targetRow * lh;
}
this.dom.editor.scrollTop = newScrollTop;
this.finalizeUpdate();
this.setStatus(`Found ${type}`);
} else {
this.setStatus(`No ${type} found`);
}
this.dom.editor.focus();
}
render() {
const { lines, scrollTop, viewportHeight, cursor, selectionAnchor } = this.state;
const { lineHeight, charWidth, xOffset, viewBuffer } = this.config;
const firstVisibleLine = Math.floor(scrollTop / lineHeight);
const startIndex = Math.max(0, firstVisibleLine - viewBuffer);
const visibleLinesCount = Math.ceil(viewportHeight / lineHeight);
const endIndex = Math.min(lines.length, firstVisibleLine + visibleLinesCount + viewBuffer);
this.dom.viewport.innerHTML = '';
const topOffset = startIndex * lineHeight;
this.dom.viewport.style.transform = `translateY(${topOffset}px)`;
let selStart = null, selEnd = null;
if (selectionAnchor) {
const anchorIsBefore = (selectionAnchor.row < cursor.row) ||
(selectionAnchor.row === cursor.row && selectionAnchor.col < cursor.col);
selStart = anchorIsBefore ? selectionAnchor : cursor;
selEnd = anchorIsBefore ? cursor : selectionAnchor;
if (selStart.row === selEnd.row && selStart.col === selEnd.col) selStart = null;
}
const fragment = document.createDocumentFragment();
for (let i = startIndex; i < endIndex; i++) {
const lineDiv = document.createElement('div');
lineDiv.className = 'line';
const numSpan = document.createElement('div');
numSpan.className = 'line-number';
numSpan.textContent = i + 1;
const contentSpan = document.createElement('div');
contentSpan.className = 'line-content';
contentSpan.innerHTML = this.highlighter.highlight(lines[i], i);
const selectionDiv = document.createElement('div');
selectionDiv.className = 'selection-layer';
if (selStart && i >= selStart.row && i <= selEnd.row) {
let colStart = 0;
let colEnd = lines[i].length;
if (i === selStart.row) colStart = selStart.col;
if (i === selEnd.row) colEnd = selEnd.col;
let width = (colEnd - colStart) * charWidth;
if (i < selEnd.row) width += charWidth * 0.5;
selectionDiv.style.left = `calc(${xOffset}px + ${colStart * charWidth}px)`;
selectionDiv.style.width = `${Math.max(0, width)}px`;
selectionDiv.classList.add('is-selected');
}
lineDiv.appendChild(numSpan);
lineDiv.appendChild(selectionDiv);
lineDiv.appendChild(contentSpan);
fragment.appendChild(lineDiv);
}
this.dom.viewport.appendChild(fragment);
this.updateCursor();
}
updateCursor() {
const { row, col } = this.state.cursor;
const { lineHeight, xOffset } = this.config;
const top = row * lineHeight;
const currentLine = this.state.lines[row] || "";
const textUpToCursor = currentLine.substring(0, col);
this.dom.measureLine.textContent = textUpToCursor;
const measuredWidth = this.dom.measureLine.getBoundingClientRect().width;
const left = xOffset + measuredWidth;
this.dom.cursor.style.top = `${top}px`;
this.dom.cursor.style.left = `${left}px`;
this.dom.cursor.classList.remove('blink');
clearTimeout(this.blinkTimeout);
this.blinkTimeout = setTimeout(() => this.dom.cursor.classList.add('blink'), 500);
}
updateDimensions() {
const { lines } = this.state;
const { lineHeight, charWidth, xOffset } = this.config;
const height = (lines.length + 5) * lineHeight;
const maxLen = lines.reduce((max, line) => Math.max(max, line.length), 0);
const width = xOffset + ((maxLen + 5) * charWidth);
this.dom.phantom.style.height = `${height}px`;
this.dom.phantom.style.width = `${width}px`;
this.dom.viewport.style.width = `${width}px`;
}
finalizeUpdate() {
this.validateCursorPosition();
this.updateDimensions();
this.ensureCursorVisible();
this.render();
}
recalculateLayout() {
const t = document.createElement('div');
t.className = 'line';
t.style.position = 'absolute';
t.style.visibility = 'hidden';
t.style.width = 'auto';
t.style.padding = '0';
t.textContent = 'M'.repeat(1000);
this.dom.viewport.appendChild(t);
const rect = t.getBoundingClientRect();
const w = rect.width / 1000;
const h = rect.height;
this.dom.viewport.removeChild(t);
let needsUpdate = false;
if (w > 0 && Math.abs(this.config.charWidth - w) > 0.0001) {
this.config.charWidth = w;
document.documentElement.style.setProperty('--char-width', `${w}px`);
needsUpdate = true;
}
if (h > 0 && Math.abs(this.config.lineHeight - h) > 0.0001) {
this.config.lineHeight = h;
document.documentElement.style.setProperty('--line-height', `${h}px`);
needsUpdate = true;
}
if (needsUpdate) this.finalizeUpdate();
}
onScroll() {
const currentLeft = this.dom.editor.scrollLeft;
if (currentLeft > 0 && currentLeft < 6) {
this.dom.editor.scrollLeft = 0;
return;
}
this.state.scrollTop = this.dom.editor.scrollTop;
if (!this.ticking) {
window.requestAnimationFrame(() => {
this.render();
this.ticking = false;
});
this.ticking = true;
}
}
applyChange(txt) {
const { cursor, selectionAnchor } = this.state;
let sr = cursor.row, sc = cursor.col;
let er = cursor.row, ec = cursor.col;
if (selectionAnchor) {
const anchorIsBefore = (selectionAnchor.row < cursor.row) ||
(selectionAnchor.row === cursor.row && selectionAnchor.col < cursor.col);
sr = anchorIsBefore ? selectionAnchor.row : cursor.row;
sc = anchorIsBefore ? selectionAnchor.col : cursor.col;
er = anchorIsBefore ? cursor.row : selectionAnchor.row;
ec = anchorIsBefore ? cursor.col : selectionAnchor.col;
}
this.state.selectionAnchor = null;
this.applyEditInternal(sr, sc, er, ec, txt, true);
this.state.desiredCol = this.state.cursor.col;
this.ensureCursorVisible();
}
applyEditInternal(sr, sc, er, ec, txt, hist) {
let l = this.state.lines;
let old = "";
const isFullReplace = (sr === 0 && er === l.length - 1 && sc === 0 && ec === l[er].length);
if (isFullReplace) {
old = l.join('\n');
} else {
if (sr === er) {
old = l[sr].slice(sc, ec);
} else {
old = [l[sr].slice(sc), ...l.slice(sr + 1, er), l[er].slice(0, ec)].join('\n');
}
}
const prefix = l[sr].slice(0, sc);
const suffix = l[er].slice(ec);
const newSegs = txt.split('\n');
newSegs[0] = prefix + newSegs[0];
newSegs[newSegs.length - 1] += suffix;
if (newSegs.length > 5000 || isFullReplace) {
const pre = l.slice(0, sr);
const post = l.slice(er + 1);
this.state.lines = pre.concat(newSegs).concat(post);
} else {
if (sr === er && newSegs.length === 1) {
l[sr] = newSegs[0];
} else {
l.splice(sr, er - sr + 1, ...newSegs);
}
}
const nr = sr + newSegs.length - 1;
const nc = (newSegs.length === 1 ? sc : 0) + txt.split('\n').pop().length;
if (hist) {
this.setDirty(true);
this.history.record({
startRow: sr, startCol: sc, endRow: er, endCol: ec,
text: txt, oldText: old,
cursorBefore: { row: sr, col: sc },
cursorAfter: { row: nr, col: nc }
});
}
this.state.cursor = { row: nr, col: nc };
this.highlighter.analyze(this.state.lines);
this.finalizeUpdate();
}
handleInput(e) {
const k = e.key;
const ctrl = e.ctrlKey || e.metaKey;
const alt = e.altKey;
if (alt) {
const lower = k.toLowerCase();
if (lower === 'c') { e.preventDefault(); this.cycleNext('comment'); return; }
if (lower === 'w') { e.preventDefault(); this.cycleNext('whitespace'); return; }
if (lower === 'l') { e.preventDefault(); this.cycleNext('empty'); return; }
if (lower === '.') { e.preventDefault(); this.cycleNext('function'); return; }
if (lower === 't') { e.preventDefault(); this.removeTrailingWhitespace(); return; }
if (lower === 'i') { e.preventDefault(); this.smartIndent(); return; }
if (lower === 'e') { e.preventDefault(); this.removeEmptyLines(); return; }
if (lower === 'r') { e.preventDefault(); this.removeComments(); return; }
return;
}
const { cursor: c, lines } = this.state;
const currentLine = lines[c.row];
if (ctrl && !['z', 'y', 'a'].includes(k.toLowerCase())) return;
if (k === 'Enter') {
e.preventDefault();
if (c.col > 0) {
const indent = currentLine.match(/^\s*/)[0];
let extra = currentLine.trim().endsWith('{') ? "  " : "";
this.applyChange("\n" + indent + extra);
} else {
this.applyChange("\n");
}
return;
}
if (k === 'Tab') {
e.preventDefault();
let inBackticks = false;
const safeUnindent = (line) => {
const startedInBackticks = inBackticks;
let charEscaped = false;
let inSingleQuote = false;
let inDoubleQuote = false;
let inRegex = false;
let inRegexClass = false;
let lastRealChar = '';
for (let j = 0; j < line.length; j++) {
const char = line[j];
if (inBackticks) {
if (charEscaped) { charEscaped = false; continue; }
if (char === '\\') { charEscaped = true; continue; }
if (char === '`') inBackticks = false;
continue;
}
if (charEscaped) {
charEscaped = false;
if (/\S/.test(char)) lastRealChar = char;
continue;
}
if (char === '\\') { charEscaped = true; continue; }
if (inRegex) {
if (inRegexClass) {
if (char === ']') inRegexClass = false;
} else {
if (char === '[') inRegexClass = true;
else if (char === '/') inRegex = false;
}
if (/\S/.test(char)) lastRealChar = char;
continue;
}
if (!inSingleQuote && !inDoubleQuote) {
if (char === "'") { inSingleQuote = true; continue; }
if (char === '"') { inDoubleQuote = true; continue; }
if (char === '`') { inBackticks = true; continue; }
if (char === '/' && line[j+1] === '/') break;
if (char === '/') {
const regexStarters = ['(', '=', ',', ':', '?', '[', '{', '!', '&', '|', 'return', 'case', 'throw'];
if (regexStarters.includes(lastRealChar) || lastRealChar === '') {
inRegex = true;
}
}
if (/\S/.test(char)) lastRealChar = char;
} else {
if (inSingleQuote && char === "'") inSingleQuote = false;
if (inDoubleQuote && char === '"') inDoubleQuote = false;
}
}
if (startedInBackticks) return line;
const isMap = /^[ \t"'#@$*+.,]+$/.test(line) && line.includes('#');
if (isMap) return line;
return line.replace(/^ {1,2}/, "");
};
if (e.shiftKey) {
if (this.state.selectionAnchor) {
inBackticks = false;
this.blockEdit(safeUnindent);
} else {
this.blockEdit(safeUnindent, c.row, c.row);
}
} else {
this.state.selectionAnchor ? this.blockEdit(l => "  " + l) : this.applyChange("  ");
}
return;
}
if (k === 'Backspace') {
e.preventDefault();
if (this.state.selectionAnchor) {
this.applyChange("");
}
else if (c.col > 0) {
const lineStart = currentLine.slice(0, c.col);
const indentUnit = '  ';
if (lineStart.trim() === '' && c.col % indentUnit.length === 0) {
this.state.selectionAnchor = { row: c.row, col: c.col - indentUnit.length };
}
else {
let backAmt = 1;
if (c.col >= 2) {
const lastTwo = currentLine.substring(c.col - 2, c.col);
if (/[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(lastTwo)) {
backAmt = 2;
}
}
this.state.selectionAnchor = { row: c.row, col: c.col - backAmt };
}
this.applyChange("");
}
else if (c.row > 0) {
const prevLineLength = lines[c.row - 1].length;
this.applyEditInternal(c.row - 1, prevLineLength, c.row, 0, "", true);
this.state.cursor.row = c.row - 1;
this.state.cursor.col = prevLineLength;
this.state.desiredCol = prevLineLength;
this.state.selectionAnchor = null;
this.finalizeUpdate();
}
return;
}
if (k === 'Delete') {
e.preventDefault();
if (this.state.selectionAnchor) this.applyChange("");
else if (c.col < currentLine.length) {
this.state.selectionAnchor = { row: c.row, col: c.col + 1 };
const oldC = { ...c };
this.applyChange("");
this.state.cursor = oldC;
this.finalizeUpdate();
}
else if (c.row < lines.length - 1) {
this.state.selectionAnchor = { row: c.row + 1, col: 0 };
const oldC = { ...c };
this.applyChange("");
this.state.cursor = oldC;
this.finalizeUpdate();
}
return;
}
const nav = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Home', 'End', 'PageUp', 'PageDown'];
if (nav.includes(k)) {
e.preventDefault();
if (e.shiftKey) {
if (!this.state.selectionAnchor) this.state.selectionAnchor = { ...c };
} else {
this.state.selectionAnchor = null;
}
this.handleNavigation(k, ctrl);
this.render();
return;
}
if (k.length === 1 && !ctrl && !e.altKey) {
e.preventDefault();
this.applyChange(k);
}
}
handleNavigation(k, wordJump) {
const { cursor: c, lines: l } = this.state;
let tr = c.row, tc = c.col;
const lineText = l[tr];
if (k === 'ArrowUp') {
if (tr > 0) tr--;
tc = Math.min(this.state.desiredCol, l[tr].length);
}
else if (k === 'ArrowDown') {
if (tr < l.length - 1) tr++;
tc = Math.min(this.state.desiredCol, l[tr].length);
}
else if (k === 'ArrowLeft') {
if (wordJump) {
tc = this.findWordBoundary(tr, tc, -1);
}
else if (tc > 0) {
let isEmoji = false;
if (tc >= 2) {
const high = lineText.charCodeAt(tc - 2);
const low = lineText.charCodeAt(tc - 1);
if (high >= 0xD800 && high <= 0xDBFF && low >= 0xDC00 && low <= 0xDFFF) {
isEmoji = true;
}
}
tc -= isEmoji ? 2 : 1;
}
else if (tr > 0) {
tr--; tc = l[tr].length;
}
this.state.desiredCol = tc;
}
else if (k === 'ArrowRight') {
if (wordJump) {
tc = this.findWordBoundary(tr, tc, 1);
}
else if (tc < lineText.length) {
const cp = lineText.codePointAt(tc);
tc += (cp > 0xFFFF) ? 2 : 1;
}
else if (tr < l.length - 1) {
tr++; tc = 0;
}
this.state.desiredCol = tc;
}
else if (k === 'Home') {
const fc = (l[tr].match(/^\s*/) || [''])[0].length;
tc = (tc === fc) ? 0 : fc;
this.state.desiredCol = tc;
} else if (k === 'End') {
tc = l[tr].length;
this.state.desiredCol = tc;
} else if (k === 'PageUp') {
tr = Math.max(0, tr - Math.floor(this.state.viewportHeight / this.config.lineHeight));
tc = Math.min(tc, l[tr].length);
} else if (k === 'PageDown') {
tr = Math.min(l.length - 1, tr + Math.floor(this.state.viewportHeight / this.config.lineHeight));
tc = Math.min(tc, l[tr].length);
}
c.row = tr; c.col = tc;
this.ensureCursorVisible();
}
findWordBoundary(r, c, d) {
const ln = this.state.lines[r];
let i = c;
if (d > 0) {
if (i >= ln.length) return i;
const type = /\w/.test(ln[i]);
while (i < ln.length && /\w/.test(ln[i]) === type) i++;
} else {
if (i <= 0) return 0;
i--;
const type = /\w/.test(ln[i]);
while (i > 0 && /\w/.test(ln[i - 1]) === type) i--;
}
return i;
}
handlePaste(e) {
e.preventDefault();
const text = (e.clipboardData || window.clipboardData).getData('text').replace(/\r\n/g, '\n').replace(/\r/g, '\n');
this.applyChange(text);
}
handleCopyCut(e, cut) {
const t = this.getSelectionText();
if (t) {
e.preventDefault();
e.clipboardData.setData('text/plain', t);
if (cut) { this.applyChange(""); this.setStatus("Cut"); }
else this.setStatus("Copied");
}
}
handleMouseDown(e) {
if (e.target === this.dom.editor && e.offsetX > this.dom.editor.clientWidth) return;
e.preventDefault();
const now = Date.now();
this.state.clickCount = (now - this.state.lastClickTime < 300) ? this.state.clickCount + 1 : 1;
this.state.lastClickTime = now;
const p = this.getPosFromMouse(e);
const lineText = this.state.lines[p.row];
let startCol, endCol, startRow, endRow;
if (this.state.clickCount === 2) {
let foundString = false;
const stringMatch = lineText.match(/("|')(.*?)("|')/g);
if (stringMatch) {
let offset = 0;
for (const match of stringMatch) {
const startIdx = lineText.indexOf(match, offset);
const endIdx = startIdx + match.length;
if (p.col > startIdx && p.col < endIdx) {
startCol = startIdx + 1;
endCol = endIdx - 1;
foundString = true;
break;
}
offset = endIdx;
}
}
if (!foundString) {
startCol = this.findWordBoundary(p.row, p.col, -1);
endCol = this.findWordBoundary(p.row, p.col, 1);
}
startRow = p.row;
endRow = p.row;
} else if (this.state.clickCount === 3) {
startRow = p.row;
endRow = p.row;
startCol = (lineText.match(/^\s*/) || [''])[0].length;
endCol = lineText.length;
} else {
this.state.selectionAnchor = null;
this.state.cursor = { ...p };
startRow = p.row; startCol = p.col;
endRow = p.row; endCol = p.col;
this.state.isDragging = true;
this.state.selectionAnchor = { ...p };
}
if (this.state.clickCount > 1) {
this.state.isDragging = false;
this.state.selectionAnchor = null;
this.state.selectionAnchor = { row: startRow, col: startCol };
this.state.cursor = { row: endRow, col: endCol };
} else {
this.state.cursor = { row: startRow, col: startCol };
}
this.state.desiredCol = this.state.cursor.col;
this.dom.editor.focus();
this.render();
}
handleMouseMove(e) {
if (!this.state.isDragging) return;
const p = this.getPosFromMouse(e);
this.state.cursor = { ...p };
this.state.desiredCol = p.col;
const rect = this.dom.editor.getBoundingClientRect();
const mouseX = e.clientX - rect.left;
const edgeMargin = 50;
const isNearEdge = mouseX < edgeMargin || mouseX > rect.width - edgeMargin;
if (isNearEdge) {
this.ensureCursorVisible();
} else {
const { row } = this.state.cursor;
const { lineHeight } = this.config;
const top = row * lineHeight;
const bottom = top + lineHeight;
const vH = this.state.viewportHeight;
const sT = this.dom.editor.scrollTop;
if (top < sT) this.dom.editor.scrollTop = top;
else if (bottom > sT + vH) this.dom.editor.scrollTop = bottom - vH;
}
this.render();
}
handleMouseUp() {
this.state.isDragging = false;
const { cursor, selectionAnchor } = this.state;
if (selectionAnchor && cursor.row === selectionAnchor.row && cursor.col === selectionAnchor.col) {
this.state.selectionAnchor = null;
}
this.render();
}
getPosFromMouse(e) {
const r = this.dom.editor.getBoundingClientRect();
const x = e.clientX - r.left + this.dom.editor.scrollLeft;
const y = e.clientY - r.top + this.dom.editor.scrollTop;
let row = Math.floor(y / this.config.lineHeight);
let col = Math.floor(((x - this.config.xOffset) / this.config.charWidth) + 0.25);
row = Math.max(0, Math.min(row, this.state.lines.length - 1));
const line = this.state.lines[row];
col = Math.max(0, Math.min(col, line.length));
if (col > 0 && col < line.length) {
const high = line.charCodeAt(col - 1);
const low = line.charCodeAt(col);
if (high >= 0xD800 && high <= 0xDBFF && low >= 0xDC00 && low <= 0xDFFF) {
col++;
}
}
return { row, col };
}
ensureCursorVisible() {
const { row, col } = this.state.cursor;
const { lineHeight, charWidth, xOffset } = this.config;
const top = row * lineHeight;
const bottom = top + lineHeight;
const vH = this.state.viewportHeight;
const sT = this.dom.editor.scrollTop;
if (top < sT) this.dom.editor.scrollTop = top;
else if (bottom > sT + vH) this.dom.editor.scrollTop = bottom - vH;
const left = xOffset + (col * charWidth);
const sL = this.dom.editor.scrollLeft;
const cW = this.dom.editor.clientWidth;
if (left < sL + xOffset) this.dom.editor.scrollLeft = Math.max(0, left - xOffset - 20);
else if (left > sL + cW) this.dom.editor.scrollLeft = left - cW + 20;
}
blockEdit(mod, sr = null, er = null) {
const { cursor: c, selectionAnchor: s, lines: l } = this.state;
sr = sr ?? Math.min(c.row, s ? s.row : c.row);
er = er ?? Math.max(c.row, s ? s.row : c.row);
const orig = l.slice(sr, er + 1).join('\n');
const modded = l.slice(sr, er + 1).map(mod).join('\n');
if (orig !== modded) {
this.applyEditInternal(sr, 0, er, l[er].length, modded, true);
this.state.selectionAnchor = { row: sr, col: 0 };
this.state.cursor = { row: er, col: l[er].length };
this.finalizeUpdate();
}
}
async handleGlobalShortcuts(e) {
const k = e.key.toLowerCase();
const ctrl = e.ctrlKey || e.metaKey;
const alt = e.altKey;
if (ctrl) {
if (k === 'z') {
e.preventDefault();
e.shiftKey ? this.history.redo() : this.history.undo();
this.setStatus(e.shiftKey ? "Redo" : "Undo");
}
if (k === 'y') {
e.preventDefault();
this.history.redo();
this.setStatus("Redo");
}
if (k === 'a') {
e.preventDefault();
this.state.selectionAnchor = { row: 0, col: 0 };
this.state.cursor = {
row: this.state.lines.length - 1,
col: this.state.lines[this.state.lines.length - 1].length
};
this.render();
}
}
if (alt) {
if (k === 's') { e.preventDefault(); await this.saveFile(); }
if (k === 'o') { e.preventDefault(); await this.openFile(); }
if (k === 'n') { e.preventDefault(); this.newFile(); }
if (k === 'p') { e.preventDefault(); this.previewFile(); }
if (k === 'i') { e.preventDefault(); this.smartIndent(); }
if (k === 'r') { e.preventDefault(); this.removeComments(); }
if (k === 'e') { e.preventDefault(); this.removeEmptyLines(); }
}
}
getSelectionText() {
const { cursor: c, selectionAnchor: s, lines: l } = this.state;
if (!s || (s.row === c.row && s.col === c.col)) return null;
const start = (s.row < c.row || (s.row === c.row && s.col < c.col)) ? s : c;
const end = (start === s) ? c : s;
if (start.row === end.row) return l[start.row].slice(start.col, end.col);
const r = [l[start.row].slice(start.col)];
for (let i = start.row + 1; i < end.row; i++) r.push(l[i]);
r.push(l[end.row].slice(0, end.col));
return r.join('\n');
}
newFile() {
if (this.state.isDirty && !confirm("Discard changes?")) {
this.dom.editor.focus();
return;
}
this.state.lines = [""];
this.state.cursor = { row: 0, col: 0 };
this.state.selectionAnchor = null;
this.state.fileName = 'Untitled.txt';
this.state.fileHandle = null;
this.highlighter.analyze(this.state.lines);
this.setDirty(false);
this.history.undoStack = [];
this.finalizeUpdate();
this.setStatus("New File");
this.dom.editor.focus();
}
previewFile() {
const win = window.open();
if (win) { win.document.write(this.state.lines.join('\n')); win.document.close(); }
this.dom.editor.focus();
}
setDirty(dirty) {
this.state.isDirty = dirty;
this.dom.fileStatus.textContent = (dirty ? "* " : "") + this.state.fileName;
document.title = this.dom.fileStatus.textContent + " - Mastodon";
}
setStatus(msg) {
this.dom.messageArea.textContent = msg;
clearTimeout(this.statusTimeout);
this.statusTimeout = setTimeout(() => this.dom.messageArea.textContent = 'Mastodon Engine', 3000);
}
async openFile() {
if (this.state.isDirty && !confirm("Discard changes?")) {
this.dom.editor.focus();
return;
}
try {
const [h] = await window.showOpenFilePicker();
const f = await h.getFile();
this.state.fileHandle = h;
this.state.lines = (await f.text()).split(/\r\n|\n|\r/);
this.state.fileName = f.name;
this.state.cursor = { row: 0, col: 0 };
this.state.selectionAnchor = null;
this.highlighter.analyze(this.state.lines);
this.setDirty(false);
this.history.undoStack = [];
this.finalizeUpdate();
this.setStatus("Opened: " + f.name);
} catch (e) {
} finally {
this.dom.editor.focus();
}
}
async saveFile() {
if (!this.state.fileHandle) {
try {
this.state.fileHandle = await window.showSaveFilePicker({ suggestedName: this.state.fileName });
this.state.fileName = this.state.fileHandle.name;
} catch (e) {
this.dom.editor.focus();
return;
}
}
try {
const w = await this.state.fileHandle.createWritable();
await w.write(this.state.lines.join('\n'));
await w.close();
this.setDirty(false);
this.setStatus("Saved!");
} catch (e) {
this.setStatus("Save failed");
} finally {
this.dom.editor.focus();
}
}
}
window.onload = () => {
window.editor = new EditorEngine();
checkIntroModal();
};
</script>
</body>
</html>