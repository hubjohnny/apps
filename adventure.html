<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Adventure</title>
<style>
@font-face {
font-family: 'NotoMini';
src: url('data:application/octet-stream;base64,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') format('woff2');
}
body,
html {
margin: 0;
padding: 0;
overflow: hidden;
font-family: sans-serif;
background-color: #1a1a1a;
display: flex;
flex-direction: column;
height: 100vh;
}
#game-container {
flex-grow: 1;
display: flex;
justify-content: center;
align-items: center;
width: 100%;
height: auto;
background-color: #245E28;
position: relative;
overflow: hidden;
transition: background-color 2s ease-in-out;
}
#game-world {
position: absolute;
width: 100%;
height: 100%;
}
#night-overlay {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: #000033;
opacity: 0;
z-index: 2;
pointer-events: none;
transition: opacity 5s ease-in-out;
mask-image: radial-gradient(circle 12vmin at center, transparent 0%, black 100%);
-webkit-mask-image: radial-gradient(circle 12vmin at center, transparent 0%, black 100%);
}
#night-overlay.is-night {
opacity: 0.85;
}
#rain-container {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
z-index: 3;
pointer-events: none;
overflow: hidden;
}
.raindrop {
position: absolute;
width: 2px;
height: 12px;
background-color: rgba(173, 216, 230, 0.6);
border-radius: 1px;
animation: fall linear infinite;
transform-origin: bottom;
will-change: transform;
}
@keyframes fall {
from {
transform: translateY(-20vh) translateX(-5vw) rotate(20deg);
}
to {
transform: translateY(120vh) translateX(-15vw) rotate(20deg);
}
}
#lightning-flash {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: #ffffff;
opacity: 0;
z-index: 4;
pointer-events: none;
transition: opacity 0.5s ease-out;
}
#map-grid {
position: absolute;
transform-origin: top left;
}
.cell {
position: absolute;
width: 8vmin;
height: 8vmin;
font-size: 6.5vmin;
display: flex;
justify-content: center;
align-items: center;
user-select: none;
line-height: 1;
}
@keyframes shake {
0%,
100% {
transform: translate(0, 0) rotate(0);
}
25% {
transform: translate(-3px, 0) rotate(-1deg);
}
50% {
transform: translate(3px, 0) rotate(1deg);
}
75% {
transform: translate(-3px, 0) rotate(-1deg);
}
}
.shaking {
animation: shake 0.15s linear;
}
@keyframes pulse {
0%,
100% {
transform: scale(1);
}
50% {
transform: scale(1.1);
}
}
@keyframes pulse-red {
0%,
100% {
transform: scale(1);
color: #ffcdd2;
background-color: rgba(239, 83, 80, 0.7);
}
50% {
transform: scale(1.05);
color: #ffffff;
background-color: rgba(244, 67, 54, 0.9);
}
}
.hud-item.low-health-warning {
animation: pulse-red 1s infinite ease-in-out;
border-radius: 8px;
}
.cell.path {
background-color: rgba(224, 224, 224, 0.3);
}
.cell.underworld-path {
background-color: #4a4a4a;
}
.cell.shelter {
font-size: 7vmin;
}
.cell.large {
font-size: 8vmin;
}
.cell.medium {
font-size: 7vmin;
}
.cell.small {
font-size: 2.5vmin;
display: flex;
align-items: flex-end;
padding-bottom: 5px;
}
#player,
.monster-container,
.npc-container {
position: absolute;
width: 8vmin;
height: 8vmin;
z-index: 5;
will-change: transform;
transform-origin: center center;
text-shadow:
-1px 0 0 #000,
1px 0 0 #000,
0 -1px 0 #000,
0 1px 0 #000;
}
.player-sprite,
.monster-sprite,
.npc-sprite {
width: 100%;
height: 100%;
font-size: 6.5vmin;
display: flex;
justify-content: center;
align-items: center;
transform-origin: center center;
user-select: none;
-webkit-tap-highlight-color: transparent;
background-color: transparent;
}
.fighting-monster .monster-sprite {
cursor: crosshair;
animation: pulse 1s infinite;
}
@keyframes walk-bob {
0%,
100% {
transform: translateY(0);
}
50% {
transform: translateY(-8%);
}
}
#player.is-walking .player-sprite {
animation: walk-bob 0.4s infinite ease-in-out;
}
#player-floating-text-container {
position: absolute;
top: -85px;
left: 50%;
transform: translateX(-50%);
width: 250px;
display: flex;
flex-direction: column-reverse;
align-items: center;
z-index: 10;
pointer-events: none;
}
.floating-text {
background: rgba(26, 26, 26, 0.85);
color: #f0f0f0;
padding: 5px 12px;
border-radius: 12px;
font-size: 1.8vmin;
font-weight: bold;
text-align: center;
margin-bottom: 5px;
white-space: nowrap;
animation: fade-out-up 3s ease-out forwards;
}
@keyframes fade-out-up {
0% {
opacity: 1;
transform: translateY(0);
}
80% {
opacity: 1;
transform: translateY(0);
}
100% {
opacity: 0;
transform: translateY(-20px);
}
}
.arrow {
position: absolute;
font-size: 4vmin;
z-index: 6;
pointer-events: none;
color: #5d4037;
will-change: transform, left, top;
}
#hud {
position: absolute;
top: 10px;
left: 50%;
transform: translateX(-50%);
width: auto;
min-width: 80vw;
background: #512DA8;
background-image: linear-gradient(to bottom, #7E57C2, #512DA8);
border: 4px solid #311B92;
color: #EDE7F6;
display: flex;
justify-content: flex-start;
align-items: center;
padding: 5px;
font-size: 2.2vmin;
font-weight: bold;
z-index: 10;
border-radius: 12px;
overflow-x: auto;
gap: 0.5rem;
}
.hud-item {
display: flex;
flex-direction: column;
align-items: center;
padding: 0 8px;
white-space: nowrap;
}
.hud-label {
font-size: 1.8vmin;
opacity: 0.8;
}
.hud-value {
font-size: 3vmin;
}
#key-display,
#time-display {
font-size: 3.5vmin;
}
#weapon-bar {
display: flex;
flex-direction: row;
align-items: center;
gap: 5px;
border: 2px solid #311B92;
border-radius: 8px;
padding: 2px 5px;
background: rgba(0, 0, 0, 0.2);
}
.weapon-slot {
display: flex;
flex-direction: column;
align-items: center;
padding: 2px 4px;
border-radius: 4px;
transition: background-color 0.2s, transform 0.2s;
}
.weapon-slot.active {
background-color: rgba(255, 255, 255, 0.3);
transform: scale(1.1);
}
.weapon-key {
font-size: 1.5vmin;
font-weight: bold;
color: #fff;
}
.weapon-emoji {
font-size: 3.5vmin;
}
.game-button {
position: absolute;
z-index: 15;
padding: 10px 15px;
font-size: 2vmin;
font-weight: bold;
background: #512DA8;
border: 3px solid #311B92;
color: #EDE7F6;
border-radius: 8px;
cursor: pointer;
transition: transform 0.1s ease, background-color 0.2s;
}
.game-button:hover {
transform: scale(1.05);
background-color: #7E57C2;
}
.game-button.top-left {
top: 15px;
left: 15px;
}
.game-button.top-right {
top: 15px;
right: 15px;
}
.health-bar-container {
position: absolute;
bottom: -15px;
left: 5%;
width: 90%;
height: 10px;
background-color: #333;
border: 1px solid #111;
border-radius: 5px;
overflow: hidden;
z-index: 6;
}
#player .health-bar-container {
top: -50px;
bottom: auto;
}
.health-bar-inner {
height: 100%;
width: 100%;
border-radius: 4px;
transition: width 0.3s ease-out;
}
.health-bar-inner.player {
background-color: #4caf50;
}
.health-bar-inner.monster {
background-color: #f44336;
}
#player .status-bar-container {
position: absolute;
top: -50px;
left: 10%;
width: 80%;
height: 8px;
background-color: rgba(20, 20, 20, 0.7);
border: 1px solid #111;
border-radius: 4px;
z-index: 6;
opacity: 1;
transition: opacity 0.5s ease-in-out;
}
#player .status-bar-container.fading-out {
opacity: 0;
}
#player .status-bar-inner {
height: 100%;
width: 100%;
background-color: #4caf50;
transition: width 0.3s ease-out;
}
#message-overlay {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.7);
display: flex;
justify-content: center;
align-items: center;
z-index: 20;
}
#message-box {
background: #2a2135;
color: #f0f0f0;
border: 4px solid #311B92;
padding: 15px 20px;
border-radius: 10px;
width: 80vw;
max-width: 1200px;
max-height: 85vh;
overflow-y: auto;
display: flex;
flex-direction: column;
}
#message-text {
font-size: 2.2vmin;
margin-bottom: 25px;
text-align: left;
flex-grow: 1;
}
#message-text h2.how-to-play-title,
#message-text h3 {
text-align: center;
color: #7E57C2;
margin: 0;
}
.how-to-play-columns {
display: flex;
flex-direction: row;
flex-wrap: wrap;
gap: 2.5rem;
align-items: flex-start;
width: 100%;
}
.how-to-play-column {
flex: 1;
min-width: 280px;
}
.how-to-play-column h3 {
margin-top: 0;
margin-bottom: 10px;
}
.how-to-play-column ul {
padding-left: 20px;
margin: 0;
list-style-position: outside;
}
.how-to-play-column li {
margin-bottom: 6px;
}
.how-to-play-column li::marker {
color: #7E57C2;
}
.how-to-play-final-message {
text-align: center;
margin-top: 25px;
width: 100%;
}
#message-options {
display: flex;
justify-content: center;
gap: 5px;
margin-top: 0;
flex-shrink: 0;
}
.message-option-button {
padding: 10px 20px;
border: 2px solid #311B92;
background-color: #512DA8;
color: #EDE7F6;
font-size: 2vmin;
font-weight: bold;
border-radius: 5px;
cursor: pointer;
transition: background-color 0.2s;
}
.message-option-button:hover {
background-color: #7E57C2;
}
#message-box.has-options #message-button {
display: none;
}
#message-button {
padding: 12px 24px;
border: 2px solid #311B92;
background-color: #512DA8;
color: #EDE7F6;
font-size: 2.5vmin;
font-weight: bold;
border-radius: 5px;
cursor: pointer;
transition: background-color 0.2s;
margin: 0 auto;
flex-shrink: 0;
}
#message-button:hover {
background-color: #7E57C2;
}
.hidden {
display: none !important;
}
::-webkit-scrollbar {
width: 8px;
height: 8px;
}
::-webkit-scrollbar-track {
background: #2a2135;
}
::-webkit-scrollbar-thumb {
background: #512DA8;
border-radius: 4px;
}
::-webkit-scrollbar-thumb:hover {
background: #7E57C2;
}
* {
scrollbar-width: thin;
scrollbar-color: #512DA8 #2a2135;
}
body, .cell, .game-button, .player-sprite, .monster-sprite, .hud-value {
font-family: sans-serif, 'NotoMini' !important;
}
</style>
</head>
<body>
<div id="game-container">
<div id="rain-container"></div>
<div id="lightning-flash"></div>
<button id="how-to-play-button" class="game-button top-left"></button>
<div style="position: absolute; top: 15px; right: 15px; z-index: 15; display: flex; flex-direction: column; gap: 10px;">
<button id="save-game-button" class="game-button" style="position: static;" title="Quick Save (Local)"></button>
<button id="export-btn" class="game-button" style="position: static;" title="Export Save"></button>
<button id="import-btn" class="game-button" style="position: static;" title="Import Save"></button>
</div>
<input type="file" id="import-input" accept=".json" style="display: none;">
<div id="hud">
<div class="hud-item">
<span class="hud-label">Level</span>
<span id="level-display" class="hud-value">1</span>
</div>
<div class="hud-item" id="hud-hp">
<span class="hud-label"> Health</span>
<span id="hp-display" class="hud-value">100/100</span>
</div>
<div class="hud-item" id="hud-strength">
<span class="hud-label"> Strength</span>
<span id="strength-display" class="hud-value">5</span>
</div>
<div class="hud-item" id="hud-weapon">
<span class="hud-label">Weapon</span>
<div id="weapon-bar"></div>
</div>
<div class="hud-item" id="hud-xp">
<span class="hud-label"> XP</span>
<span id="xp-display" class="hud-value">0/20</span>
</div>
<div class="hud-item">
<span class="hud-label"> Wood</span>
<span id="wood-display" class="hud-value">0</span>
</div>
<div class="hud-item">
<span class="hud-label"> Stone</span>
<span id="stone-display" class="hud-value">0</span>
</div>
<div class="hud-item">
<span class="hud-label"> Gem</span>
<span id="gem-display" class="hud-value">0</span>
</div>
<div class="hud-item">
<span class="hud-label"> Herb</span>
<span id="herb-display" class="hud-value">0</span>
</div>
<div class="hud-item">
<span class="hud-label"> Arrows</span>
<span id="arrows-display" class="hud-value">0</span>
</div>
<div class="hud-item">
<span class="hud-label"> Key</span>
<span id="key-display" class="hud-value"></span>
</div>
<div class="hud-item">
<span id="time-display" class="hud-value"> Day</span>
</div>
</div>
<div id="game-world" oncontextmenu="return false;">
<div id="player">
<div id="player-floating-text-container"></div>
<div class="player-sprite"></div>
</div>
</div>
<div id="night-overlay"></div>
</div>
<div id="message-overlay" class="hidden">
<div id="message-box">
<div id="message-text"></div>
<div id="message-options"></div>
<button id="message-button">OK</button>
</div>
</div>
<script>
const audioManager = {
context: null,
isInitialized: false,
mainGain: null,
activeAmbiance: {},
birdChirpTimer: null,
owlHootTimer: null,
soundCooldowns: {},
init: function () {
if (this.isInitialized) return;
try {
this.context = new (window.AudioContext || window.webkitAudioContext)();
this.mainGain = this.context.createGain();
this.mainGain.connect(this.context.destination);
this.mainGain.gain.setValueAtTime(1.0, this.context.currentTime);
this.isInitialized = true;
console.log("Audio Context er initialisert.");
} catch (e) {
console.error("Web Audio API stttes ikke i denne nettleseren.", e);
}
},
sounds: {
'tree_chop': (ctx, dest) => {
const bufferSize = ctx.sampleRate * 0.1;
const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
const data = buffer.getChannelData(0);
for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
const noise = ctx.createBufferSource();
noise.buffer = buffer;
const filter = ctx.createBiquadFilter();
filter.type = 'lowpass';
filter.frequency.setValueAtTime(1000, ctx.currentTime);
const gain = ctx.createGain();
gain.gain.setValueAtTime(0.3, ctx.currentTime);
gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);
noise.connect(filter).connect(gain).connect(dest);
noise.start(ctx.currentTime);
noise.stop(ctx.currentTime + 0.1);
},
'item_pickup': (ctx, dest) => {
const osc = ctx.createOscillator();
osc.type = 'sine';
osc.frequency.setValueAtTime(600, ctx.currentTime);
osc.frequency.linearRampToValueAtTime(1200, ctx.currentTime + 0.1);
const gain = ctx.createGain();
gain.gain.setValueAtTime(0.2, ctx.currentTime);
gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);
osc.connect(gain).connect(dest);
osc.start(ctx.currentTime);
osc.stop(ctx.currentTime + 0.1);
},
'wind_ambiance': (ctx, dest) => {
const t = ctx.currentTime;
const bufferSize = 5 * ctx.sampleRate;
const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
const output = buffer.getChannelData(0);
for (let i = 0; i < bufferSize; i++) {
output[i] = (Math.random() * 2 - 1) * 0.3;
}
const fadeLength = Math.floor(ctx.sampleRate * 0.01);
for (let i = 0; i < fadeLength; i++) {
output[i] *= (i / fadeLength);
output[bufferSize - 1 - i] *= (i / fadeLength);
}
const noiseNode = ctx.createBufferSource();
noiseNode.buffer = buffer;
noiseNode.loop = true;
const filter = ctx.createBiquadFilter();
filter.type = 'lowpass';
filter.frequency.setValueAtTime(300, t);
filter.Q.setValueAtTime(1, t);
const lfoFilterSlow = ctx.createOscillator();
lfoFilterSlow.type = 'sine';
lfoFilterSlow.frequency.setValueAtTime(0.08, t);
const lfoFilterSlowGain = ctx.createGain();
lfoFilterSlowGain.gain.setValueAtTime(100, t);
lfoFilterSlow.connect(lfoFilterSlowGain).connect(filter.frequency);
const lfoFilterFast = ctx.createOscillator();
lfoFilterFast.type = 'sine';
lfoFilterFast.frequency.setValueAtTime(0.3, t);
const lfoFilterFastGain = ctx.createGain();
lfoFilterFastGain.gain.setValueAtTime(50, t);
lfoFilterFast.connect(lfoFilterFastGain).connect(filter.frequency);
const masterGain = ctx.createGain();
masterGain.gain.setValueAtTime(0.8, t);
const lfoVolume = ctx.createOscillator();
lfoVolume.type = 'sine';
lfoVolume.frequency.setValueAtTime(0.11, t);
const lfoVolumeGain = ctx.createGain();
lfoVolumeGain.gain.setValueAtTime(0.2, t);
lfoVolume.connect(lfoVolumeGain).connect(masterGain.gain);
noiseNode.connect(filter).connect(masterGain).connect(dest);
lfoFilterSlow.start(t);
lfoFilterFast.start(t);
lfoVolume.start(t);
noiseNode.start(t);
return {
lfo: lfoFilterSlow,
lfoFilterSlow,
lfoFilterFast,
lfoVolume,
noiseNode
};
},
'bird_chirp_1': (ctx, dest) => {
const t = ctx.currentTime;
const gain = ctx.createGain();
gain.gain.setValueAtTime(0, t);
gain.gain.linearRampToValueAtTime(0.08, t + 0.01);
gain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
gain.connect(dest);
const osc1 = ctx.createOscillator();
osc1.type = 'triangle';
osc1.frequency.setValueAtTime(3500, t);
osc1.frequency.linearRampToValueAtTime(2800, t + 0.08);
const osc2 = ctx.createOscillator();
osc2.type = 'sine';
osc2.frequency.setValueAtTime(3520, t);
osc2.frequency.linearRampToValueAtTime(2820, t + 0.08);
osc1.connect(gain);
osc2.connect(gain);
osc1.start(t);
osc2.start(t);
osc1.stop(t + 0.08);
osc2.stop(t + 0.08);
},
'bird_chirp_2': (ctx, dest) => {
const t = ctx.currentTime;
const osc = ctx.createOscillator();
osc.type = 'triangle';
osc.frequency.setValueAtTime(3000, t);
osc.frequency.linearRampToValueAtTime(3800, t + 0.04);
osc.frequency.linearRampToValueAtTime(3200, t + 0.08);
osc.frequency.linearRampToValueAtTime(3900, t + 0.12);
const gain = ctx.createGain();
gain.gain.setValueAtTime(0, t);
gain.gain.linearRampToValueAtTime(0.07, t + 0.01);
gain.gain.exponentialRampToValueAtTime(0.001, t + 0.42);
osc.connect(gain).connect(dest);
osc.start(t);
osc.stop(t + 0.12);
},
'bird_chirp_3': (ctx, dest) => {
const t = ctx.currentTime;
const totalDuration = 0.5;
const osc = ctx.createOscillator();
osc.type = 'triangle';
osc.frequency.setValueAtTime(4000, t);
osc.frequency.linearRampToValueAtTime(3500, t + totalDuration);
const lfo = ctx.createOscillator();
lfo.type = 'sine';
lfo.frequency.setValueAtTime(30, t);
lfo.frequency.linearRampToValueAtTime(20, t + totalDuration);
const lfoGain = ctx.createGain();
lfoGain.gain.setValueAtTime(100, t);
lfo.connect(lfoGain).connect(osc.frequency);
const gain = ctx.createGain();
gain.gain.setValueAtTime(0, t);
gain.gain.linearRampToValueAtTime(0.06, t + 0.02);
gain.gain.exponentialRampToValueAtTime(0.001, t + totalDuration);
osc.connect(gain).connect(dest);
lfo.start(t);
osc.start(t);
lfo.stop(t + totalDuration);
osc.stop(t + totalDuration);
},
'player_attack_unarmed': (ctx, dest) => {
const t = ctx.currentTime;
const osc = ctx.createOscillator();
osc.type = 'triangle';
osc.frequency.setValueAtTime(180, t);
osc.frequency.exponentialRampToValueAtTime(100, t + 0.1);
const gain = ctx.createGain();
gain.gain.setValueAtTime(0, t);
gain.gain.linearRampToValueAtTime(0.4, t + 0.01);
gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
osc.connect(gain).connect(dest);
osc.start(t);
osc.stop(t + 0.1);
},
'player_attack_sword': (ctx, dest) => {
const t = ctx.currentTime;
const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.15, ctx.sampleRate);
const data = buffer.getChannelData(0);
for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
const noise = ctx.createBufferSource();
noise.buffer = buffer;
const filter = ctx.createBiquadFilter();
filter.type = 'bandpass';
filter.frequency.setValueAtTime(1500, t);
filter.Q.setValueAtTime(10, t);
const gain = ctx.createGain();
gain.gain.setValueAtTime(0, t);
gain.gain.linearRampToValueAtTime(0.3, t + 0.01);
gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
noise.connect(filter).connect(gain).connect(dest);
noise.start(t);
noise.stop(t + 0.15);
},
'player_attack_sledge': (ctx, dest) => {
const t = ctx.currentTime;
const osc = ctx.createOscillator();
osc.type = 'square';
osc.frequency.setValueAtTime(120, t);
osc.frequency.exponentialRampToValueAtTime(80, t + 0.15);
const gain = ctx.createGain();
gain.gain.setValueAtTime(0, t);
gain.gain.linearRampToValueAtTime(0.4, t + 0.01);
gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
osc.connect(gain).connect(dest);
osc.start(t);
osc.stop(t + 0.15);
},
'arrow_shoot_swoosh': (ctx, dest) => {
const t = ctx.currentTime;
const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.2, ctx.sampleRate);
const data = buffer.getChannelData(0);
for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
const noise = ctx.createBufferSource();
noise.buffer = buffer;
const filter = ctx.createBiquadFilter();
filter.type = 'bandpass';
filter.frequency.setValueAtTime(3000, t);
filter.Q.setValueAtTime(5, t);
const gain = ctx.createGain();
gain.gain.setValueAtTime(0, t);
gain.gain.linearRampToValueAtTime(0.3, t + 0.01);
gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
noise.connect(filter).connect(gain).connect(dest);
noise.start(t);
noise.stop(t + 0.2);
},
'arrow_hit_thud': (ctx, dest) => {
const t = ctx.currentTime;
const osc = ctx.createOscillator();
osc.type = 'triangle';
osc.frequency.setValueAtTime(150, t);
osc.frequency.exponentialRampToValueAtTime(100, t + 0.08);
const gain = ctx.createGain();
gain.gain.setValueAtTime(0, t);
gain.gain.linearRampToValueAtTime(0.5, t + 0.01);
gain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
osc.connect(gain).connect(dest);
osc.start(t);
osc.stop(t + 0.08);
},
'monster_die_xp': (ctx, dest) => {
const t = ctx.currentTime;
const noiseBuffer = ctx.createBuffer(1, ctx.sampleRate * 0.2, ctx.sampleRate);
const data = noiseBuffer.getChannelData(0);
for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
const noise = ctx.createBufferSource();
noise.buffer = noiseBuffer;
const filter = ctx.createBiquadFilter();
filter.type = 'lowpass';
filter.frequency.setValueAtTime(1000, t);
filter.frequency.exponentialRampToValueAtTime(200, t + 0.2);
const noiseGain = ctx.createGain();
noiseGain.gain.setValueAtTime(0.3, t);
noiseGain.gain.linearRampToValueAtTime(0.001, t + 0.2);
noise.connect(filter).connect(noiseGain).connect(dest);
noise.start(t);
noise.stop(t + 0.2);
const osc = ctx.createOscillator();
osc.type = 'triangle';
osc.frequency.setValueAtTime(800, t + 0.1);
osc.frequency.linearRampToValueAtTime(1500, t + 0.2);
const xpGain = ctx.createGain();
xpGain.gain.setValueAtTime(0, t + 0.1);
xpGain.gain.linearRampToValueAtTime(0.2, t + 0.11);
xpGain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
osc.connect(xpGain).connect(dest);
osc.start(t + 0.1);
osc.stop(t + 0.2);
},
'player_walk': (ctx, dest) => {
const t = ctx.currentTime;
const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.08, ctx.sampleRate);
const data = buffer.getChannelData(0);
for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
const noise = ctx.createBufferSource();
noise.buffer = buffer;
const filter = ctx.createBiquadFilter();
filter.type = 'lowpass';
filter.frequency.setValueAtTime(400, t);
const gain = ctx.createGain();
gain.gain.setValueAtTime(0, t);
gain.gain.linearRampToValueAtTime(0.1, t + 0.01);
gain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
noise.connect(filter).connect(gain).connect(dest);
noise.start(t);
noise.stop(t + 0.08);
},
'gather_stone': (ctx, dest) => {
const t = ctx.currentTime;
const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.05, ctx.sampleRate);
const data = buffer.getChannelData(0);
for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
const noise = ctx.createBufferSource();
noise.buffer = buffer;
const filter = ctx.createBiquadFilter();
filter.type = 'highpass';
filter.frequency.setValueAtTime(1500, t);
const gain = ctx.createGain();
gain.gain.setValueAtTime(0.3, t);
gain.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
noise.connect(filter).connect(gain).connect(dest);
noise.start(t);
noise.stop(t + 0.05);
},
'gather_gem': (ctx, dest) => {
const t = ctx.currentTime;
const osc = ctx.createOscillator();
osc.type = 'sine';
osc.frequency.setValueAtTime(2000, t);
osc.frequency.linearRampToValueAtTime(2500, t + 0.1);
const gain = ctx.createGain();
gain.gain.setValueAtTime(0.2, t);
gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
osc.connect(gain).connect(dest);
osc.start(t);
osc.stop(t + 0.1);
},
'gather_herb': (ctx, dest) => {
const t = ctx.currentTime;
const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.1, ctx.sampleRate);
const data = buffer.getChannelData(0);
for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
const noise = ctx.createBufferSource();
noise.buffer = buffer;
const filter = ctx.createBiquadFilter();
filter.type = 'bandpass';
filter.frequency.setValueAtTime(2500, t);
filter.Q.setValueAtTime(10, t);
const gain = ctx.createGain();
gain.gain.setValueAtTime(0.15, t);
gain.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
noise.connect(filter).connect(gain).connect(dest);
noise.start(t);
noise.stop(t + 0.1);
},
'night_ambiance': (ctx, dest) => {
const bufferSize = 2 * ctx.sampleRate;
const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
const output = buffer.getChannelData(0);
for (let i = 0; i < bufferSize; i++) {
output[i] = (Math.random() * 2 - 1) * 0.3;
if (i > 0) output[i] = (output[i - 1] + (0.08 * output[i])) / 1.08;
}
const noiseNode = ctx.createBufferSource();
noiseNode.buffer = buffer;
noiseNode.loop = true;
const filter = ctx.createBiquadFilter();
filter.type = 'lowpass';
filter.frequency.setValueAtTime(200, ctx.currentTime);
filter.Q.setValueAtTime(1, ctx.currentTime);
const lfo = ctx.createOscillator();
lfo.type = 'sine';
lfo.frequency.setValueAtTime(0.05, ctx.currentTime);
const lfoGain = ctx.createGain();
lfoGain.gain.setValueAtTime(100, ctx.currentTime);
lfo.connect(lfoGain).connect(filter.frequency);
noiseNode.connect(filter).connect(dest);
lfo.start(ctx.currentTime);
noiseNode.start(ctx.currentTime);
return { lfo, noiseNode };
},
'owl_hoot': (ctx, dest) => {
const t = ctx.currentTime;
const osc = ctx.createOscillator();
osc.type = 'sine';
osc.frequency.setValueAtTime(500, t);
osc.frequency.linearRampToValueAtTime(400, t + 0.2);
osc.frequency.setValueAtTime(450, t + 0.25);
osc.frequency.linearRampToValueAtTime(350, t + 0.45);
const gain = ctx.createGain();
gain.gain.setValueAtTime(0, t);
gain.gain.linearRampToValueAtTime(0.2, t + 0.05);
gain.gain.setValueAtTime(0.2, t + 0.4);
gain.gain.linearRampToValueAtTime(0, t + 0.45);
osc.connect(gain).connect(dest);
osc.start(t);
osc.stop(t + 0.5);
},
'ghost_spawn': (ctx, dest) => {
const t = ctx.currentTime;
const osc = ctx.createOscillator();
osc.type = 'sine';
osc.frequency.setValueAtTime(150, t);
osc.frequency.linearRampToValueAtTime(250, t + 1.0);
const lfo = ctx.createOscillator();
lfo.type = 'sine';
lfo.frequency.setValueAtTime(5, t);
const lfoGain = ctx.createGain();
lfoGain.gain.setValueAtTime(10, t);
lfo.connect(lfoGain).connect(osc.frequency);
const buffer = ctx.createBuffer(1, ctx.sampleRate * 1.0, ctx.sampleRate);
const data = buffer.getChannelData(0);
for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
const noise = ctx.createBufferSource();
noise.buffer = buffer;
const filter = ctx.createBiquadFilter();
filter.type = 'bandpass';
filter.frequency.setValueAtTime(800, t);
filter.Q.setValueAtTime(5, t);
const gain = ctx.createGain();
gain.gain.setValueAtTime(0, t);
gain.gain.linearRampToValueAtTime(0.2, t + 0.3);
gain.gain.setValueAtTime(0.2, t + 0.7);
gain.gain.linearRampToValueAtTime(0, t + 1.0);
osc.connect(gain).connect(dest);
noise.connect(filter).connect(gain).connect(dest);
lfo.start(t);
osc.start(t);
noise.start(t);
lfo.stop(t + 1.0);
osc.stop(t + 1.0);
noise.stop(t + 1.0);
},
'ambiance_rain': (ctx, dest) => {
const bufferSize = 2 * ctx.sampleRate;
const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
const output = buffer.getChannelData(0);
for (let i = 0; i < bufferSize; i++) {
output[i] = Math.random() * 2 - 1;
}
const noiseNode = ctx.createBufferSource();
noiseNode.buffer = buffer;
noiseNode.loop = true;
const filter = ctx.createBiquadFilter();
filter.type = 'highpass';
filter.frequency.setValueAtTime(1000, ctx.currentTime);
noiseNode.connect(filter).connect(dest);
noiseNode.start(ctx.currentTime);
return { noiseNode };
},
'effect_thunder': (ctx, dest) => {
const t = ctx.currentTime;
const duration = 2.5;
const bufferSize = ctx.sampleRate * duration;
const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
const output = buffer.getChannelData(0);
let lastOut = 0;
for (let i = 0; i < bufferSize; i++) {
const white = Math.random() * 2 - 1;
output[i] = (lastOut + (0.02 * white)) / 1.02;
lastOut = output[i];
output[i] *= 3.5;
}
const noise = ctx.createBufferSource();
noise.buffer = buffer;
const filter = ctx.createBiquadFilter();
filter.type = 'lowpass';
filter.frequency.setValueAtTime(120, t);
filter.frequency.linearRampToValueAtTime(40, t + duration);
const gain = ctx.createGain();
gain.gain.setValueAtTime(0, t);
gain.gain.linearRampToValueAtTime(1.0, t + 0.05);
gain.gain.exponentialRampToValueAtTime(0.01, t + duration);
noise.connect(filter).connect(gain).connect(dest);
noise.start(t);
noise.stop(t + duration);
},
'player_take_damage': (ctx, dest) => {
const t = ctx.currentTime;
const osc = ctx.createOscillator();
osc.type = 'sawtooth';
osc.frequency.setValueAtTime(120, t);
osc.frequency.exponentialRampToValueAtTime(80, t + 0.15);
const gain = ctx.createGain();
gain.gain.setValueAtTime(0, t);
gain.gain.linearRampToValueAtTime(0.3, t + 0.01);
gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
osc.connect(gain).connect(dest);
osc.start(t);
osc.stop(t + 0.15);
},
'door_open_creak': (ctx, dest) => {
const t = ctx.currentTime;
const osc = ctx.createOscillator();
osc.type = 'sawtooth';
osc.frequency.setValueAtTime(120, t);
osc.frequency.linearRampToValueAtTime(150, t + 0.4);
const gain = ctx.createGain();
gain.gain.setValueAtTime(0, t);
gain.gain.linearRampToValueAtTime(0.2, t + 0.1);
gain.gain.setValueAtTime(0.2, t + 0.4);
gain.gain.linearRampToValueAtTime(0, t + 0.5);
osc.connect(gain).connect(dest);
osc.start(t);
osc.stop(t + 0.5);
},
'key_pickup': (ctx, dest) => {
const t = ctx.currentTime;
const osc = ctx.createOscillator();
osc.type = 'sine';
osc.frequency.setValueAtTime(1200, t);
osc.frequency.linearRampToValueAtTime(1800, t + 0.15);
const gain = ctx.createGain();
gain.gain.setValueAtTime(0, t);
gain.gain.linearRampToValueAtTime(0.3, t + 0.01);
gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
osc.connect(gain).connect(dest);
osc.start(t);
osc.stop(t + 0.15);
},
'swan_heal': (ctx, dest) => {
const t = ctx.currentTime;
const osc = ctx.createOscillator();
osc.type = 'triangle';
osc.frequency.setValueAtTime(1500, t);
osc.frequency.exponentialRampToValueAtTime(3000, t + 0.3);
const gain = ctx.createGain();
gain.gain.setValueAtTime(0, t);
gain.gain.linearRampToValueAtTime(0.4, t + 0.05);
gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
osc.connect(gain).connect(dest);
osc.start(t);
osc.stop(t + 0.3);
}
},
playSound: function (name) {
if (!this.isInitialized) this.init();
if (!this.isInitialized || !this.sounds[name]) return;
this.sounds[name](this.context, this.mainGain);
},
playSoundThrottled: function (name, delay) {
if (!this.isInitialized || this.soundCooldowns[name]) {
return;
}
this.playSound(name);
this.soundCooldowns[name] = true;
setTimeout(() => {
this.soundCooldowns[name] = false;
}, delay);
},
startAmbiance: function (name) {
if (!this.isInitialized) this.init();
if (!this.isInitialized || !this.sounds[name] || this.activeAmbiance[name]) return;
console.log('Starter atmosfre:', name);
const gain = this.context.createGain();
gain.connect(this.mainGain);
gain.gain.setValueAtTime(0, this.context.currentTime);
let targetVolume = 0.4;
if (name === 'night_ambiance') targetVolume = 0.3;
if (name === 'ambiance_rain') targetVolume = 0.008;
gain.gain.linearRampToValueAtTime(targetVolume, this.context.currentTime + 3);
const nodes = this.sounds[name](this.context, gain);
this.activeAmbiance[name] = { ...nodes, gainNode: gain };
},
stopAmbiance: function (name) {
if (!this.isInitialized || !this.activeAmbiance[name]) return;
console.log('Stopper atmosfre:', name);
const nodes = this.activeAmbiance[name];
const fadeTime = this.context.currentTime + 2;
nodes.gainNode.gain.cancelScheduledValues(this.context.currentTime);
nodes.gainNode.gain.linearRampToValueAtTime(0.001, fadeTime);
setTimeout(() => {
if (nodes.noiseNode) nodes.noiseNode.stop();
if (nodes.lfo) nodes.lfo.stop();
nodes.gainNode.disconnect();
}, 2100);
delete this.activeAmbiance[name];
},
startBirdSounds: function () {
if (!this.isInitialized || this.birdChirpTimer) return;
console.log("Starter fuglelyder...");
const birdSounds = ['bird_chirp_1', 'bird_chirp_2', 'bird_chirp_3'];
const loop = () => {
const randomDelay = Math.random() * 10000 + 5000;
this.birdChirpTimer = setTimeout(() => {
if (!this.isInitialized) return;
const soundName = birdSounds[Math.floor(Math.random() * birdSounds.length)];
this.playSound(soundName);
loop();
}, randomDelay);
};
loop();
},
stopBirdSounds: function () {
if (this.birdChirpTimer) {
console.log("Stopper fuglelyder...");
clearTimeout(this.birdChirpTimer);
this.birdChirpTimer = null;
}
},
startNightSounds: function () {
if (!this.isInitialized) return;
this.startAmbiance('night_ambiance');
if (this.owlHootTimer) return;
console.log("Starter uglelyder...");
const loop = () => {
const randomDelay = Math.random() * 15000 + 15000;
this.owlHootTimer = setTimeout(() => {
if (!this.isInitialized) return;
this.playSound('owl_hoot');
loop();
}, randomDelay);
};
loop();
},
stopNightSounds: function () {
this.stopAmbiance('night_ambiance');
if (this.owlHootTimer) {
console.log("Stopper uglelyder...");
clearTimeout(this.owlHootTimer);
this.owlHootTimer = null;
}
}
};
document.addEventListener('DOMContentLoaded', () => {
const WORLD_SIZE = {
rows: 150,
cols: 150
};
const DAY_DURATION = 300;
const NIGHT_DURATION = 180;
const PLAYER_SPEED = 200;
const MONSTER_ATTACK_SPEED = 1500;
const NIGHT_STRENGTH_BONUS = 1.75;
const CROSSBOW_BASE_DAMAGE = 10;
const CROSSBOW_STRENGTH_DAMAGE_FACTOR = 4;
const BOSS_AGGRO_RANGE = 3;
const BOSS_CHASE_RANGE = 8;
const GATHERING_HITS = 5;
const GATHER_HP_COST = 10;
const WOOD_PER_TREE = 3;
const STONE_PER_ROCK = 2;
const GEM_PER_ROCK = 1;
const HERB_PER_PLANT = 1;
const BASE_SHELTER_WOOD_COST = 15;
const BASE_SHELTER_HP_COST = 10;
const SHELTER_COST_WOOD_PER_LEVEL = 5;
const SHELTER_COST_HP_PER_LEVEL = 5;
const BASE_CROSSBOW_WOOD_COST = 30;
const BASE_CROSSBOW_HP_COST = 25;
const CROSSBOW_COST_WOOD_PER_LEVEL = 10;
const CROSSBOW_COST_HP_PER_LEVEL = 10;
const ARROW_CRAFTING_COST = 20;
const STONE_SWORD_COST = 20;
const STONE_SLEDGE_COST = 80;
const MIN_FOOD_COUNT = 25;
const FOOD_RESPAWN_AMOUNT = 20;
const TILE = {
PLAYER: '',
EMPTY: ' ',
WALL_1: '',
WALL_2: '',
STONE: '',
DECOR_1: '',
DECOR_2: '',
DECOR_3: '',
DOOR: '',
KEY: '',
MONSTER_1: '',
MONSTER_2: '',
MONSTER_3: '',
BOSS: '',
U_MONSTER_1: '',
U_MONSTER_2: '',
U_MONSTER_3: '',
U_BOSS: '',
FOOD_1: '',
FOOD_2: '',
DEAD: '',
PATH: '',
UW_PATH: '',
SHELTER: '',
CROSSBOW: '',
ARROW: '',
GHOST: '',
STONE_SWORD: '',
STONE_SLEDGE: '',
WATER: '',
SWAN: '',
TRADER: '',
WISE_OLD_MAN: '',
GEM: '',
HERB: '',
UNICORN: '',
CAGE: '',
UNICORN_KEY: ''
};
const WEAPONS = {
'unarmed': {
name: 'Unarmed',
emoji: '',
type: 'melee',
damageBonus: 1.0
},
'crossbow': {
name: 'Crossbow',
emoji: TILE.CROSSBOW,
type: 'ranged'
},
'sword': {
name: 'Stone Sword',
emoji: TILE.STONE_SWORD,
type: 'melee',
damageBonus: 1.2
},
'sledge': {
name: 'Stone Sledgehammer',
emoji: TILE.STONE_SLEDGE,
type: 'melee',
damageBonus: 1.4
},
};
const WEAPON_HOTBAR_ORDER = ['unarmed', 'crossbow', 'sword', 'sledge'];
const OBJECT_DATA = {
[TILE.MONSTER_1]: {
hp: 25,
strength: 6,
xpReward: 10,
type: 'monster',
speed: 80
},
[TILE.MONSTER_2]: {
hp: 45,
strength: 10,
xpReward: 25,
type: 'monster',
speed: 100
},
[TILE.MONSTER_3]: {
hp: 70,
strength: 15,
xpReward: 40,
type: 'monster',
speed: 120
},
[TILE.BOSS]: {
hp: 200,
strength: 30,
xpReward: 100,
type: 'boss',
speed: 150
},
[TILE.U_MONSTER_1]: {
hp: 50,
strength: 12,
xpReward: 20,
type: 'monster',
speed: 90
},
[TILE.U_MONSTER_2]: {
hp: 80,
strength: 8,
xpReward: 15,
type: 'monster',
speed: 60
},
[TILE.U_MONSTER_3]: {
hp: 60,
strength: 18,
xpReward: 35,
type: 'monster',
speed: 130
},
[TILE.U_BOSS]: {
hp: 400,
strength: 45,
xpReward: 250,
type: 'boss',
speed: 160
},
[TILE.GHOST]: {
hp: 50,
strength: 0,
xpReward: 5,
type: 'ghost',
speed: 180
},
[TILE.SWAN]: {
hp: 999,
strength: 0,
xpReward: 0,
type: 'special',
speed: 70
},
[TILE.FOOD_1]: {
hpGain: 10,
type: 'food'
},
[TILE.FOOD_2]: {
hpGain: 20,
type: 'food'
},
[TILE.TRADER]: {
type: 'npc',
speed: 50
},
[TILE.WISE_OLD_MAN]: {
type: 'npc',
speed: 30
},
[TILE.UNICORN]: {
type: 'special'
}
};
const NPC_DATA = {
[TILE.TRADER]: {
getDialogue: () => "Greetings, traveler! I have rare goods, if you have the resources.",
options: (npc) => [{
text: `Trade 50  for 1 `,
action: () => {
if (gameState.player.wood >= 50) {
gameState.player.wood -= 50;
gameState.player.gems += 1;
showMessage(`Trade successful! You received 1 ${TILE.GEM}`);
updateHUD();
} else {
showMessage(`You don't have enough ${TILE.WOOD}!`);
}
}
}, {
text: "Leave",
action: "close"
}]
},
[TILE.WISE_OLD_MAN]: {
getDialogue: () => {
if (!gameState.player.boughtGemUpgrade) {
return "Ah, a fellow adventurer! Those gems  you carry... they pulse with latent energy. For 10 gems, I can unlock your true potential and permanently increase your strength! ";
}
const dialogues = [
"The underworld holds treasures beyond imagination, but also deeper dangers.",
"They say a great beast guards a mythical creature on the 20th floor...",
"A shelter is the only true safety when the moon is high.",
"Only a key dropped from the mightiest foe can unlock the ultimate prize."
];
return dialogues[Math.floor(Math.random() * dialogues.length)];
},
options: (npc) => {
let opts = [];
if (!gameState.player.boughtGemUpgrade) {
opts.push({
text: "Trade 10  for +2  Strength",
action: () => {
if (gameState.player.gems >= 10) {
gameState.player.gems -= 10;
gameState.player.strength += 2;
gameState.player.boughtGemUpgrade = true;
showMessage(`You feel a surge of power! Strength permanently increased to ${gameState.player.strength}!`);
updateHUD();
} else {
showMessage(`You don't have 10 ${TILE.GEM}! Return when you do.`);
}
}
});
}
opts.push({
text: gameState.player.boughtGemUpgrade ? "Interesting..." : "I'll think about it.",
action: "close"
});
return opts;
}
}
};
const gameContainer = document.getElementById('game-container');
const gameWorld = document.getElementById('game-world');
const nightOverlay = document.getElementById('night-overlay');
const rainContainer = document.getElementById('rain-container');
const lightningFlash = document.getElementById('lightning-flash');
const hpDisplay = document.getElementById('hp-display');
const strengthDisplay = document.getElementById('strength-display');
const weaponBar = document.getElementById('weapon-bar');
const xpDisplay = document.getElementById('xp-display');
const levelDisplay = document.getElementById('level-display');
const keyDisplay = document.getElementById('key-display');
const woodDisplay = document.getElementById('wood-display');
const stoneDisplay = document.getElementById('stone-display');
const gemDisplay = document.getElementById('gem-display');
const herbDisplay = document.getElementById('herb-display');
const arrowsDisplay = document.getElementById('arrows-display');
const timeDisplay = document.getElementById('time-display');
const messageOverlay = document.getElementById('message-overlay');
const messageBox = document.getElementById('message-box');
const messageText = document.getElementById('message-text');
const messageOptions = document.getElementById('message-options');
const messageButton = document.getElementById('message-button');
const saveGameButton = document.getElementById('save-game-button');
const howToPlayButton = document.getElementById('how-to-play-button');
let gameState = {};
let mapGrid, playerElement;
let gameLoopInterval = null;
let mainGameLoopId = null;
let playerFloatingTextContainer;
let cellSize = (8 * Math.min(window.innerWidth, window.innerHeight)) / 100;
const keysPressed = {};
let lastFrameTime = 0;
let visibleCellElements = {};
let visibleMonsterElements = {};
let visibleNpcElements = {};
let messageQueue = [];
let isDisplayingMessage = false;
function showFloatingText(htmlContent) {
if (!playerFloatingTextContainer) return;
const textElement = document.createElement('div');
textElement.className = 'floating-text';
textElement.innerHTML = htmlContent;
playerFloatingTextContainer.appendChild(textElement);
setTimeout(() => {
textElement.remove();
}, 3000);
}
function showMessage(htmlContent, onConfirm, options = []) {
if (!onConfirm && options.length === 0) {
showFloatingText(htmlContent);
} else {
messageQueue.push({
htmlContent,
onConfirm,
options
});
processMessageQueue();
}
}
function processMessageQueue() {
if (isDisplayingMessage || messageQueue.length === 0) {
return;
}
isDisplayingMessage = true;
const {
htmlContent,
onConfirm,
options
} = messageQueue.shift();
messageText.innerHTML = htmlContent;
messageOptions.innerHTML = '';
if (options && options.length > 0) {
messageBox.classList.add('has-options');
options.forEach(opt => {
const btn = document.createElement('button');
btn.className = 'message-option-button';
btn.textContent = opt.text;
btn.onclick = () => {
if (opt.action && typeof opt.action === 'function') {
opt.action();
}
closeModal();
};
messageOptions.appendChild(btn);
});
} else {
messageBox.classList.remove('has-options');
messageButton.onclick = () => {
if (onConfirm) onConfirm();
closeModal();
};
}
messageOverlay.classList.remove('hidden');
}
function closeModal() {
messageOverlay.classList.add('hidden');
isDisplayingMessage = false;
messageButton.onclick = null;
messageOptions.innerHTML = '';
processMessageQueue();
}
function showHowToPlay() {
const costs = gameState.levelConfig;
const instructions = `
<h2 class="how-to-play-title"> How to Play (Level ${gameState.level}) </h2>
<div class="how-to-play-columns">
<div class="how-to-play-column">
<h3>Your Goal </h3>
<p>Find the key , unlock the door , and advance. Your ultimate quest is to reach <strong>Level 20 and rescue the captive Unicorn !</strong></p>
<h3>Your Attributes</h3>
<ul>
<li><strong> Health:</strong> Your life force. Restore it by eating food (, ), touching the magic swan , or crafting potions ().</li>
<li><strong> Strength:</strong> Your attack power. Increased by gaining XP or trading with the Wise Old Man .</li>
<li><strong> XP:</strong> Earned by defeating monsters.</li>
<li><strong> Wood/ Stone/ Gems/ Herbs:</strong> Crafting and trading resources. Cost health to gather.</li>
<li>Every 5th level (5, 10, 15) is a dark underworld where you can find gems  and stone .</li>
</ul>
</div>
<div class="how-to-play-column">
<h3>Actions & Controls</h3>
<p>Remember, crafting and building cost both resources and Health !</p>
<ul>
<li><strong>WASD / Arrow Keys:</strong> Movement.</li>
<li><strong>'E' Key:</strong> Interact with characters (, ) when you are next to them.</li>
<li><strong>Number Keys (1,2,3...):</strong> Switch active weapon.</li>
<li><strong>Click on ///:</strong> Gather resource (costs health).</li>
<li><strong>'B' Key:</strong> Build shelter (costs ${costs.shelterWoodCost} , ${costs.shelterHPCost} ).</li>
<li><strong>'C' Key:</strong> Craft Crossbow (costs ${costs.crossbowWoodCost} ).</li>
<li><strong>'P' Key:</strong> Craft arrows (costs ${ARROW_CRAFTING_COST} ).</li>
<li><strong>'V' Key:</strong> Craft Stone Sword (costs ${STONE_SWORD_COST} ).</li>
<li><strong>'H' Key:</strong> Craft Stone Sledgehammer (costs ${STONE_SLEDGE_COST} ).</li>
<li><strong>'M' Key:</strong> Craft Health Potion (costs 5 ).</li>
<li><strong>Right-Click:</strong> Shoot (if crossbow is equipped).</li>
</ul>
</div>
</div>
<ul style="text-align: left; list-style-position: inside; padding-left: 0;">
<li>Fear the night ()! Monsters are stronger. A shelter () is your best friend.</li>
<li>Look for friendly faces! Traders  and wise men  can help you on your quest.</li>
<li>At night, ghosts  hunt! If they catch you outside, they'll steal your items.</li>
</ul>`;
showMessage(instructions, () => { });
}
function setupNewGame() {
if (gameLoopInterval) clearInterval(gameLoopInterval);
if (mainGameLoopId) cancelAnimationFrame(mainGameLoopId);
audioManager.stopAmbiance('wind_ambiance');
audioManager.stopBirdSounds();
audioManager.stopNightSounds();
audioManager.stopAmbiance('ambiance_rain');
const oldPlayer = gameState.player;
const currentLevel = gameState.level ? gameState.level + 1 : 1;
const isUnderworld = currentLevel % 5 === 0 && currentLevel < 20;
gameContainer.style.backgroundColor = isUnderworld ? '#2d2d3a' : '#245E28';
if (isUnderworld) {
initRainEffect(100);
} else {
stopRainEffect();
audioManager.startAmbiance('wind_ambiance');
audioManager.startBirdSounds();
}
nightOverlay.classList.remove('is-night');
gameState = {
level: currentLevel,
isUnderworld: isUnderworld,
player: {
hp: 100,
maxHp: 100,
hasKey: false,
hasUnicornKey: false,
wood: 0,
stone: 0,
gems: 0,
herbs: 0,
arrows: 0,
inventory: ['unarmed'],
equippedWeapon: 'unarmed',
pos: {
x: Math.floor(WORLD_SIZE.cols / 2),
y: Math.floor(WORLD_SIZE.rows / 2)
},
pixelPos: {
x: 0,
y: 0
},
},
world: [],
monsters: [],
npcs: [],
resources: [],
time: 0,
timeOfDay: 'day',
isGameOver: false,
isFighting: false,
activeFighter: null,
monsterAttackInterval: null,
playerStatusBar: null,
activeProjectiles: [],
};
if (oldPlayer) {
gameState.player.strength = oldPlayer.strength;
gameState.player.xp = oldPlayer.xp;
gameState.player.xpForNextStrength = oldPlayer.xpForNextStrength;
gameState.player.inventory = oldPlayer.inventory || ['unarmed'];
gameState.player.equippedWeapon = oldPlayer.equippedWeapon || 'unarmed';
gameState.player.wood = oldPlayer.wood;
gameState.player.stone = oldPlayer.stone;
gameState.player.gems = oldPlayer.gems;
gameState.player.herbs = oldPlayer.herbs;
gameState.player.arrows = oldPlayer.arrows;
} else {
gameState.player.strength = 5;
gameState.player.xp = 0;
gameState.player.xpForNextStrength = 20;
}
gameState.levelConfig = {
shelterWoodCost: BASE_SHELTER_WOOD_COST + SHELTER_COST_WOOD_PER_LEVEL * (gameState.level - 1),
shelterHPCost: BASE_SHELTER_HP_COST + SHELTER_COST_HP_PER_LEVEL * (gameState.level - 1),
crossbowWoodCost: BASE_CROSSBOW_WOOD_COST + CROSSBOW_COST_WOOD_PER_LEVEL * (gameState.level - 1),
crossbowHPCost: BASE_CROSSBOW_HP_COST + CROSSBOW_COST_HP_PER_LEVEL * (gameState.level - 1),
};
if (currentLevel === 20) {
generateUnicornLevel();
} else if (isUnderworld) {
generateUnderworld();
} else {
generateRealisticWorld();
}
const startPos = gameState.player.pos;
gameState.player.pixelPos = {
x: startPos.x * cellSize + cellSize / 2,
y: startPos.y * cellSize + cellSize / 2,
};
createWorldElements();
updateVisibleCells(true);
render();
updateHUD();
gameLoopInterval = setInterval(gameTick, 1000);
lastFrameTime = performance.now();
mainGameLoopId = requestAnimationFrame(mainGameLoop);
}
function exportSaveFile() {
if (gameState.isFighting) {
showMessage("Cannot export during combat!");
return;
}
try {
const stateToSave = JSON.parse(JSON.stringify(gameState));
stateToSave.monsters = stateToSave.monsters.filter(m => !m.isDying);
delete stateToSave.playerStatusBar;
delete stateToSave.activeProjectiles;
delete stateToSave.levelConfig;
delete stateToSave.monsterAttackInterval;
const json = JSON.stringify(stateToSave);
const blob = new Blob([json], { type: "application/json" });
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = `Adventure_Lvl${gameState.level}_HP${gameState.player.hp}.json`;
document.body.appendChild(a);
a.click();
document.body.removeChild(a);
URL.revokeObjectURL(url);
showMessage("Game exported successfully! ");
} catch (e) {
console.error(e);
showMessage("Error exporting game.");
}
}
function importSaveFile(e) {
const file = e.target.files[0];
if (!file) return;
const reader = new FileReader();
reader.onload = function(event) {
try {
const json = event.target.result;
const check = JSON.parse(json);
if (!check.player || !check.world) {
alert("Invalid save file!");
return;
}
if(confirm("Importing will overwrite your current game. Continue?")) {
localStorage.setItem('adventureGameSaveData', json);
if (loadGame()) {
showMessage("Game imported successfully! ");
} else {
showMessage("Failed to load the imported save.");
}
}
} catch (err) {
console.error(err);
alert("Error reading file.");
}
e.target.value = '';
};
reader.readAsText(file);
}
function saveGame() {
if (gameState.isFighting) {
showMessage("Cannot save during combat!");
return;
}
try {
const stateToSave = JSON.parse(JSON.stringify(gameState));
stateToSave.monsters = stateToSave.monsters.filter(m => !m.isDying);
delete stateToSave.playerStatusBar;
delete stateToSave.activeProjectiles;
delete stateToSave.levelConfig;
delete stateToSave.monsterAttackInterval;
localStorage.setItem('adventureGameSaveData', JSON.stringify(stateToSave));
showMessage("Game Saved! ");
} catch (error) {
console.error('Failed to save game:', error);
showMessage("Error: Could not save the game.");
}
}
function loadGame() {
const savedData = localStorage.getItem('adventureGameSaveData');
if (!savedData) return false;
if (gameLoopInterval) clearInterval(gameLoopInterval);
if (mainGameLoopId) cancelAnimationFrame(mainGameLoopId);
audioManager.stopAmbiance('wind_ambiance');
audioManager.stopBirdSounds();
audioManager.stopNightSounds();
audioManager.stopAmbiance('ambiance_rain');
try {
gameState = JSON.parse(savedData);
gameState.player.inventory = gameState.player.inventory || ['unarmed'];
gameState.player.equippedWeapon = gameState.player.equippedWeapon || 'unarmed';
gameState.player.stone = gameState.player.stone || 0;
gameState.player.gems = gameState.player.gems || 0;
gameState.player.herbs = gameState.player.herbs || 0;
gameState.player.arrows = gameState.player.arrows || 0;
gameState.player.hasUnicornKey = gameState.player.hasUnicornKey || false;
gameState.npcs = gameState.npcs || [];
if (gameState.player.xp === undefined) gameState.player.xp = 0;
if (gameState.player.xpForNextStrength === undefined) {
let xpNeeded = 20;
if (gameState.player.strength > 5) {
for (let i = 5; i < gameState.player.strength; i++) {
xpNeeded = Math.floor(xpNeeded * 1.5);
}
}
gameState.player.xpForNextStrength = xpNeeded;
}
gameState.player.pixelPos = {
x: gameState.player.pos.x * cellSize + cellSize / 2,
y: gameState.player.pos.y * cellSize + cellSize / 2
};
const entitiesToUpdate = [...(gameState.monsters || []), ...(gameState.npcs || [])];
entitiesToUpdate.forEach((m) => {
m.pixelPos = {
x: m.x * cellSize + cellSize / 2,
y: m.y * cellSize + cellSize / 2
};
m.targetPixelPos = {
...m.pixelPos
};
});
gameState.isUnderworld = gameState.level % 5 === 0 && gameState.level < 20;
gameContainer.style.backgroundColor = gameState.level === 20 ? '#1a001a' : (gameState.isUnderworld ? '#2d2d3a' : '#245E28');
if (gameState.isUnderworld) {
initRainEffect(100);
} else {
stopRainEffect();
}
gameState.levelConfig = {
shelterWoodCost: BASE_SHELTER_WOOD_COST + SHELTER_COST_WOOD_PER_LEVEL * (gameState.level - 1),
shelterHPCost: BASE_SHELTER_HP_COST + SHELTER_COST_HP_PER_LEVEL * (gameState.level - 1),
crossbowWoodCost: BASE_CROSSBOW_WOOD_COST + CROSSBOW_COST_WOOD_PER_LEVEL * (gameState.level - 1),
crossbowHPCost: BASE_CROSSBOW_HP_COST + CROSSBOW_COST_HP_PER_LEVEL * (gameState.level - 1),
};
gameState.time = gameState.time || 0;
gameState.timeOfDay = gameState.timeOfDay || 'day';
gameState.isFighting = false;
gameState.activeFighter = null;
gameState.monsterAttackInterval = null;
gameState.isGameOver = false;
gameState.playerStatusBar = null;
gameState.activeProjectiles = [];
createWorldElements();
updateVisibleCells(true);
render();
updateHUD();
if (gameState.timeOfDay === 'night') {
nightOverlay.classList.add('is-night');
if (!gameState.isUnderworld && gameState.level !== 20) {
audioManager.startNightSounds();
}
} else {
nightOverlay.classList.remove('is-night');
if (!gameState.isUnderworld && gameState.level !== 20) {
audioManager.startAmbiance('wind_ambiance');
audioManager.startBirdSounds();
}
}
gameLoopInterval = setInterval(gameTick, 1000);
lastFrameTime = performance.now();
mainGameLoopId = requestAnimationFrame(mainGameLoop);
showMessage("Game Loaded!");
return true;
} catch (error) {
console.error('Failed to load game:', error);
localStorage.removeItem('adventureGameSaveData');
return false;
}
}
function levelUp() {
showMessage(`Congratulations! You reached level ${gameState.level + 1}! The challenges grow tougher...`, setupNewGame);
}
function gameOver() {
gameState.isGameOver = true;
audioManager.stopAmbiance('wind_ambiance');
audioManager.stopBirdSounds();
audioManager.stopNightSounds();
audioManager.stopAmbiance('ambiance_rain');
clearInterval(gameLoopInterval);
cancelAnimationFrame(mainGameLoopId);
showMessage("GAME OVER <br>Loading last save...", () => {
if (!loadGame()) {
window.location.reload();
}
});
}
function gameWon() {
gameState.isGameOver = true;
audioManager.stopAmbiance('wind_ambiance');
audioManager.stopBirdSounds();
audioManager.stopNightSounds();
audioManager.stopAmbiance('ambiance_rain');
clearInterval(gameLoopInterval);
cancelAnimationFrame(mainGameLoopId);
localStorage.removeItem('adventureGameSaveData');
const winContent = `<h2> VICTORY! </h2><p>You have defeated the great dragon and used its key to free the mystical Unicorn!<br><br>The land is safe once more, thanks to your courage. You are a true hero!</p>`;
showMessage(winContent, null, [{
text: "Play Again",
action: () => window.location.reload()
}]);
}
function findValidSpotNear(targetPos, searchRadius = 5) {
const pathTile = gameState.isUnderworld ? TILE.UW_PATH : TILE.PATH;
for (let r = 1; r <= searchRadius; r++) {
for (let i = -r; i <= r; i++) {
for (let j = -r; j <= r; j++) {
if (Math.abs(i) !== r && Math.abs(j) !== r) continue;
const checkX = targetPos.x + i;
const checkY = targetPos.y + j;
if (checkX >= 0 && checkX < WORLD_SIZE.cols && checkY >= 0 && checkY < WORLD_SIZE.rows) {
const tile = gameState.world[checkY][checkX];
if (tile === TILE.EMPTY || tile === pathTile) {
return {
x: checkX,
y: checkY
};
}
}
}
}
}
return null;
}
function generateLake() {
const lakeSize = 15 + Math.floor(Math.random() * 10);
const center = {
x: Math.floor(WORLD_SIZE.cols * (0.2 + Math.random() * 0.6)),
y: Math.floor(WORLD_SIZE.rows * (0.2 + Math.random() * 0.6)),
};
let lakeTiles = [{
...center
}];
gameState.world[center.y][center.x] = TILE.WATER;
for (let i = 0; i < lakeSize * lakeSize * 0.8; i++) {
const randomTile = lakeTiles[Math.floor(Math.random() * lakeTiles.length)];
const directions = [
[0, -1],
[0, 1],
[-1, 0],
[1, 0]
];
const move = directions[Math.floor(Math.random() * 4)];
const newTile = {
x: randomTile.x + move[0],
y: randomTile.y + move[1]
};
if (newTile.x >= 1 && newTile.x < WORLD_SIZE.cols - 1 && newTile.y >= 1 && newTile.y < WORLD_SIZE.rows - 1) {
if (gameState.world[newTile.y][newTile.x] !== TILE.WATER) {
gameState.world[newTile.y][newTile.x] = TILE.WATER;
lakeTiles.push(newTile);
}
}
}
}
function generateRealisticWorld() {
gameState.world = Array.from({
length: WORLD_SIZE.rows
}, () => Array(WORLD_SIZE.cols).fill(TILE.EMPTY));
gameState.resources = [];
gameState.monsters = [];
gameState.npcs = [];
generateLake();
for (let y = 0; y < WORLD_SIZE.rows; y++) {
for (let x = 0; x < WORLD_SIZE.cols; x++) {
if (gameState.world[y][x] === TILE.EMPTY && Math.random() < 0.45) {
gameState.world[y][x] = TILE.WALL_1;
}
}
}
for (let i = 0; i < 4; i++) {
let nextWorld = JSON.parse(JSON.stringify(gameState.world));
for (let y = 1; y < WORLD_SIZE.rows - 1; y++) {
for (let x = 1; x < WORLD_SIZE.cols - 1; x++) {
if (gameState.world[y][x] === TILE.WATER) continue;
let neighbors = 0;
for (let dy = -1; dy <= 1; dy++) {
for (let dx = -1; dx <= 1; dx++) {
if (dx === 0 && dy === 0) continue;
if (gameState.world[y + dy][x + dx] === TILE.WALL_1) neighbors++;
}
}
if (neighbors > 4) nextWorld[y][x] = TILE.WALL_1;
else if (neighbors < 4) nextWorld[y][x] = TILE.EMPTY;
}
}
gameState.world = nextWorld;
}
const startPos = getRandomEmptyPosition(TILE.EMPTY, [], 1);
if (!startPos) {
showMessage("Could not generate the map...", () => window.location.reload(), []);
return;
}
const doorPos = getRandomEmptyPosition(TILE.EMPTY, [startPos], 50);
if (!doorPos) {
showMessage("Could not generate the map...", () => window.location.reload(), []);
return;
}
const keyPos = getRandomEmptyPosition(TILE.EMPTY, [startPos, doorPos], 40);
if (!keyPos) {
showMessage("Could not generate the map...", () => window.location.reload(), []);
return;
}
gameState.player.pos = startPos;
gameState.keyPos = keyPos;
gameState.doorPos = doorPos;
carvePath(startPos, keyPos, 2);
carvePath(startPos, doorPos, 2);
carvePath(keyPos, doorPos, 1);
const bossHomePos = findValidSpotNear(doorPos, 8);
if (bossHomePos) {
placeMonsters(TILE.BOSS, 1, bossHomePos);
} else {
placeMonsters(TILE.BOSS, 1);
}
for (let y = 0; y < WORLD_SIZE.rows; y++) {
for (let x = 0; x < WORLD_SIZE.cols; x++) {
if ([TILE.WALL_1, TILE.WALL_2].includes(gameState.world[y][x])) {
gameState.resources.push({
x,
y,
hits: 0,
type: 'tree'
});
}
}
}
placeObjectsInBiome(TILE.WALL_2, 300, TILE.WALL_1);
placeObjectsInBiome(TILE.FOOD_1, 60, TILE.EMPTY);
placeObjectsInBiome(TILE.FOOD_2, 40, TILE.EMPTY);
placeObjectsInBiome(TILE.HERB, 30, TILE.EMPTY);
placeFlowerBeds(30, 5);
placeMonsters(TILE.MONSTER_1, 40);
placeMonsters(TILE.MONSTER_2, 25);
placeMonsters(TILE.MONSTER_3, 10);
const swanPos = getRandomEmptyPosition(TILE.WATER, [], 0);
if (swanPos) {
placeMonsters(TILE.SWAN, 1, swanPos);
}
placeNPCs(TILE.TRADER, 1 + Math.floor(gameState.level / 4));
placeNPCs(TILE.WISE_OLD_MAN, 1 + Math.floor(gameState.level / 6));
}
function generateUnderworld() {
gameState.world = Array.from({
length: WORLD_SIZE.rows
}, () => Array(WORLD_SIZE.cols).fill(TILE.EMPTY));
gameState.resources = [];
gameState.monsters = [];
gameState.npcs = [];
placeResourceClusters(TILE.STONE, 80, 8);
placeResourceClusters(TILE.WALL_1, 95, 5);
placeResourceClusters(TILE.GEM, 40, 4);
const startPos = getRandomEmptyPosition(TILE.EMPTY, [], 1);
if (!startPos) {
showMessage("Could not generate the map...", () => window.location.reload(), []);
return;
}
const doorPos = getRandomEmptyPosition(TILE.EMPTY, [startPos], 50);
if (!doorPos) {
showMessage("Could not generate the map...", () => window.location.reload(), []);
return;
}
const keyPos = getRandomEmptyPosition(TILE.EMPTY, [startPos, doorPos], 40);
if (!keyPos) {
showMessage("Could not generate the map...", () => window.location.reload(), []);
return;
}
gameState.player.pos = startPos;
gameState.keyPos = keyPos;
gameState.doorPos = doorPos;
carvePath(startPos, keyPos, 2);
carvePath(startPos, doorPos, 2);
carvePath(keyPos, doorPos, 1);
const bossHomePos = findValidSpotNear(doorPos, 8);
if (bossHomePos) {
placeMonsters(TILE.U_BOSS, 1, bossHomePos);
} else {
placeMonsters(TILE.U_BOSS, 1);
}
placeObjectsInBiome(TILE.FOOD_1, 60, TILE.EMPTY);
placeObjectsInBiome(TILE.FOOD_2, 45, TILE.EMPTY);
placeMonsters(TILE.U_MONSTER_1, 30);
placeMonsters(TILE.U_MONSTER_2, 20);
placeMonsters(TILE.U_MONSTER_3, 15);
placeNPCs(TILE.TRADER, 1 + Math.floor(gameState.level / 4));
}
function generateUnicornLevel() {
gameState.world = Array.from({
length: WORLD_SIZE.rows
}, () => Array(WORLD_SIZE.cols).fill(TILE.EMPTY));
gameState.resources = [];
gameState.monsters = [];
gameState.npcs = [];
gameContainer.style.backgroundColor = '#1a001a';
const arena_x = Math.floor(WORLD_SIZE.cols / 2);
const arena_y = Math.floor(WORLD_SIZE.rows / 2);
const arena_radius = 25;
for (let y = 0; y < WORLD_SIZE.rows; y++) {
for (let x = 0; x < WORLD_SIZE.cols; x++) {
const dist = Math.hypot(x - arena_x, y - arena_y);
if (dist > arena_radius) {
gameState.world[y][x] = TILE.STONE;
} else if (dist > arena_radius - 2) {
gameState.world[y][x] = TILE.DECOR_1;
}
}
}
const startPos = {
x: arena_x,
y: arena_y + 20
};
gameState.player.pos = startPos;
const unicornPos = {
x: arena_x,
y: arena_y - 20
};
gameState.unicornPos = unicornPos;
for (let i = -1; i <= 1; i++) {
for (let j = -1; j <= 1; j++) {
if (i === 0 && j === 0) continue;
gameState.world[unicornPos.y + j][unicornPos.x + i] = TILE.CAGE;
}
}
placeSpecial(TILE.UNICORN, 1, unicornPos);
const bossPos = {
x: arena_x,
y: arena_y
};
placeMonsters(TILE.U_BOSS, 1, bossPos);
placeMonsters(TILE.U_MONSTER_3, 10);
placeObjectsInBiome(TILE.FOOD_2, 15, TILE.EMPTY);
gameState.doorPos = {
x: -1,
y: -1
};
gameState.keyPos = {
x: -1,
y: -1
};
}
function placeResourceClusters(tile, clusterCount, maxClusterSize) {
for (let i = 0; i < clusterCount; i++) {
const center = getRandomEmptyPosition(TILE.EMPTY, [gameState.player.pos], 5);
if (!center) continue;
const clusterSize = 2 + Math.floor(Math.random() * (maxClusterSize - 1));
for (let j = 0; j < clusterSize; j++) {
const angle = Math.random() * 2 * Math.PI;
const radius = Math.random() * (maxClusterSize / 3);
const resX = Math.round(center.x + Math.cos(angle) * radius);
const resY = Math.round(center.y + Math.sin(angle) * radius);
if (resX >= 0 && resX < WORLD_SIZE.cols && resY >= 0 && resY < WORLD_SIZE.rows) {
if (gameState.world[resY][resX] === TILE.EMPTY) {
gameState.world[resY][resX] = tile;
let resourceType;
if (tile === TILE.STONE) resourceType = 'stone';
else if (tile === TILE.GEM) resourceType = 'gem';
else resourceType = 'tree';
gameState.resources.push({
x: resX,
y: resY,
hits: 0,
type: resourceType
});
}
}
}
}
}
function getRandomEmptyPosition(tileType, pointsToAvoid = [], minDistance = 20) {
let x, y, tries = 0;
const maxTries = 10000;
while (tries < maxTries) {
x = Math.floor(Math.random() * WORLD_SIZE.cols);
y = Math.floor(Math.random() * WORLD_SIZE.rows);
tries++;
if (x < 0 || x >= WORLD_SIZE.cols || y < 0 || y >= WORLD_SIZE.rows) continue;
if (gameState.world[y][x] !== tileType) continue;
let tooClose = false;
for (const point of pointsToAvoid) {
if (point && typeof point.x === 'number' && typeof point.y === 'number') {
if (Math.hypot(x - point.x, y - point.y) < minDistance) {
tooClose = true;
break;
}
}
}
if (tooClose) continue;
return {
x,
y
};
}
console.warn(`Could not find a valid random position for ${tileType} after ${maxTries} tries.`);
return null;
}
function carvePath(start, end, width) {
let current = {
...start
};
const pathTile = gameState.isUnderworld ? TILE.UW_PATH : TILE.PATH;
while (Math.abs(current.x - end.x) > width || Math.abs(current.y - end.y) > width) {
for (let i = -width; i <= width; i++) {
for (let j = -width; j <= width; j++) {
if (current.y + i >= 0 && current.y + i < WORLD_SIZE.rows && current.x + j >= 0 && current.x + j < WORLD_SIZE.cols) {
if (gameState.world[current.y + i][current.x + j] === TILE.EMPTY) {
gameState.world[current.y + i][current.x + j] = pathTile;
}
}
}
}
if (Math.random() > 0.5) {
current.x += Math.sign(end.x - current.x);
} else {
current.y += Math.sign(end.y - current.y);
}
}
}
function placeFlowerBeds(bedCount, maxClusterSize) {
for (let i = 0; i < bedCount; i++) {
const center = getRandomEmptyPosition(TILE.EMPTY, [gameState.player.pos]);
if (!center) continue;
const clusterSize = 2 + Math.floor(Math.random() * (maxClusterSize - 1));
for (let j = 0; j < clusterSize; j++) {
const offsetX = Math.floor(Math.random() * 3) - 1;
const offsetY = Math.floor(Math.random() * 3) - 1;
const flowerX = center.x + offsetX;
const flowerY = center.y + offsetY;
if (flowerX >= 0 && flowerX < WORLD_SIZE.cols && flowerY >= 0 && flowerY < WORLD_SIZE.rows) {
if (gameState.world[flowerY][flowerX] === TILE.EMPTY) {
const flowerType = Math.random() < 0.5 ? TILE.DECOR_2 : TILE.DECOR_3;
gameState.world[flowerY][flowerX] = flowerType;
}
}
}
}
}
function placeObjectsInBiome(tile, count, targetBiome, shouldUpdateCells = false) {
const isResource = [TILE.HERB, TILE.GEM].includes(tile);
for (let i = 0; i < count; i++) {
const pos = getRandomEmptyPosition(targetBiome, [gameState.player.pos]);
if (pos) {
gameState.world[pos.y][pos.x] = tile;
if (isResource) {
gameState.resources.push({
x: pos.x,
y: pos.y,
hits: 0,
type: tile === TILE.HERB ? 'herb' : 'gem'
});
}
if (shouldUpdateCells) {
updateCell(pos.x, pos.y, tile);
}
}
}
}
function placeMonsters(tile, count, fixedPos = null) {
for (let i = 0; i < count; i++) {
let pos = fixedPos;
if (!pos) {
const tileType = tile === TILE.SWAN ? TILE.WATER : TILE.EMPTY;
pos = getRandomEmptyPosition(tileType, [gameState.player.pos], 10);
}
if (!pos) continue;
const baseStats = OBJECT_DATA[tile];
const isSpecial = [TILE.SWAN, TILE.GHOST].includes(tile);
const levelMultiplier = isSpecial ? 1 : 1 + 0.35 * (gameState.level - 1);
const finalHp = Math.floor(baseStats.hp * levelMultiplier);
const finalStrength = Math.floor(baseStats.strength * levelMultiplier);
const xPx = pos.x * cellSize + cellSize / 2;
const yPx = pos.y * cellSize + cellSize / 2;
const isBoss = OBJECT_DATA[tile].type === 'boss';
const monsterData = {
id: `m-${Date.now()}-${Math.random()}`,
tile: tile,
x: pos.x,
y: pos.y,
baseHp: finalHp,
currentHp: finalHp,
baseStrength: finalStrength,
currentStrength: finalStrength,
isAggroed: false,
isDying: false,
pixelPos: {
x: xPx,
y: yPx
},
targetPixelPos: {
x: xPx,
y: yPx
},
speed: OBJECT_DATA[tile].speed,
isBoss: isBoss,
isHunting: false,
};
if (isBoss) {
monsterData.homePos = {
x: pos.x,
y: pos.y
};
}
gameState.monsters.push(monsterData);
}
}
function placeNPCs(tile, count) {
for (let i = 0; i < count; i++) {
const pos = getRandomEmptyPosition(TILE.EMPTY, [gameState.player.pos], 15);
if (!pos) continue;
const xPx = pos.x * cellSize + cellSize / 2;
const yPx = pos.y * cellSize + cellSize / 2;
const npc = {
id: `npc-${Date.now()}-${Math.random()}`,
tile: tile,
x: pos.x,
y: pos.y,
pixelPos: {
x: xPx,
y: yPx
},
targetPixelPos: {
x: xPx,
y: yPx
},
speed: OBJECT_DATA[tile].speed,
};
gameState.npcs.push(npc);
}
}
function placeSpecial(tile, count, fixedPos = null) {
for (let i = 0; i < count; i++) {
let pos = fixedPos || getRandomEmptyPosition(TILE.EMPTY, [gameState.player.pos], 10);
if (!pos) continue;
const xPx = pos.x * cellSize + cellSize / 2;
const yPx = pos.y * cellSize + cellSize / 2;
const specialObject = {
id: `s-${Date.now()}-${Math.random()}`,
tile: tile,
x: pos.x,
y: pos.y,
pixelPos: {
x: xPx,
y: yPx
},
targetPixelPos: {
x: xPx,
y: yPx
},
speed: 0,
};
gameState.npcs.push(specialObject);
}
}
function createWorldElements() {
gameWorld.innerHTML = '';
mapGrid = document.createElement('div');
mapGrid.id = 'map-grid';
gameWorld.appendChild(mapGrid);
playerElement = document.createElement('div');
playerElement.id = 'player';
playerFloatingTextContainer = document.createElement('div');
playerFloatingTextContainer.id = 'player-floating-text-container';
playerElement.appendChild(playerFloatingTextContainer);
const playerSprite = document.createElement('div');
playerSprite.className = 'player-sprite';
playerSprite.textContent = TILE.PLAYER;
playerElement.appendChild(playerSprite);
gameWorld.appendChild(playerElement);
visibleCellElements = {};
Object.values(visibleMonsterElements).forEach((el) => el.remove());
visibleMonsterElements = {};
Object.values(visibleNpcElements).forEach((el) => el.remove());
visibleNpcElements = {};
mapGrid.addEventListener('click', (e) => {
if (gameState.isGameOver || gameState.isFighting || !e.target.dataset.cellId) return;
const parts = e.target.dataset.cellId.split('-');
const x = parseInt(parts[1]);
const y = parseInt(parts[2]);
if (gameState.monsters.some((m) => !m.isDying && m.x === x && m.y === y)) return;
const isAdjacent = Math.abs(x - gameState.player.pos.x) <= 1 && Math.abs(y - gameState.player.pos.y) <= 1;
if (!isAdjacent) return;
const resource = gameState.resources.find((r) => r.x === x && r.y === y);
if (resource) {
gatherResource(resource, e.target);
}
});
}
function updateVisibleCells(forceRedraw = false) {
const pPos = gameState.player.pos;
const renderDistX = Math.ceil(gameContainer.clientWidth / cellSize / 2) + 1;
const renderDistY = Math.ceil(gameContainer.clientHeight / cellSize / 2) + 1;
const newVisible = {};
const pathTile = gameState.isUnderworld ? TILE.UW_PATH : TILE.PATH;
for (let y = pPos.y - renderDistY; y <= pPos.y + renderDistY; y++) {
for (let x = pPos.x - renderDistX; x <= pPos.x + renderDistX; x++) {
const cellId = `cell-${x}-${y}`;
newVisible[cellId] = true;
if (!visibleCellElements[cellId] || forceRedraw) {
if (forceRedraw && visibleCellElements[cellId]) {
visibleCellElements[cellId].remove();
}
const cell = document.createElement('div');
cell.className = 'cell';
cell.dataset.cellId = cellId;
cell.style.left = `${x * cellSize}px`;
cell.style.top = `${y * cellSize}px`;
if (x < 0 || x >= WORLD_SIZE.cols || y < 0 || y >= WORLD_SIZE.rows) {
cell.style.backgroundColor = '#000000';
cell.textContent = '';
} else {
let displayTile = gameState.world[y][x];
if (gameState.level < 20) {
if (x === gameState.keyPos.x && y === gameState.keyPos.y && !gameState.player.hasKey) {
displayTile = TILE.KEY;
} else if (x === gameState.doorPos.x && y === gameState.doorPos.y) {
displayTile = TILE.DOOR;
}
}
const monsterAtPos = gameState.monsters.find((m) => m.x === x && m.y === y && !m.isDying);
const npcAtPos = gameState.npcs.find((n) => n.x === x && n.y === y);
if (monsterAtPos || npcAtPos) {
if (displayTile !== TILE.KEY && displayTile !== TILE.DOOR) {
displayTile = gameState.world[y][x] === pathTile ? pathTile : TILE.EMPTY;
}
}
if (gameState.world[y][x] === TILE.WATER) {
cell.style.backgroundColor = '#42a5f5';
displayTile = TILE.EMPTY;
} else {
cell.style.backgroundColor = 'transparent';
}
cell.textContent = displayTile;
updateCellClass(cell, displayTile);
}
mapGrid.appendChild(cell);
visibleCellElements[cellId] = cell;
}
}
}
for (const cellId in visibleCellElements) {
if (!newVisible[cellId]) {
visibleCellElements[cellId].remove();
delete visibleCellElements[cellId];
}
}
}
function render() {
if (!gameState || gameState.isGameOver) {
if (playerElement) {
playerElement.querySelector('.player-sprite').textContent = TILE.DEAD;
playerElement.classList.remove('is-walking');
}
return;
}
if (!gameState.player || !gameState.player.pixelPos || !mapGrid) {
return;
}
const screenCenterX = gameContainer.clientWidth / 2;
const screenCenterY = gameContainer.clientHeight / 2;
const mapX = screenCenterX - gameState.player.pixelPos.x;
const mapY = screenCenterY - gameState.player.pixelPos.y;
mapGrid.style.transform = `translate(${mapX}px, ${mapY}px)`;
playerElement.style.transform = `translate(${screenCenterX - cellSize / 2}px, ${screenCenterY - cellSize / 2}px)`;
renderVisibleMonsters();
renderVisibleNPCs();
}
function renderVisibleMonsters() {
if (!gameState.player || !mapGrid) return;
const pPos = gameState.player.pos;
const renderDistX = Math.ceil(gameContainer.clientWidth / cellSize / 2) + 4;
const renderDistY = Math.ceil(gameContainer.clientHeight / cellSize / 2) + 4;
const newVisibleMonsters = {};
for (const monster of gameState.monsters) {
const isVisible = Math.abs(monster.x - pPos.x) < renderDistX && Math.abs(monster.y - pPos.y) < renderDistY;
if (isVisible) {
newVisibleMonsters[monster.id] = true;
let monsterEl = visibleMonsterElements[monster.id];
if (!monsterEl) {
monsterEl = document.createElement('div');
monsterEl.className = 'monster-container';
const sprite = document.createElement('div');
sprite.className = 'monster-sprite';
sprite.textContent = monster.tile;
if (OBJECT_DATA[monster.tile].type === 'boss') {
sprite.classList.add('large');
} else {
sprite.classList.add('medium');
}
monsterEl.appendChild(sprite);
mapGrid.appendChild(monsterEl);
visibleMonsterElements[monster.id] = monsterEl;
monsterEl.addEventListener('click', () => {
if (gameState.isGameOver || monster.isDying || monster.tile === TILE.GHOST || monster.tile === TILE.SWAN) return;
if (gameState.isFighting && gameState.activeFighter.id === monster.id) {
const equippedWeapon = WEAPONS[gameState.player.equippedWeapon];
let weaponForThisHit = equippedWeapon;
if (weaponForThisHit.type === 'ranged') {
weaponForThisHit = WEAPONS['unarmed'];
}
if (weaponForThisHit.name === 'Unarmed') {
audioManager.playSound('player_attack_unarmed');
} else if (weaponForThisHit.name === 'Stone Sword') {
audioManager.playSound('player_attack_sword');
} else if (weaponForThisHit.name === 'Stone Sledgehammer') {
audioManager.playSound('player_attack_sledge');
}
const damageBonus = weaponForThisHit.damageBonus;
const baseDamage = gameState.player.strength + Math.floor(Math.random() * 3) - 1;
const playerDamage = Math.floor(baseDamage * damageBonus);
gameState.activeFighter.currentHp -= playerDamage;
updateHealthBar(monsterEl, gameState.activeFighter.currentHp, gameState.activeFighter.baseHp);
if (gameState.activeFighter.currentHp <= 0) {
endFight('win');
}
} else if (!gameState.isFighting) {
const isAdjacent = Math.abs(monster.x - gameState.player.pos.x) <= 1 && Math.abs(monster.y - gameState.player.pos.y) <= 1;
if (isAdjacent) {
startFight(monster);
const equippedWeapon = WEAPONS[gameState.player.equippedWeapon];
let weaponForThisHit = equippedWeapon;
if (weaponForThisHit.type === 'ranged') {
weaponForThisHit = WEAPONS['unarmed'];
}
if (weaponForThisHit.name === 'Unarmed') {
audioManager.playSound('player_attack_unarmed');
} else if (weaponForThisHit.name === 'Stone Sword') {
audioManager.playSound('player_attack_sword');
} else if (weaponForThisHit.name === 'Stone Sledgehammer') {
audioManager.playSound('player_attack_sledge');
}
const damageBonus = weaponForThisHit.damageBonus;
const baseDamage = gameState.player.strength + Math.floor(Math.random() * 3) - 1;
const playerDamage = Math.floor(baseDamage * damageBonus);
if (gameState.activeFighter) {
gameState.activeFighter.currentHp -= playerDamage;
updateHealthBar(monsterEl, gameState.activeFighter.currentHp, gameState.activeFighter.baseHp);
if (gameState.activeFighter.currentHp <= 0) {
endFight('win');
}
}
}
}
});
}
if (monster.pixelPos) {
const elX = monster.pixelPos.x - cellSize / 2;
const elY = monster.pixelPos.y - cellSize / 2;
monsterEl.style.transform = `translate(${elX}px, ${elY}px)`;
}
}
}
for (const monsterId in visibleMonsterElements) {
if (!newVisibleMonsters[monsterId]) {
visibleMonsterElements[monsterId].remove();
delete visibleMonsterElements[monsterId];
}
}
}
function renderVisibleNPCs() {
if (!gameState.player || !mapGrid) return;
const pPos = gameState.player.pos;
const renderDistX = Math.ceil(gameContainer.clientWidth / cellSize / 2) + 4;
const renderDistY = Math.ceil(gameContainer.clientHeight / cellSize / 2) + 4;
const newVisibleNPCs = {};
for (const npc of gameState.npcs) {
const isVisible = Math.abs(npc.x - pPos.x) < renderDistX && Math.abs(npc.y - pPos.y) < renderDistY;
if (isVisible) {
newVisibleNPCs[npc.id] = true;
let npcEl = visibleNpcElements[npc.id];
if (!npcEl) {
npcEl = document.createElement('div');
npcEl.className = 'npc-container';
const sprite = document.createElement('div');
sprite.className = 'npc-sprite';
sprite.textContent = npc.tile;
npcEl.appendChild(sprite);
mapGrid.appendChild(npcEl);
visibleNpcElements[npc.id] = npcEl;
}
if (npc.pixelPos) {
const elX = npc.pixelPos.x - cellSize / 2;
const elY = npc.pixelPos.y - cellSize / 2;
npcEl.style.transform = `translate(${elX}px, ${elY}px)`;
}
}
}
for (const npcId in visibleNpcElements) {
if (!newVisibleNPCs[npcId]) {
visibleNpcElements[npcId].remove();
delete visibleNpcElements[npcId];
}
}
}
function updateHUD() {
if (!gameState || !gameState.player) return;
hpDisplay.textContent = `${gameState.player.hp}/${gameState.player.maxHp}`;
strengthDisplay.textContent = gameState.player.strength;
xpDisplay.textContent = `${gameState.player.xp}/${gameState.player.xpForNextStrength}`;
levelDisplay.textContent = gameState.level;
keyDisplay.textContent = gameState.player.hasKey ? '' : '';
woodDisplay.textContent = gameState.player.wood;
stoneDisplay.textContent = gameState.player.stone;
gemDisplay.textContent = gameState.player.gems;
herbDisplay.textContent = gameState.player.herbs;
arrowsDisplay.textContent = gameState.player.inventory.includes('crossbow') ? gameState.player.arrows : '';
timeDisplay.textContent = gameState.timeOfDay === 'day' ? ' Day' : ' Night';
const hpElement = document.getElementById('hud-hp');
if ((gameState.player.hp / gameState.player.maxHp) < 0.25) {
hpElement.classList.add('low-health-warning');
} else {
hpElement.classList.remove('low-health-warning');
}
updateWeaponBar();
}
function updateWeaponBar() {
weaponBar.innerHTML = '';
const availableWeapons = WEAPON_HOTBAR_ORDER.filter(wId => gameState.player.inventory.includes(wId));
availableWeapons.forEach((weaponId, index) => {
const weaponData = WEAPONS[weaponId];
const slot = document.createElement('div');
slot.className = 'weapon-slot';
if (weaponId === gameState.player.equippedWeapon) {
slot.classList.add('active');
}
const keyEl = document.createElement('span');
keyEl.className = 'weapon-key';
keyEl.textContent = index + 1;
const emojiEl = document.createElement('span');
emojiEl.className = 'weapon-emoji';
emojiEl.textContent = weaponData.emoji;
slot.appendChild(keyEl);
slot.appendChild(emojiEl);
weaponBar.appendChild(slot);
});
}
function updateCell(x, y, newTile) {
const pathTile = gameState.isUnderworld ? TILE.UW_PATH : TILE.PATH;
const isEntityTile = OBJECT_DATA[newTile] && ['monster', 'special', 'boss', 'npc'].includes(OBJECT_DATA[newTile].type);
if (!isEntityTile) {
gameState.world[y][x] = newTile;
}
const cell = visibleCellElements[`cell-${x}-${y}`];
if (cell) {
let displayTile = gameState.world[y][x];
if (gameState.level < 20) {
if (x === gameState.keyPos.x && y === gameState.keyPos.y && !gameState.player.hasKey) {
displayTile = TILE.KEY;
} else if (x === gameState.doorPos.x && y === gameState.doorPos.y) {
displayTile = TILE.DOOR;
}
}
if (gameState.world[y][x] === TILE.WATER) {
cell.style.backgroundColor = '#42a5f5';
displayTile = TILE.EMPTY;
} else {
cell.style.backgroundColor = 'transparent';
}
const monsterAtPos = gameState.monsters.find((m) => m.x === x && m.y === y && !m.isDying);
const npcAtPos = gameState.npcs.find((n) => n.x === x && n.y === y);
if (monsterAtPos || npcAtPos) {
if (displayTile !== TILE.KEY && displayTile !== TILE.DOOR && displayTile !== TILE.CAGE) {
displayTile = gameState.world[y][x] === pathTile ? pathTile : TILE.EMPTY;
}
}
cell.textContent = displayTile;
updateCellClass(cell, displayTile);
}
}
function updateCellClass(cell, tile) {
cell.className = 'cell';
if (tile === TILE.PATH) cell.classList.add('path');
else if (tile === TILE.UW_PATH) cell.classList.add('underworld-path');
else if (tile === TILE.SHELTER) cell.classList.add('shelter');
else if ([TILE.WALL_1, TILE.WALL_2, TILE.STONE, TILE.GEM].includes(tile)) cell.classList.add('large');
else if ([TILE.DECOR_1, TILE.DECOR_2, TILE.DECOR_3, TILE.HERB].includes(tile)) cell.classList.add('small');
}
function initRainEffect(dropCount) {
stopRainEffect();
audioManager.startAmbiance('ambiance_rain');
for (let i = 0; i < dropCount; i++) {
const drop = document.createElement('div');
drop.className = 'raindrop';
drop.style.left = `${Math.random() * 110}vw`;
drop.style.animationDuration = `${0.5 + Math.random() * 0.8}s`;
drop.style.animationDelay = `${Math.random() * 2}s`;
drop.style.opacity = Math.random() * 0.6 + 0.3;
drop.style.transform = `scale(${0.5 + Math.random()})`;
rainContainer.appendChild(drop);
}
}
function stopRainEffect() {
rainContainer.innerHTML = '';
}
function triggerLightning() {
audioManager.playSound('effect_thunder');
lightningFlash.style.opacity = '0.7';
setTimeout(() => {
lightningFlash.style.opacity = '0';
}, 150);
}
function handleInteraction(x, y, tile) {
if (gameState.level === 20) {
if (gameState.world[y][x] === TILE.CAGE) {
if (gameState.player.hasUnicornKey) {
gameWon();
} else {
showMessage("The cage is magically sealed. You need a special key!");
}
}
return;
}
if (x === gameState.doorPos.x && y === gameState.doorPos.y) {
if (gameState.player.hasKey) {
audioManager.playSound('door_open_creak');
levelUp();
} else {
showMessage("The door is locked! You need a key .");
}
} else if (x === gameState.keyPos.x && y === gameState.keyPos.y && !gameState.player.hasKey) {
gameState.player.hasKey = true;
audioManager.playSound('key_pickup');
updateCell(x, y, gameState.world[y][x]);
showMessage("You found the key!  Now find the door !");
updateHUD();
} else {
const item = OBJECT_DATA[tile];
if (item && item.type === 'food') {
if (gameState.player.hp < gameState.player.maxHp) {
gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + item.hpGain);
updateCell(x, y, TILE.EMPTY);
updateHUD();
showPlayerStatusBar();
audioManager.playSound('item_pickup');
} else {
showMessage("You are at full health and don't need food right now.");
}
}
}
}
function handleNPCInteraction() {
const p = gameState.player.pos;
for (const npc of gameState.npcs) {
if (Math.abs(p.x - npc.x) <= 1 && Math.abs(p.y - npc.y) <= 1) {
const data = NPC_DATA[npc.tile];
if (data) {
const dialogue = data.getDialogue(npc);
const options = data.options(npc).map(opt => {
return {
text: opt.text,
action: opt.action === 'close' ? null : opt.action
};
});
showMessage(dialogue, null, options);
return;
}
}
}
}
function gatherResource(resource, cellElement) {
if (gameState.player.hp <= GATHER_HP_COST) {
showMessage("You are too weak to gather resources!");
return;
}
if (resource.type === 'tree') {
audioManager.playSound('tree_chop');
} else if (resource.type === 'stone') {
audioManager.playSound('gather_stone');
} else if (resource.type === 'gem') {
audioManager.playSound('gather_gem');
} else if (resource.type === 'herb') {
audioManager.playSound('gather_herb');
}
resource.hits++;
cellElement.classList.add('shaking');
setTimeout(() => cellElement.classList.remove('shaking'), 150);
if (resource.hits >= GATHERING_HITS) {
let replacementTile = TILE.EMPTY;
if (resource.type === 'tree') {
gameState.player.wood += WOOD_PER_TREE;
showMessage(`+${WOOD_PER_TREE} , -${GATHER_HP_COST} `);
replacementTile = TILE.DECOR_1;
} else if (resource.type === 'stone') {
gameState.player.stone += STONE_PER_ROCK;
showMessage(`+${STONE_PER_ROCK} , -${GATHER_HP_COST} `);
} else if (resource.type === 'gem') {
gameState.player.gems += GEM_PER_ROCK;
showMessage(`+${GEM_PER_ROCK} , -${GATHER_HP_COST} `);
} else if (resource.type === 'herb') {
gameState.player.herbs += HERB_PER_PLANT;
showMessage(`+${HERB_PER_PLANT} , -${GATHER_HP_COST} `);
}
gameState.player.hp -= GATHER_HP_COST;
updateCell(resource.x, resource.y, replacementTile);
gameState.resources = gameState.resources.filter((r) => r !== resource);
updateHUD();
showPlayerStatusBar();
}
}
function buildShelter() {
if (gameState.isFighting) return;
const costs = gameState.levelConfig;
if (gameState.player.wood < costs.shelterWoodCost) {
showMessage(`Need ${costs.shelterWoodCost} wood to build a shelter.`);
return;
}
if (gameState.player.hp <= costs.shelterHPCost) {
showMessage(`Need more than ${costs.shelterHPCost} health to build.`);
return;
}
const p = gameState.player.pos;
const currentTile = gameState.world[p.y][p.x];
const pathTile = gameState.isUnderworld ? TILE.UW_PATH : TILE.PATH;
if (currentTile === TILE.EMPTY || currentTile === pathTile) {
gameState.player.wood -= costs.shelterWoodCost;
gameState.player.hp -= costs.shelterHPCost;
updateCell(p.x, p.y, TILE.SHELTER);
audioManager.playSound('tree_chop');
setTimeout(() => audioManager.playSound('tree_chop'), 150);
setTimeout(() => audioManager.playSound('tree_chop'), 300);
updateHUD();
showMessage("You built a shelter! ");
} else {
showMessage("You can't build here!");
}
}
function buildStoneWeapon(weaponType) {
if (gameState.isFighting) return;
const weaponData = WEAPONS[weaponType];
if (gameState.player.inventory.includes(weaponType)) {
showMessage(`You have already crafted a ${weaponData.name}.`);
return;
}
const cost = weaponType === 'sword' ? STONE_SWORD_COST : STONE_SLEDGE_COST;
if (gameState.player.stone < cost) {
showMessage(`Need ${cost} stone for the ${weaponData.name}.`);
return;
}
gameState.player.stone -= cost;
gameState.player.inventory.push(weaponType);
equipWeapon(weaponType);
showMessage(`You crafted a ${weaponData.name}! ${weaponData.emoji}`);
}
function buildCrossbow() {
const costs = gameState.levelConfig;
if (gameState.player.inventory.includes('crossbow')) {
showMessage(`You have already crafted a Crossbow.`);
return;
}
if (gameState.isFighting) return;
if (gameState.player.wood < costs.crossbowWoodCost) {
showMessage(`Need ${costs.crossbowWoodCost} wood to craft a crossbow.`);
return;
}
if (gameState.player.hp <= costs.crossbowHPCost) {
showMessage(`Need more than ${costs.crossbowHPCost} health to build.`);
return;
}
gameState.player.wood -= costs.crossbowWoodCost;
gameState.player.hp -= costs.crossbowHPCost;
gameState.player.inventory.push('crossbow');
gameState.player.arrows += 50;
equipWeapon('crossbow');
showMessage(`You crafted a Crossbow! ${TILE.CROSSBOW} +50 ${TILE.ARROW}`);
}
function craftArrows() {
if (gameState.isFighting) return;
if (!gameState.player.inventory.includes('crossbow')) {
showMessage("You need a crossbow to craft arrows.");
return;
}
const cost = ARROW_CRAFTING_COST;
if (gameState.player.wood < cost) {
showMessage(`Need ${cost} wood to craft arrows.`);
return;
}
gameState.player.wood -= cost;
gameState.player.arrows += 50;
updateHUD();
showMessage(`You crafted 50 arrows! +50 ${TILE.ARROW}, -${cost} `);
}
function craftHealthPotion() {
if (gameState.isFighting) {
showMessage("Cannot craft during combat!");
return;
}
const HERB_COST = 5;
const HEAL_AMOUNT = 50;
if (gameState.player.herbs < HERB_COST) {
showMessage(`Need ${HERB_COST} ${TILE.HERB} to craft a health potion.`);
return;
}
if (gameState.player.hp >= gameState.player.maxHp) {
showMessage("You are already at full health!");
return;
}
gameState.player.herbs -= HERB_COST;
gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + HEAL_AMOUNT);
showMessage(`You crafted a potion! +${HEAL_AMOUNT} , -${HERB_COST} `);
updateHUD();
showPlayerStatusBar();
}
function equipWeapon(weaponId) {
if (gameState.player.inventory.includes(weaponId)) {
gameState.player.equippedWeapon = weaponId;
const weaponData = WEAPONS[weaponId];
showMessage(`Switched to ${weaponData.name} ${weaponData.emoji}`);
updateHUD();
}
}
function startFight(monster) {
if (gameState.isFighting) return;
gameState.isFighting = true;
gameState.activeFighter = monster;
const monsterEl = visibleMonsterElements[monster.id];
if (monsterEl) {
createHealthBar(monsterEl, monster.currentHp, monster.baseHp, 'monster');
monsterEl.classList.add('fighting-monster');
}
createHealthBar(playerElement, gameState.player.hp, gameState.player.maxHp, 'player');
gameState.monsterAttackInterval = setInterval(() => {
if (!gameState.isFighting || !gameState.activeFighter) return;
const monsterDamage = gameState.activeFighter.currentStrength + Math.floor(Math.random() * 3) - 1;
gameState.player.hp -= Math.max(0, monsterDamage);
if (monsterDamage > 0) {
audioManager.playSound('player_take_damage');
}
updateHUD();
updateHealthBar(playerElement, gameState.player.hp, gameState.player.maxHp);
if (gameState.player.hp <= 0) {
endFight('lose');
}
}, MONSTER_ATTACK_SPEED);
}
function endFight(outcome) {
if (!gameState.isFighting) return;
const monster = gameState.activeFighter;
if (monster) {
const monsterEl = visibleMonsterElements[monster.id];
if (monsterEl) {
const healthBar = monsterEl.querySelector('.health-bar-container');
if (healthBar) healthBar.remove();
monsterEl.classList.remove('fighting-monster');
}
}
const playerHealthBar = playerElement.querySelector('.health-bar-container');
if (playerHealthBar) playerHealthBar.remove();
clearInterval(gameState.monsterAttackInterval);
gameState.monsterAttackInterval = null;
gameState.isFighting = false;
gameState.activeFighter = null;
if (outcome === 'win' && monster) {
killMonster(monster);
} else if (outcome === 'lose') {
gameState.player.hp = 0;
gameOver();
}
updateHUD();
}
function killMonster(monster) {
audioManager.playSound('monster_die_xp');
monster.isDying = true;
const reward = OBJECT_DATA[monster.tile].xpReward || 0;
showMessage(`Defeated ${monster.tile}! +${reward} XP `);
if (monster.isBoss) {
showMessage("The boss dropped some food! ");
gameState.world[monster.y][monster.x] = TILE.FOOD_2;
if (gameState.level === 20) {
gameState.player.hasUnicornKey = true;
showMessage("The Dragon dropped a strange key!  It must be for the Unicorn's cage!");
}
}
gameState.player.xp += reward;
checkIfStrengthIncreases();
updateHUD();
const monsterEl = visibleMonsterElements[monster.id];
if (monsterEl) {
const healthBar = monsterEl.querySelector('.health-bar-container');
if (healthBar) healthBar.remove();
monsterEl.classList.remove('fighting-monster');
const sprite = monsterEl.querySelector('.monster-sprite');
if (sprite) sprite.textContent = TILE.DEAD;
monsterEl.style.transition = 'opacity 2s ease-out';
monsterEl.style.opacity = '0';
setTimeout(() => {
monsterEl.remove();
delete visibleMonsterElements[monster.id];
gameState.monsters = gameState.monsters.filter((m) => m.id !== monster.id);
updateVisibleCells();
}, 2000);
} else {
gameState.monsters = gameState.monsters.filter((m) => m.id !== monster.id);
updateVisibleCells();
}
}
function checkIfStrengthIncreases() {
while (gameState.player.xp >= gameState.player.xpForNextStrength) {
gameState.player.xp -= gameState.player.xpForNextStrength;
gameState.player.strength++;
gameState.player.xpForNextStrength = Math.floor(gameState.player.xpForNextStrength * 1.5);
showMessage(` Strength increased to ${gameState.player.strength}! `, null);
updateHUD();
}
}
function shootCrossbow(targetMapX, targetMapY) {
if (gameState.player.arrows <= 0) {
showMessage("You're out of arrows!");
return;
}
audioManager.playSound('arrow_shoot_swoosh');
const pPos = gameState.player.pixelPos;
const dx = targetMapX - pPos.x;
const dy = targetMapY - pPos.y;
if (Math.hypot(dx, dy) < cellSize / 2) return;
gameState.player.arrows--;
updateHUD();
const len = Math.hypot(dx, dy);
const dirX = dx / len;
const dirY = dy / len;
const arrow = document.createElement('div');
arrow.className = 'arrow';
arrow.textContent = TILE.ARROW;
const angle = (Math.atan2(dirY, dirX) * 180) / Math.PI;
arrow.style.left = `${pPos.x - cellSize / 4}px`;
arrow.style.top = `${pPos.y - cellSize / 4}px`;
arrow.style.transform = `rotate(${angle}deg)`;
mapGrid.appendChild(arrow);
gameState.activeProjectiles.push({
el: arrow,
x: pPos.x,
y: pPos.y,
dx: dirX,
dy: dirY,
speed: 800,
distanceTraveled: 0,
maxDistance: 15 * cellSize,
});
}
function updateProjectiles(deltaTime) {
for (let i = gameState.activeProjectiles.length - 1; i >= 0; i--) {
const p = gameState.activeProjectiles[i];
const moveDist = p.speed * deltaTime;
p.x += p.dx * moveDist;
p.y += p.dy * moveDist;
p.distanceTraveled += moveDist;
p.el.style.left = `${p.x - cellSize / 4}px`;
p.el.style.top = `${p.y - cellSize / 4}px`;
let hit = false;
const gridX = Math.floor(p.x / cellSize);
const gridY = Math.floor(p.y / cellSize);
const monster = gameState.monsters.find((m) => !m.isDying && m.x === gridX && m.y === gridY);
if (monster && monster.tile !== TILE.SWAN) {
hit = true;
audioManager.playSound('arrow_hit_thud');
let damage = CROSSBOW_BASE_DAMAGE + Math.floor(gameState.player.strength / CROSSBOW_STRENGTH_DAMAGE_FACTOR);
if (monster.isBoss) {
damage = Math.max(1, Math.floor(damage / 10));
}
monster.currentHp -= damage;
monster.isAggroed = true;
const monsterEl = visibleMonsterElements[monster.id];
if (monsterEl) {
if (!monsterEl.querySelector('.health-bar-container')) {
createHealthBar(monsterEl, monster.currentHp, monster.baseHp, 'monster');
}
updateHealthBar(monsterEl, monster.currentHp, monster.baseHp);
}
if (monster.currentHp <= 0) {
if (gameState.isFighting && gameState.activeFighter.id === monster.id) {
endFight('win');
} else if (!gameState.isFighting) {
killMonster(monster);
}
}
}
if (isTileBlocking(gridX, gridY) || p.distanceTraveled >= p.maxDistance) {
hit = true;
}
if (hit) {
p.el.remove();
gameState.activeProjectiles.splice(i, 1);
}
}
}
function createHealthBar(parent, current, max, type) {
const existingBar = parent.querySelector('.health-bar-container');
if (existingBar) existingBar.remove();
const container = document.createElement('div');
container.className = 'health-bar-container';
const inner = document.createElement('div');
inner.className = `health-bar-inner ${type}`;
inner.style.width = `${Math.max(0, (current / max) * 100)}%`;
container.appendChild(inner);
parent.appendChild(container);
}
function updateHealthBar(barParent, current, max) {
if (!barParent) return;
const innerBar = barParent.querySelector('.health-bar-inner');
if (innerBar) {
innerBar.style.width = `${Math.max(0, (current / max) * 100)}%`;
}
}
function showPlayerStatusBar() {
if (gameState.playerStatusBar) {
gameState.playerStatusBar.remove();
}
const container = document.createElement('div');
container.className = 'status-bar-container';
const inner = document.createElement('div');
inner.className = 'status-bar-inner';
const hpPercent = (gameState.player.hp / gameState.player.maxHp) * 100;
inner.style.width = `${Math.max(0, hpPercent)}%`;
container.appendChild(inner);
playerElement.appendChild(container);
gameState.playerStatusBar = container;
setTimeout(() => {
if (gameState.playerStatusBar === container) container.classList.add('fading-out');
}, 2000);
setTimeout(() => {
if (gameState.playerStatusBar === container) {
container.remove();
gameState.playerStatusBar = null;
}
}, 2500);
}
function checkAggro() {
if (gameState.isFighting) return;
const pPos = gameState.player.pos;
for (const monster of gameState.monsters) {
if (monster.isDying || monster.tile === TILE.GHOST || monster.tile === TILE.SWAN) continue;
const distance = Math.hypot(pPos.x - monster.x, pPos.y - monster.y);
if (monster.isBoss && distance < BOSS_AGGRO_RANGE) {
startFight(monster);
return;
}
if (!monster.isBoss && distance < 2) {
startFight(monster);
return;
}
}
const swan = gameState.monsters.find(m => m.tile === TILE.SWAN);
if (swan && gameState.player.hp < gameState.player.maxHp) {
const distanceToSwan = Math.hypot(pPos.x - swan.x, pPos.y - swan.y);
if (distanceToSwan < 1.5) {
gameState.player.hp = gameState.player.maxHp;
audioManager.playSound('swan_heal');
showMessage("The magic swan  heals you! You are at full health .");
updateHUD();
showPlayerStatusBar();
}
}
}
function updateEntityPixelPositions(deltaTime) {
const entities = [...gameState.monsters, ...gameState.npcs];
for (const entity of entities) {
if (entity.isDying) continue;
if (entity.tile === TILE.GHOST && entity.isHunting) {
const playerPixelPos = gameState.player.pixelPos;
const dx = playerPixelPos.x - entity.pixelPos.x;
const dy = playerPixelPos.y - entity.pixelPos.y;
const dist = Math.hypot(dx, dy);
if (dist > cellSize) {
const dirX = dx / dist;
const dirY = dy / dist;
const moveAmount = entity.speed * deltaTime;
entity.pixelPos.x += dirX * moveAmount;
entity.pixelPos.y += dirY * moveAmount;
entity.x = Math.floor(entity.pixelPos.x / cellSize);
entity.y = Math.floor(entity.pixelPos.y / cellSize);
}
continue;
}
const dx = entity.targetPixelPos.x - entity.pixelPos.x;
const dy = entity.targetPixelPos.y - entity.pixelPos.y;
const dist = Math.hypot(dx, dy);
if (dist < 1) continue;
const moveAmount = entity.speed * deltaTime;
if (dist < moveAmount) {
entity.pixelPos.x = entity.targetPixelPos.x;
entity.pixelPos.y = entity.targetPixelPos.y;
} else {
entity.pixelPos.x += (dx / dist) * moveAmount;
entity.pixelPos.y += (dy / dist) * moveAmount;
}
}
}
function moveEntities() {
const playerInShelterAtNight = gameState.timeOfDay === 'night' && gameState.world[gameState.player.pos.y][gameState.player.pos.x] === TILE.SHELTER;
const ghostsToRemove = [];
const allEntities = [...gameState.monsters, ...gameState.npcs];
allEntities.forEach((entity) => {
if (entity.isDying) return;
if (entity.tile === TILE.SWAN) {
if (Math.random() > 0.6) {
const validMoves = [];
[
[0, -1],
[0, 1],
[-1, 0],
[1, 0]
].forEach(move => {
const newX = entity.x + move[0];
const newY = entity.y + move[1];
if (gameState.world[newY] && gameState.world[newY][newX] === TILE.WATER) {
validMoves.push(move);
}
});
if (validMoves.length > 0) {
const chosenMove = validMoves[Math.floor(Math.random() * validMoves.length)];
entity.x += chosenMove[0];
entity.y += chosenMove[1];
entity.targetPixelPos = {
x: entity.x * cellSize + cellSize / 2,
y: entity.y * cellSize + cellSize / 2
};
}
}
return;
}
if (entity.tile === TILE.GHOST) {
entity.isHunting = true;
const distanceToPlayer = Math.hypot(gameState.player.pos.x - entity.x, gameState.player.pos.y - entity.y);
if (distanceToPlayer < 1.5 && !playerInShelterAtNight) {
const damage = 15 + Math.floor(Math.random() * 10);
let stolenItems = [];
if (gameState.player.hasKey) {
gameState.player.hasKey = false;
stolenItems.push(TILE.KEY);
}
if (gameState.player.inventory.includes('crossbow')) {
gameState.player.inventory = gameState.player.inventory.filter(w => w !== 'crossbow');
if (gameState.player.arrows > 0) {
stolenItems.push(`${gameState.player.arrows} ${TILE.ARROW}`);
gameState.player.arrows = 0;
}
stolenItems.push(TILE.CROSSBOW);
}
if (gameState.player.wood > 0) {
stolenItems.push(`${gameState.player.wood} `);
gameState.player.wood = 0;
}
if (stolenItems.includes(TILE.KEY) && gameState.level < 20) {
const newKeyPos = getRandomEmptyPosition(TILE.EMPTY, [gameState.player.pos], 10);
if (newKeyPos) {
gameState.keyPos = newKeyPos;
updateCell(newKeyPos.x, newKeyPos.y, TILE.KEY);
}
}
gameState.player.hp = Math.max(0, gameState.player.hp - damage);
updateHUD();
let message = ` A ghost attacked! You lost ${damage} .`;
if (stolenItems.length > 0) {
message += ` It stole: ${stolenItems.join(', ')}!`;
}
showMessage(message);
ghostsToRemove.push(entity.id);
const entityEl = visibleMonsterElements[entity.id];
if (entityEl) entityEl.remove();
delete visibleMonsterElements[entity.id];
if (gameState.player.hp <= 0) gameOver();
return;
}
return;
}
if (playerInShelterAtNight || OBJECT_DATA[entity.tile].type === 'special') return;
const atTarget = Math.hypot(entity.pixelPos.x - entity.targetPixelPos.x, entity.pixelPos.y - entity.targetPixelPos.y) < 1;
if (!atTarget) return;
let move = [0, 0];
const pPos = gameState.player.pos;
let targetPos = null;
if (entity.isBoss) {
const distanceToPlayer = Math.hypot(pPos.x - entity.x, pPos.y - entity.y);
if (distanceToPlayer < BOSS_CHASE_RANGE) {
targetPos = pPos;
} else if (entity.x !== entity.homePos.x || entity.y !== entity.homePos.y) {
targetPos = entity.homePos;
}
} else if (entity.isAggroed) {
targetPos = pPos;
}
if (targetPos) {
const dx = targetPos.x - entity.x;
const dy = targetPos.y - entity.y;
if (Math.abs(dx) > Math.abs(dy)) {
move[0] = Math.sign(dx);
} else if (dy !== 0) {
move[1] = Math.sign(dy);
} else if (dx !== 0) {
move[0] = Math.sign(dx);
}
} else {
if (Math.random() > 0.4) return;
const options = [
[0, -1],
[0, 1],
[-1, 0],
[1, 0]
];
move = options[Math.floor(Math.random() * 4)];
}
const newX = entity.x + move[0];
const newY = entity.y + move[1];
const canMove = !isTileBlocking(newX, newY);
if ((move[0] !== 0 || move[1] !== 0) && canMove) {
const oldX = entity.x;
const oldY = entity.y;
entity.x = newX;
entity.y = newY;
entity.targetPixelPos = {
x: newX * cellSize + cellSize / 2,
y: newY * cellSize + cellSize / 2
};
updateVisibleCells();
}
});
if (ghostsToRemove.length > 0) {
gameState.monsters = gameState.monsters.filter((m) => !ghostsToRemove.includes(m.id));
updateVisibleCells();
}
checkAggro();
}
function mainGameLoop(timestamp) {
if (gameState.isGameOver) {
cancelAnimationFrame(mainGameLoopId);
return;
}
const deltaTime = Math.min((timestamp - lastFrameTime) / 1000, 0.1);
lastFrameTime = timestamp;
processPlayerInputAndMove(deltaTime);
updateEntityPixelPositions(deltaTime);
updateProjectiles(deltaTime);
render();
mainGameLoopId = requestAnimationFrame(mainGameLoop);
}
function gameTick() {
if (gameState.isGameOver || gameState.isFighting) return;
updateTime();
moveEntities();
if (gameState.time % 10 === 0) {
respawnFoodIfNeeded();
}
if (gameState.isUnderworld && Math.random() < 0.05) {
triggerLightning();
}
}
function processPlayerInputAndMove(deltaTime) {
if (gameState.isFighting) {
playerElement.classList.remove('is-walking');
return;
}
let dx = 0;
let dy = 0;
if (keysPressed['w'] || keysPressed['arrowup']) dy = -1;
if (keysPressed['s'] || keysPressed['arrowdown']) dy = 1;
if (keysPressed['a'] || keysPressed['arrowleft']) dx = -1;
if (keysPressed['d'] || keysPressed['arrowright']) dx = 1;
if (dx === 0 && dy === 0) {
playerElement.classList.remove('is-walking');
return;
}
playerElement.classList.add('is-walking');
audioManager.playSoundThrottled('player_walk', 300);
const length = Math.sqrt(dx * dx + dy * dy);
if (length > 0) {
dx /= length;
dy /= length;
}
const moveAmount = PLAYER_SPEED * deltaTime;
const newPixelX = gameState.player.pixelPos.x + dx * moveAmount;
const newPixelY = gameState.player.pixelPos.y + dy * moveAmount;
const playerHalfWidth = cellSize / 4;
const targetXGrid = Math.floor((newPixelX + Math.sign(dx) * playerHalfWidth) / cellSize);
const currentYGridForXCheck = Math.floor(gameState.player.pixelPos.y / cellSize);
if (!isTileBlocking(targetXGrid, currentYGridForXCheck)) {
gameState.player.pixelPos.x = newPixelX;
}
const targetYGrid = Math.floor((newPixelY + Math.sign(dy) * playerHalfWidth) / cellSize);
const currentXGridForYCheck = Math.floor(gameState.player.pixelPos.x / cellSize);
if (!isTileBlocking(currentXGridForYCheck, targetYGrid)) {
gameState.player.pixelPos.y = newPixelY;
}
const oldGridX = gameState.player.pos.x;
const oldGridY = gameState.player.pos.y;
const newGridX = Math.floor(gameState.player.pixelPos.x / cellSize);
const newGridY = Math.floor(gameState.player.pixelPos.y / cellSize);
if (newGridX !== oldGridX || newGridY !== oldGridY) {
gameState.player.pos.x = newGridX;
gameState.player.pos.y = newGridY;
updateVisibleCells();
const targetTile = gameState.world[newGridY][newGridX];
handleInteraction(newGridX, newGridY, targetTile);
checkAggro();
}
}
function isTileBlocking(x, y) {
if (x < 0 || x >= WORLD_SIZE.cols || y < 0 || y >= WORLD_SIZE.rows) return true;
const targetTile = gameState.world[y][x];
const blockingTiles = [TILE.WALL_1, TILE.WALL_2, TILE.STONE, TILE.WATER, TILE.GEM, TILE.CAGE];
if (blockingTiles.includes(targetTile)) return true;
if (gameState.monsters.some((m) => !m.isDying && m.tile !== TILE.GHOST && m.tile !== TILE.SWAN && m.x === x && m.y === y)) return true;
if (gameState.npcs.some((n) => n.x === x && n.y === y)) return true;
return false;
}
function updateTime() {
if (gameState.level === 20) return;
gameState.time++;
const cycleDuration = DAY_DURATION + NIGHT_DURATION;
const timeInCycle = gameState.time % cycleDuration;
const wasDay = gameState.timeOfDay === 'day';
if (wasDay && timeInCycle >= DAY_DURATION) {
gameState.timeOfDay = 'night';
nightOverlay.classList.add('is-night');
audioManager.stopAmbiance('wind_ambiance');
audioManager.stopBirdSounds();
if (!gameState.isUnderworld) {
audioManager.startNightSounds();
}
gameState.monsters.forEach((m) => {
m.currentStrength = Math.floor(m.baseStrength * NIGHT_STRENGTH_BONUS);
});
setTimeout(spawnGhosts, 10000);
} else if (!wasDay && timeInCycle < DAY_DURATION) {
gameState.timeOfDay = 'day';
nightOverlay.classList.remove('is-night');
audioManager.stopNightSounds();
if (!gameState.isUnderworld) {
audioManager.startAmbiance('wind_ambiance');
audioManager.startBirdSounds();
}
gameState.monsters.forEach((m) => {
m.currentStrength = m.baseStrength;
});
despawnGhosts();
}
updateHUD();
}
function spawnGhosts() {
if (gameState.isFighting) return;
audioManager.playSound('ghost_spawn');
const ghostCount = 2 + gameState.level;
placeMonsters(TILE.GHOST, ghostCount);
showMessage("A sinister presence is felt... ");
}
function despawnGhosts() {
gameState.monsters.forEach((monster) => {
if (monster.tile === TILE.GHOST) {
const monsterEl = visibleMonsterElements[monster.id];
if (monsterEl) {
monsterEl.remove();
delete visibleMonsterElements[monster.id];
}
}
});
gameState.monsters = gameState.monsters.filter((monster) => monster.tile !== TILE.GHOST);
}
function respawnFoodIfNeeded() {
let foodCount = 0;
const foodTiles = [TILE.FOOD_1, TILE.FOOD_2];
for (let y = 0; y < WORLD_SIZE.rows; y++) {
for (let x = 0; x < WORLD_SIZE.cols; x++) {
if (foodTiles.includes(gameState.world[y][x])) {
foodCount++;
}
}
}
if (foodCount < MIN_FOOD_COUNT) {
placeObjectsInBiome(TILE.FOOD_1, Math.ceil(FOOD_RESPAWN_AMOUNT * 0.7), TILE.EMPTY, true);
placeObjectsInBiome(TILE.FOOD_2, Math.floor(FOOD_RESPAWN_AMOUNT * 0.3), TILE.EMPTY, true);
}
}
function jumpToLevel(level) {
closeModal();
messageQueue = [];
gameState.level = level - 1;
setupNewGame();
}
window.addEventListener('keydown', (e) => {
const key = e.key.toLowerCase();
if (isDisplayingMessage) {
if (key === 'escape' || key === 'enter') {
if (!messageBox.classList.contains('has-options') || gameState.isGameOver) {
(messageButton.onclick || closeModal)();
}
}
if (key === 'q') {
e.preventDefault();
const code = prompt('Enter code to switch levels:');
if (code === '1234') {
const levelInput = prompt('Which level do you want to jump to?', gameState.level);
const targetLevel = parseInt(levelInput);
if (!isNaN(targetLevel) && targetLevel > 0) {
jumpToLevel(targetLevel);
} else if (levelInput) {
alert('Invalid level. Enter a number greater than 0.');
}
} else if (code) {
alert('Incorrect code.');
}
}
} else {
keysPressed[key] = true;
if (['1', '2', '3', '4'].includes(key)) {
e.preventDefault();
const hotbar = WEAPON_HOTBAR_ORDER.filter(wId => gameState.player.inventory.includes(wId));
const weaponIndex = parseInt(key) - 1;
if (hotbar[weaponIndex]) {
equipWeapon(hotbar[weaponIndex]);
}
} else if (key === 'b') {
e.preventDefault();
buildShelter();
} else if (key === 'c') {
e.preventDefault();
buildCrossbow();
} else if (key === 'p') {
e.preventDefault();
craftArrows();
} else if (key === 'v') {
e.preventDefault();
buildStoneWeapon('sword');
} else if (key === 'h') {
e.preventDefault();
buildStoneWeapon('sledge');
} else if (key === 'm') {
e.preventDefault();
craftHealthPotion();
} else if (key === 'e') {
e.preventDefault();
handleNPCInteraction();
}
}
});
window.addEventListener('keyup', (e) => {
keysPressed[e.key.toLowerCase()] = false;
});
window.addEventListener('resize', () => {
if (!gameState || !mapGrid || !gameState.player || !gameState.player.pixelPos) {
return;
}
cellSize = (8 * Math.min(window.innerWidth, window.innerHeight)) / 100;
gameState.player.pixelPos = {
x: gameState.player.pos.x * cellSize + cellSize / 2,
y: gameState.player.pos.y * cellSize + cellSize / 2
};
const allEntities = [...(gameState.monsters || []), ...(gameState.npcs || [])];
allEntities.forEach(entity => {
entity.pixelPos = {
x: entity.x * cellSize + cellSize / 2,
y: entity.y * cellSize + cellSize / 2
};
entity.targetPixelPos = { ...entity.pixelPos };
});
if (gameState.activeProjectiles) {
gameState.activeProjectiles.forEach(p => p.el.remove());
gameState.activeProjectiles = [];
}
mapGrid.innerHTML = '';
visibleCellElements = {};
visibleMonsterElements = {};
visibleNpcElements = {};
updateVisibleCells(true);
render();
});
gameWorld.addEventListener('contextmenu', (e) => {
e.preventDefault();
const equipped = WEAPONS[gameState.player.equippedWeapon];
if (equipped && equipped.type === 'ranged' && !gameState.isFighting && !gameState.isGameOver) {
const worldRect = gameWorld.getBoundingClientRect();
const mapTransform = new DOMMatrix(getComputedStyle(mapGrid).transform);
const clickX = e.clientX - worldRect.left - mapTransform.e;
const clickY = e.clientY - worldRect.top - mapTransform.f;
shootCrossbow(clickX, clickY);
}
});
saveGameButton.addEventListener('click', saveGame);
document.getElementById('export-btn').addEventListener('click', exportSaveFile);
document.getElementById('import-btn').addEventListener('click', () => document.getElementById('import-input').click());
document.getElementById('import-input').addEventListener('change', importSaveFile);
howToPlayButton.addEventListener('click', showHowToPlay);
if (!loadGame()) {
setupNewGame();
}
showHowToPlay();
function forceInitialDraw() {
if (!gameState || !gameState.player || gameState.isGameOver || !mainGameLoopId) {
setTimeout(forceInitialDraw, 50);
return;
}
const gameWidth = gameContainer.clientWidth;
if (gameWidth > 0) {
console.log("Layout ferdig. Simulerer piltrykk for  tegne kartet...");
cellSize = (8 * Math.min(window.innerWidth, window.innerHeight)) / 100;
keysPressed['d'] = true;
setTimeout(() => {
keysPressed['d'] = false;
}, 50);
} else {
setTimeout(forceInitialDraw, 50);
}
}
document.body.addEventListener('click', () => audioManager.init(), { once: true });
document.body.addEventListener('keydown', () => audioManager.init(), { once: true });
forceInitialDraw();
});
</script>
</body>
</html>