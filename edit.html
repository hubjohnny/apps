<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Edit</title>
<style>
:root{
  --b:#000;
  --t:#39FF14;
  --f:'Courier New',monospace}
body{
  margin:0;
  overflow:hidden;
  background:var(--b)
}
#e{
  width:100vw;
  height:100vh;
  box-sizing:border-box;
  background:0;color:var(--t);
  border:0;
  outline:0;
  resize:none;
  font:16px var(--f);
  padding:15px;
  white-space:pre;
  caret-color:#00BFFF
}
#t{
  position:fixed;
  bottom:20px;
  right:20px;
  background:#111;
  color:var(--t);
  border:1px solid var(--t);
  padding:8px 12px;
  font:13px var(--f);
  pointer-events:none;
  opacity:0;
  transition:opacity .5s;z-index:9;
  box-shadow:0 0 10px #39ff1433
}
</style>
</head>
<body>
<textarea id="e" spellcheck="false"></textarea><div id="t"></div>
<script>
const E={h:null,n:'Untitled',d:!1,v:1,e:null,tm:null,
init(){
  this.e=document.getElementById('e');
  this.e.oninput=()=>{if(!this.d)this.dirty(!0)};
  this.e.onkeydown=this.tab.bind(this);
  document.onkeydown=this.key.bind(this);
  window.onbeforeunload=e=>{if(this.d){e.preventDefault();e.returnValue=''}};
  this.e.focus();
},
dirty(s){this.d=s;document.title=`${s?'*':''}${this.n}`},
async open(){
  if(this.d&&!confirm("Unsaved changes. Continue?"))return;
  if(!window.showOpenFilePicker)return alert("No API support");
  try{[this.h]=await showOpenFilePicker();const f=await this.h.getFile();this.e.value=await f.text();this.n=f.name;this.v=1;this.dirty(!1)}
catch(e){if(e.name!=='AbortError')alert(e.message)}
},
async save(){
  if(!window.showSaveFilePicker)return this.toast("No API support for saving. Falling back to download.");
  if(!this.h) {
    try {
      this.h = await showSaveFilePicker({
        suggestedName: this.n === 'Untitled' ? 'Untitled.txt' : this.n,
        types: [{
          description: 'Text Files',
          accept: {'text/plain': ['.txt', '.html', '.js', '.css']}
        }]
      });
      this.n = this.h.name;
    } catch(e) {
      if (e.name !== 'AbortError') this.toast(`Save failed: ${e.message}`);
      return;
    }
  }
  try {
    const writable = await this.h.createWritable();
    await writable.write(this.e.value);
    await writable.close();
    this.dirty(false);
    this.toast(`Saved to ${this.n}`);
  } catch(e) {
    this.toast(`Write failed: ${e.message}`);
  }
},
async clean(){
  const editor = this.e;
  const originalValue = editor.value;
  this.toast("Formatting code... Please wait.");
  await new Promise(resolve => setTimeout(resolve, 50));
  let c = 0;
  const re = /(\/\*[\s\S]*?\*\/)|(\/\/[^\n]*)|("[^"\\]*(?:\\.[^"\\]*)*"|'[^'\\]*(?:\\.[^'\\]*)*'|`[^`\\]*(?:\\.[^`\\]*)*`)/g;
  let text = originalValue.replace(re, (match, blockComment, lineComment, stringLiteral) => {
    if (blockComment || lineComment) {
      c++;
      return '';
    }
    return match;
  });
  let lines = text.split('\n')
  .map(l => l.trim())
  .filter(l => l.length > 0);
  const formattedLines = [];
  let currentLevel = 0;
  const indentUnit = '  ';
  const voidTags = ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source', 'track', 'wbr', '!doctype'];
  const rootTags = ['html', 'head', 'body', 'script', 'style', '!doctype'];
  lines.forEach((line) => {
    let tagName = '';
    const tagMatch = line.match(/^<\/?([a-zA-Z0-9-]+)/);
    if (tagMatch) tagName = tagMatch[1].toLowerCase();
    const isHtmlRoot = rootTags.includes(tagName);
    const isStandardDef = /^(export\s+)?(async\s+)?(function|class)\b/.test(line);
    const isMethodDef = /^\s*(async\s+)?(?!(if|for|while|switch|catch)\b)[a-zA-Z_$][\w$]*\s*\(.*?\)\s*\{/.test(line);
      const isJsRoot = isStandardDef || isMethodDef;
      if (isJsRoot || isHtmlRoot) {
        currentLevel = 0;
      }
      const openBraces = (line.match(/\{/g) || []).length;
        const closeBraces = (line.match(/\}/g) || []).length;
      let openTags = 0;
      let closeTags = 0;
      if (/^<[a-zA-Z0-9-]+/.test(line) && !line.includes('</') && !line.endsWith('/>') && !voidTags.includes(tagName)) {
        if (!isHtmlRoot) openTags = 1;
      }
      if (line.match(/^<\/[a-zA-Z0-9-]+/)) {
        if (!isHtmlRoot) closeTags = 1;
      }
      let printLevel = currentLevel;
      const startsWithClosing = line.match(/^(\}|\]|\)|\<\/)/);
    const isContinuation = /^(else|catch|finally)/.test(line);
    if (startsWithClosing || isContinuation) {
      printLevel = Math.max(0, currentLevel - 1);
    }
    formattedLines.push(indentUnit.repeat(printLevel) + line);
    const netChange = (openBraces - closeBraces) + (openTags - closeTags);
    currentLevel = Math.max(0, currentLevel + netChange);
  });
  const newValue = formattedLines.join('\n');
  if (originalValue !== newValue) {
    editor.value = newValue;
    if(!this.d)this.dirty(!0);
    this.toast(`Done! Code is clean, indented, and ${c} comments removed. ✨`);
  } else {
    this.toast("Already clean! ✨");
  }
},
preview(){
  const win = window.open();
  if(win) {
    win.document.write(this.e.value);
    win.document.close();
  }
},
jumpToSection(tag) {
  const val = this.e.value;
  let idx = val.indexOf(`<${tag}`, this.e.selectionStart + 1);
  if (idx === -1) {
    idx = val.indexOf(`<${tag}`);
  }
  if (idx > -1) this.jumpTo(idx);
else this.toast(`Tag <${tag}> not found.`);
},
jumpToNextDefinition() {
  this.regexJump(/(^\s*(?!if|for|while|switch|catch)\w+\s*\(.*?\)\s*\{|^\s*function\s+\w+)/gm, "Next Definition");
  },
jumpToComment() {
  this.regexJump(/(\/\*[\s\S]*?\*\/|(?<!:)\/\/.*)/g, "Next Comment");
},
regexJump(regex, type) {
  const val = this.e.value;
  const current = this.e.selectionStart;
  let match;
  let next = -1;
  let first = -1;
  regex.lastIndex = 0;
  while ((match = regex.exec(val)) !== null) {
    if (first === -1) first = match.index;
    if (match.index > current) {
      next = match.index;
      break;
    }
  }
  if (next === -1 && first > -1) {
    this.jumpTo(first);
    this.toast(`Cycled to first ${type}.`);
  } else if (next > -1) {
    this.jumpTo(next);
    this.toast(`Jumped to ${type}.`);
  } else {
    this.toast(`No ${type} found.`);
  }
},
jumpTo(idx) {
  if (idx === -1) return;
  const editor = this.e;
  const computedStyle = window.getComputedStyle(editor);
  const lineHeight = parseFloat(computedStyle.lineHeight) || 16;
  editor.setSelectionRange(idx, idx);
  const lines = editor.value.substr(0, idx).split('\n').length - 1;
  const newScrollTop = (lines * lineHeight) - (editor.clientHeight / 2) + (lineHeight / 2);
  editor.scrollTo({
    top: newScrollTop,
    behavior: 'smooth'
  });
  editor.blur();
  setTimeout(() => {
    editor.focus();
  }, 10);
},
toast(m){const el=document.getElementById('t');el.innerText=m;el.style.opacity=1;if(this.tm)clearTimeout(this.tm);this.tm=setTimeout(()=>el.style.opacity=0,4000)},
key(e){
  const isCtrlOrCmd = e.metaKey || e.ctrlKey;
  const key = e.key.toLowerCase();
  if (isCtrlOrCmd && !e.shiftKey) {
    if(['o','s','b','p'].includes(key)){
      e.preventDefault();
      if(key==='o')this.open();
      if(key==='s')this.save();
      if(key==='b')this.clean();
      if(key==='p')this.preview();
    }
    return;
  }
  if(isCtrlOrCmd && e.shiftKey){
    const code = e.code;
    if(['Digit1', 'Digit2', 'Digit3', 'Digit4'].includes(code)){
      e.preventDefault();
      const num = code.slice(-1);
      if(num === '1') {
        this.jumpToSection('style');
      } else if(num === '2') {
        this.jumpToSection('body');
      } else if(num === '3') {
        this.jumpToComment();
      } else if(num === '4') {
        this.jumpToNextDefinition();
      }
    }
  }
},
tab(e){
  if(e.key!=='Tab')return;e.preventDefault();const el=this.e,t='  ';
  const s=el.value.lastIndexOf('\n',el.selectionStart-1)+1,x=el.value.indexOf('\n',el.selectionEnd-1),end=x===-1?el.value.length:x;
  const l=el.value.substring(s,end).split('\n');
  let ch=!1,nT=l.map(r=>{
    if(e.shiftKey){
      if(r.startsWith(t)){ch=!0;return r.substring(t.length)}
    else if(r.startsWith(' ')){ch=!0;return r.substring(1)}
      return r
    }
  else{
      ch=!0;return t+r
    }
  }).join('\n');
  if(ch){el.setRangeText(nT,s,end,'select');if(!this.d)this.dirty(!0)}
}};
window.onload=()=>E.init();
</script>
</body>
</html>