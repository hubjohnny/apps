<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Edit</title>
<style>
:root{
  --b:#000;
  --t:#39FF14;
  --f:'Courier New',monospace}
body{
  margin:0;
  overflow:hidden;
  background:var(--b)
}
#e{
  width:100vw;
  height:100vh;
  box-sizing:border-box;
  background:0;color:var(--t);
  border:0;
  outline:0;
  resize:none;
  font:16px var(--f);
  padding:15px;
  white-space:pre;
  caret-color:#00BFFF
}
#t{
  position:fixed;
  bottom:20px;
  right:20px;
  background:#111;
  color:var(--t);
  border:1px solid var(--t);
  padding:8px 12px;
  font:13px var(--f);
  pointer-events:none;
  opacity:0;
  transition:opacity .5s;z-index:9;
  box-shadow:0 0 10px #39ff1433
}
</style>
</head>
<body>
<textarea id="e" spellcheck="false"></textarea><div id="t"></div>
<script>
const E={h:null,n:'Untitled',d:!1,v:1,e:null,tm:null,
init(){
  this.e=document.getElementById('e');
  this.e.oninput=()=>{if(!this.d)this.dirty(!0)};
  this.e.onkeydown=this.tab.bind(this);
  document.onkeydown=this.key.bind(this);
  window.onbeforeunload=e=>{if(this.d){e.preventDefault();e.returnValue=''}};
  this.e.focus();
},
dirty(s){this.d=s;document.title=`${s?'*':''}${this.n}`},
async open(){
  if(this.d&&!confirm("Unsaved changes. Continue?"))return;
  if(!window.showOpenFilePicker)return alert("No API support");
  try{[this.h]=await showOpenFilePicker();const f=await this.h.getFile();this.e.value=await f.text();this.n=f.name;this.v=1;this.dirty(!1)}
catch(e){if(e.name!=='AbortError')alert(e.message)}
},
async save(){
  if(!window.showSaveFilePicker)return this.toast("No API support for saving. Falling back to download.");
  if(!this.h) {
    try {
      this.h = await showSaveFilePicker({
        suggestedName: this.n === 'Untitled' ? 'Untitled.txt' : this.n,
        types: [{
          description: 'Text Files',
          accept: {'text/plain': ['.txt', '.html', '.js', '.css']}
        }]
      });
      this.n = this.h.name;
    } catch(e) {
      if (e.name !== 'AbortError') this.toast(`Save failed: ${e.message}`);
      return;
    }
  }
  try {
    const writable = await this.h.createWritable();
    await writable.write(this.e.value);
    await writable.close();
    this.dirty(false);
    this.toast(`Saved to ${this.n}`);
  } catch(e) {
    this.toast(`Write failed: ${e.message}`);
  }
},
async clean(){
  const editor = this.e;
  const originalValue = editor.value;
  this.toast("Formatting code... Please wait.");
  await new Promise(resolve => setTimeout(resolve, 50));
  let c = 0;
  const re = /(\/\*[\s\S]*?\*\/)|(\/\/[^\n]*)|("[^"\\]*(?:\\.[^"\\]*)*"|'[^'\\]*(?:\\.[^'\\]*)*'|`[^`\\]*(?:\\.[^`\\]*)*`)/g;
  let text = originalValue.replace(re, (match, blockComment, lineComment, stringLiteral) => {
    if (blockComment || lineComment) {
      c++;
      return '';
    }
    return match;
  });
  let lines = text.split('\n')
  .map(l => l.trim())
  .filter(l => l.length > 0);
  const formattedLines = [];
  let currentLevel = 0;
  const indentUnit = '  ';
  const voidTags = ['area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'link', 'meta', 'param', 'source', 'track', 'wbr', '!doctype'];
  const rootTags = ['html', 'head', 'body', 'script', 'style', '!doctype'];
  lines.forEach((line) => {
    let tagName = '';
    const tagMatch = line.match(/^<\/?([a-zA-Z0-9-]+)/);
    if (tagMatch) tagName = tagMatch[1].toLowerCase();
    const isHtmlRoot = rootTags.includes(tagName);
    const isStandardDef = /^(export\s+)?(async\s+)?(function|class)\b/.test(line);
    const isMethodDef = /^\s*(async\s+)?(?!(if|for|while|switch|catch)\b)[a-zA-Z_$][\w$]*\s*\(.*?\)\s*\{/.test(line);
      const isJsRoot = isStandardDef || isMethodDef;
      if (isJsRoot || isHtmlRoot) {
        currentLevel = 0;
      }
      const openBraces = (line.match(/\{/g) || []).length;
        const closeBraces = (line.match(/\}/g) || []).length;
      let openTags = 0;
      let closeTags = 0;
      if (/^<[a-zA-Z0-9-]+/.test(line) && !line.includes('</') && !line.endsWith('/>') && !voidTags.includes(tagName)) {
        if (!isHtmlRoot) openTags = 1;
      }
      if (line.match(/^<\/[a-zA-Z0-9-]+/)) {
        if (!isHtmlRoot) closeTags = 1;
      }
      let printLevel = currentLevel;
      const startsWithClosing = line.match(/^(\}|\]|\)|\<\/)/);
    const isContinuation = /^(else|catch|finally)/.test(line);
    if (startsWithClosing || isContinuation) {
      printLevel = Math.max(0, currentLevel - 1);
    }
    formattedLines.push(indentUnit.repeat(printLevel) + line);
    const netChange = (openBraces - closeBraces) + (openTags - closeTags);
    currentLevel = Math.max(0, currentLevel + netChange);
  });
  const newValue = formattedLines.join('\n');
  if (originalValue !== newValue) {
    editor.value = newValue;
    if(!this.d)this.dirty(!0);
    this.toast(`Done! Code is clean, indented, and ${c} comments removed. ✨`);
  } else {
    this.toast("Already clean! ✨");
  }
},
preview(){
  const win = window.open();
  if(win) {
    win.document.write(this.e.value);
    win.document.close();
  }
},
toast(m){const el=document.getElementById('t');el.innerText=m;el.style.opacity=1;if(this.tm)clearTimeout(this.tm);this.tm=setTimeout(()=>el.style.opacity=0,4000)},
key(e){
  if(!e.metaKey&&!e.ctrlKey)return;
  const k=e.key.toLowerCase();
  if(['o','s','b', 'p'].includes(k)){
    e.preventDefault();
    if(k==='o')this.open();
    if(k==='s')this.save();
    if(k==='b')this.clean();
    if(k==='p')this.preview();
  }
},
tab(e){
  if(e.key!=='Tab')return;e.preventDefault();const el=this.e,t='  ';
  const s=el.value.lastIndexOf('\n',el.selectionStart-1)+1,x=el.value.indexOf('\n',el.selectionEnd-1),end=x===-1?el.value.length:x;
  const l=el.value.substring(s,end).split('\n');
  let ch=!1,nT=l.map(r=>{
    if(e.shiftKey){
      if(r.startsWith(t)){ch=!0;return r.substring(t.length)}
    else if(r.startsWith(' ')){ch=!0;return r.substring(1)}
      return r
    }
  else{
      ch=!0;return t+r
    }
  }).join('\n');
  if(ch){el.setRangeText(nT,s,end,'select');if(!this.d)this.dirty(!0)}
}};
window.onload=()=>E.init();
</script>
</body>
</html>