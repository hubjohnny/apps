<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Image Editor</title>
<style>
:root {
--bg-color: #1e1e1e;
--primary-color: #2d2d2d;
--secondary-color: #3c3c3c;
--text-color: #e0e0e0;
--accent-color: #007acc;
--border-color: #4a4a4a;
--font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}
html, body {
margin: 0;
padding: 0;
width: 100%;
height: 100vh;
font-family: var(--font-family);
background-color: var(--bg-color);
color: var(--text-color);
overflow: hidden;
}
body {
display: grid;
grid-template-rows: auto 1fr;
}
.options-bar {
background-color: var(--primary-color);
padding: 5px 15px;
border-bottom: 1px solid var(--border-color);
display: flex;
align-items: center;
gap: 10px;
min-height: 40px;
flex-wrap: wrap;
z-index: 10;
box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}
.options-bar label, .options-bar button, .options-bar input, .options-bar select, .options-bar span {
margin: 0;
font-size: 13px;
display: flex;
align-items: center;
}
.options-bar input, .options-bar select {
background-color: var(--secondary-color);
color: var(--text-color);
border: 1px solid var(--border-color);
border-radius: 3px;
padding: 4px 6px;
transition: border-color 0.2s;
}
.options-bar input[type="number"] { max-width: 60px; }
.options-bar input[type="text"] { max-width: 150px; }
.options-bar input:focus, .options-bar select:focus { outline: none; border-color: var(--accent-color); }
.options-bar button {
background-color: var(--accent-color);
color: white;
border: none;
padding: 5px 12px;
border-radius: 3px;
cursor: pointer;
transition: opacity 0.2s;
}
.options-bar button:hover { opacity: 0.9; }
.separator {
width: 1px;
height: 20px;
background-color: var(--border-color);
margin: 0 5px;
}
.main-container {
display: flex;
overflow: hidden;
position: relative;
height: 100%;
}
.toolbar {
background-color: var(--primary-color);
padding: 10px;
display: flex;
flex-direction: column;
gap: 10px;
width: 50px;
border-right: 1px solid var(--border-color);
align-items: center;
z-index: 5;
}
.tool-btn {
background-color: var(--secondary-color);
border: 1px solid var(--border-color);
color: var(--text-color);
cursor: pointer;
width: 40px;
height: 40px;
font-size: 18px;
border-radius: 4px;
transition: all 0.2s;
display: flex;
align-items: center;
justify-content: center;
}
.tool-btn:hover { background-color: #444; }
.tool-btn.active { background-color: var(--accent-color); border-color: white; }
.canvas-container {
flex: 1;
display: grid;
place-items: center;
overflow: hidden;
background-image:
linear-gradient(45deg, #2a2a2a 25%, transparent 25%),
linear-gradient(-45deg, #2a2a2a 25%, transparent 25%),
linear-gradient(45deg, transparent 75%, #2a2a2a 75%),
linear-gradient(-45deg, transparent 75%, #2a2a2a 75%);
background-size: 20px 20px;
background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
position: relative;
}
canvas {
box-shadow: 0 0 20px rgba(0, 0, 0, 0.6);
cursor: default;
}
.right-panel {
width: 240px;
background-color: var(--primary-color);
border-left: 1px solid var(--border-color);
display: flex;
flex-direction: column;
overflow-y: auto;
z-index: 5;
}
.panel-section {
padding: 12px;
border-bottom: 1px solid var(--border-color);
}
.panel-section h4 {
margin: 0 0 10px 0;
font-size: 14px;
text-transform: uppercase;
color: #888;
font-weight: 600;
letter-spacing: 0.5px;
}
#layers-list {
list-style: none;
padding: 0;
margin: 0;
max-height: 250px;
overflow-y: auto;
}
#layers-list li {
background-color: var(--secondary-color);
padding: 8px 10px;
margin-bottom: 4px;
cursor: pointer;
border: 1px solid transparent;
border-radius: 3px;
font-size: 13px;
display: flex;
justify-content: space-between;
align-items: center;
user-select: none;
}
#layers-list li.active {
border-color: var(--accent-color);
background-color: #4a4a4a;
}
#layers-list li .visibility-toggle {
cursor: pointer;
opacity: 0.6;
margin-right: 8px;
}
#layers-list li .visibility-toggle:hover { opacity: 1; }
.layer-controls {
display: flex;
gap: 4px;
margin-top: 10px;
}
.layer-controls button {
flex: 1;
padding: 4px;
font-size: 14px;
background-color: var(--secondary-color);
border: 1px solid var(--border-color);
color: var(--text-color);
cursor: pointer;
border-radius: 3px;
}
.layer-controls button:hover { background-color: #555; }
#export-preview {
max-width: 100%;
height: auto;
margin-top: 10px;
border: 1px solid var(--border-color);
background: #000;
}
#crop-info {
position: fixed;
background-color: rgba(0, 122, 204, 0.9);
color: white;
padding: 4px 8px;
font-size: 12px;
border-radius: 3px;
pointer-events: none;
display: none;
z-index: 1000;
box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}
.adjustment-slider {
width: 100%;
margin-bottom: 8px;
-webkit-appearance: none;
height: 4px;
background: #555;
outline: none;
border-radius: 2px;
}
.adjustment-slider::-webkit-slider-thumb {
-webkit-appearance: none;
width: 14px;
height: 14px;
border-radius: 50%;
background: var(--accent-color);
cursor: pointer;
border: 2px solid #fff;
}
.adjustment-group {
margin-bottom: 12px;
}
.adjustment-group label {
display: flex;
justify-content: space-between;
font-size: 12px;
margin-bottom: 4px;
}
</style>
</head>
<body>
<input type="file" id="file-input" accept="image/*" style="display: none;">
<input type="file" id="project-input" accept=".json" style="display: none;">
<div class="options-bar">
<button id="open-btn">Open</button>
<button id="import-btn">Import</button>
<div class="separator"></div>
<button id="save-project-btn">Save Project</button>
<button id="load-project-btn">Load Project</button>
<div class="separator"></div>
<button id="flatten-btn">Flatten</button>
<div class="separator"></div>
<span>W:</span>
<input type="number" id="resize-width" min="1">
<span>H:</span>
<input type="number" id="resize-height" min="1">
<label title="Keep Aspect Ratio"><input type="checkbox" id="keep-proportions" checked> üîó</label>
<button id="resize-btn">Resize</button>
<div class="separator"></div>
<button id="zoom-out-btn" title="Zoom out">-</button>
<button id="fit-to-screen-btn" title="Fit to screen">[ ]</button>
<button id="zoom-in-btn" title="Zoom in">+</button>
<span id="zoom-display">100%</span>
<div class="separator"></div>
<div id="crop-options" style="display: none; align-items: center; gap: 10px;">
<button id="apply-crop-btn">‚úÖ Apply Crop</button>
</div>
<div id="text-options" style="display: none; align-items: center; gap: 10px;">
<input type="text" id="text-input" placeholder="Text...">
<input type="color" id="text-color" value="#ffffff" title="Text Color">
<select id="font-select">
<option>Arial</option>
<option>Verdana</option>
<option>Times New Roman</option>
<option>Courier New</option>
<option>Impact</option>
<option>Segoe UI</option>
</select>
<input type="number" id="font-size" value="48" min="1" title="Font Size">
<button id="add-text-btn">Add</button>
<label><input type="checkbox" id="text-shadow"> Shadow</label>
</div>
</div>
<div class="main-container">
<div class="toolbar">
<button class="tool-btn active" id="tool-move" title="Move Tool (V)">V</button>
<button class="tool-btn" id="tool-crop" title="Crop Tool (C)">C</button>
<button class="tool-btn" id="tool-text" title="Text Tool (T)">T</button>
</div>
<div class="canvas-container" id="canvas-container">
<canvas id="canvas"></canvas>
<div id="crop-info"></div>
</div>
<div class="right-panel">
<div class="panel-section">
<h4>Layers</h4>
<div class="layer-controls" style="margin-bottom: 10px;">
<button id="layer-up-btn" title="Move Up">‚ñ≤</button>
<button id="layer-down-btn" title="Move Down">‚ñº</button>
<button id="layer-duplicate-btn" title="Duplicate">üìã</button>
<button id="layer-delete-btn" title="Delete">üóëÔ∏è</button>
</div>
<ul id="layers-list"></ul>
<div style="margin-top: 15px;">
<label style="display:flex; justify-content:space-between; font-size:12px;">Opacity <span id="layer-opacity-value">100%</span></label>
<input type="range" id="layer-opacity" class="adjustment-slider" min="0" max="1" step="0.01" value="1">
</div>
<div style="margin-top: 5px;">
<select id="layer-blend-mode" style="width: 100%; padding: 4px;">
<option value="source-over">Normal</option>
<option value="multiply">Multiply</option>
<option value="screen">Screen</option>
<option value="overlay">Overlay</option>
<option value="darken">Darken</option>
<option value="lighten">Lighten</option>
<option value="hard-light">Hard Light</option>
<option value="soft-light">Soft Light</option>
<option value="difference">Difference</option>
<option value="luminosity">Luminosity</option>
</select>
</div>
</div>
<div class="panel-section" id="adjustments-panel" style="display: none;">
<h4>Adjustments</h4>
<div class="adjustment-group">
<label>Brightness <span id="brightness-value">0</span></label>
<input type="range" id="adj-brightness" class="adjustment-slider" min="-100" max="100" value="0">
</div>
<div class="adjustment-group">
<label>Contrast <span id="contrast-value">0</span></label>
<input type="range" id="adj-contrast" class="adjustment-slider" min="-100" max="100" value="0">
</div>
<div class="adjustment-group">
<label>Saturation <span id="saturation-value">0</span></label>
<input type="range" id="adj-saturation" class="adjustment-slider" min="-100" max="100" value="0">
</div>
<div class="adjustment-group">
<label>Blur (px) <span id="blur-value">0</span></label>
<input type="range" id="filter-blur" class="adjustment-slider" min="0" max="20" step="0.1" value="0">
</div>
</div>
<div class="panel-section" id="filters-panel" style="display: none;">
<h4>Filters</h4>
<div style="display: flex; gap: 5px;">
<button id="filter-sharpen" style="width: 100%; padding: 6px;">Sharpen</button>
<button id="filter-emboss" style="width: 100%; padding: 6px;">Emboss</button>
</div>
<div style="margin-top: 5px;">
<button id="filter-grayscale" style="width: 100%; padding: 6px;">Grayscale</button>
</div>
</div>
<div class="panel-section">
<h4>Export</h4>
<div style="display:flex; gap:5px; margin-bottom:5px;">
<select id="export-format" style="flex:1;">
<option value="image/png">PNG</option>
<option value="image/jpeg">JPEG</option>
<option value="image/webp">WEBP</option>
</select>
<button id="export-btn" style="flex:1;">Download</button>
</div>
<div id="quality-control" style="display:none; margin-bottom: 10px;">
<label style="font-size:11px;">Quality</label>
<input type="range" id="export-quality" class="adjustment-slider" min="0.1" max="1" step="0.1" value="0.9">
</div>
<img id="export-preview" src="" alt="Preview">
<div id="file-size-info" style="font-size: 11px; text-align: center; margin-top: 5px; color: #888;"></div>
</div>
</div>
</div>
<script>
document.addEventListener('DOMContentLoaded', () => {
const CONSTANTS = {
TOOLS: { MOVE: 'move', CROP: 'crop', TEXT: 'text' },
PAN_BUTTON: 1,
DEFAULT_W: 800,
DEFAULT_H: 600,
DEFAULTS_ADJ: { brightness: 0, contrast: 0, saturation: 0, blur: 0 }
};
const state = {
layers: [],
activeLayerIndex: -1,
currentTool: CONSTANTS.TOOLS.MOVE,
logicalWidth: CONSTANTS.DEFAULT_W,
logicalHeight: CONSTANTS.DEFAULT_H,
currentAspectRatio: CONSTANTS.DEFAULT_W / CONSTANTS.DEFAULT_H,
zoom: 1.0,
panX: 0,
panY: 0,
mouse: {
isDown: false,
startX: 0,
startY: 0,
dragOffsetX: 0,
dragOffsetY: 0,
originalLayerState: null,
activeHandle: null,
},
status: {
isDragging: false,
isCropping: false,
isPanning: false,
isResizingLayer: false,
isMovingCrop: false,
isResizingCrop: false,
},
cropRect: { x: 0, y: 0, w: 0, h: 0 }
};
const DOM = {
canvas: document.getElementById('canvas'),
container: document.getElementById('canvas-container'),
ctx: document.getElementById('canvas').getContext('2d'),
fileInput: document.getElementById('file-input'),
projectInput: document.getElementById('project-input'),
widthInput: document.getElementById('resize-width'),
heightInput: document.getElementById('resize-height'),
keepRatio: document.getElementById('keep-proportions'),
layersList: document.getElementById('layers-list'),
adjPanel: document.getElementById('adjustments-panel'),
filtersPanel: document.getElementById('filters-panel'),
zoomDisplay: document.getElementById('zoom-display'),
cropInfo: document.getElementById('crop-info'),
exportPreview: document.getElementById('export-preview'),
fileSizeInfo: document.getElementById('file-size-info')
};
const clamp = (val, min, max) => Math.min(Math.max(val, min), max);
const getNormalizedRect = (rect) => ({
x: rect.w < 0 ? rect.x + rect.w : rect.x,
y: rect.h < 0 ? rect.y + rect.h : rect.y,
w: Math.abs(rect.w),
h: Math.abs(rect.h),
});
const getMousePos = (e) => {
const rect = DOM.canvas.getBoundingClientRect();
const mouseX = e.clientX - rect.left;
const mouseY = e.clientY - rect.top;
const worldX = (mouseX - rect.width / 2 - state.panX) / state.zoom + state.logicalWidth / 2;
const worldY = (mouseY - rect.height / 2 - state.panY) / state.zoom + state.logicalHeight / 2;
return { x: worldX, y: worldY };
};
const getHandles = (rect) => {
const { x, y, w, h } = rect;
return {
topLeft: { x, y },
topMiddle: { x: x + w / 2, y },
topRight: { x: x + w, y },
middleLeft: { x, y: y + h / 2 },
middleRight: { x: x + w, y: y + h / 2 },
bottomLeft: { x, y: y + h },
bottomMiddle: { x: x + w / 2, y: y + h },
bottomRight: { x: x + w, y: y + h },
};
};
const updateCanvasSize = () => {
const rect = DOM.container.getBoundingClientRect();
DOM.canvas.style.width = `${rect.width}px`;
DOM.canvas.style.height = `${rect.height}px`;
const dpr = window.devicePixelRatio || 1;
DOM.canvas.width = rect.width * dpr;
DOM.canvas.height = rect.height * dpr;
DOM.ctx.scale(dpr, dpr);
redrawCanvas();
};
const drawCheckerboard = (ctx, x, y, width, height) => {
const size = 20;
ctx.fillStyle = '#252525';
for (let i = 0; i < Math.ceil(width / size); i++) {
for (let j = 0; j < Math.ceil(height / size); j++) {
if ((i + j) % 2 === 0) ctx.fillRect(x + i * size, y + j * size, size, size);
}
}
};
const createFlattenedCanvas = () => {
const tempCanvas = document.createElement('canvas');
tempCanvas.width = state.logicalWidth;
tempCanvas.height = state.logicalHeight;
const tempCtx = tempCanvas.getContext('2d');
tempCtx.fillStyle = '#ffffff';
tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
drawLayers(tempCtx);
return tempCanvas;
};
const drawLayers = (targetCtx) => {
state.layers.forEach(layer => {
if (!layer.visible) return;
targetCtx.save();
targetCtx.globalAlpha = layer.opacity;
targetCtx.globalCompositeOperation = layer.blendMode;
let filterString = '';
if (layer.adjustments) {
if (layer.adjustments.brightness !== 0) filterString += `brightness(${100 + layer.adjustments.brightness}%) `;
if (layer.adjustments.contrast !== 0) filterString += `contrast(${100 + layer.adjustments.contrast}%) `;
if (layer.adjustments.saturation !== 0) filterString += `saturate(${100 + layer.adjustments.saturation}%) `;
if (layer.adjustments.blur > 0) filterString += `blur(${layer.adjustments.blur}px) `;
}
if (filterString) targetCtx.filter = filterString;
if (layer.type === 'image') {
targetCtx.drawImage(layer.content, layer.x, layer.y, layer.width, layer.height);
} else if (layer.type === 'text') {
targetCtx.font = `${layer.fontSize}px ${layer.font}`;
targetCtx.fillStyle = layer.color;
targetCtx.textBaseline = 'top';
if (layer.shadow) {
targetCtx.shadowColor = 'rgba(0,0,0,0.5)';
targetCtx.shadowBlur = 5;
targetCtx.shadowOffsetX = 2;
targetCtx.shadowOffsetY = 2;
}
targetCtx.fillText(layer.content, layer.x, layer.y);
}
targetCtx.restore();
});
};
const redrawCanvas = () => {
const dpr = window.devicePixelRatio || 1;
const ctx = DOM.ctx;
ctx.save();
ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
ctx.clearRect(0, 0, DOM.canvas.width / dpr, DOM.canvas.height / dpr);
const viewW = DOM.canvas.width / dpr;
const viewH = DOM.canvas.height / dpr;
ctx.translate(viewW / 2 + state.panX, viewH / 2 + state.panY);
ctx.scale(state.zoom, state.zoom);
ctx.translate(-state.logicalWidth / 2, -state.logicalHeight / 2);
ctx.fillStyle = '#fff';
ctx.fillRect(0, 0, state.logicalWidth, state.logicalHeight);
drawCheckerboard(ctx, 0, 0, state.logicalWidth, state.logicalHeight);
drawLayers(ctx);
drawOverlays(ctx);
ctx.restore();
};
const drawOverlays = (ctx) => {
const zoom = state.zoom;
if (state.currentTool === CONSTANTS.TOOLS.MOVE && state.activeLayerIndex !== -1) {
const layer = state.layers[state.activeLayerIndex];
if (layer && layer.visible) {
ctx.strokeStyle = '#007acc';
ctx.lineWidth = 1 / zoom;
ctx.strokeRect(layer.x, layer.y, layer.width, layer.height);
drawHandlePoints(ctx, getHandles({x: layer.x, y: layer.y, w: layer.width, h: layer.height}));
}
}
if (state.currentTool === CONSTANTS.TOOLS.CROP && (state.cropRect.w !== 0 || state.status.isCropping)) {
const norm = getNormalizedRect(state.cropRect);
ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
ctx.beginPath();
ctx.rect(0, 0, state.logicalWidth, state.logicalHeight);
ctx.rect(norm.x, norm.y, norm.w, norm.h);
ctx.fill('evenodd');
ctx.strokeStyle = 'white';
ctx.lineWidth = 1 / zoom;
ctx.setLineDash([5 / zoom, 5 / zoom]);
ctx.strokeRect(norm.x, norm.y, norm.w, norm.h);
ctx.setLineDash([]);
drawHandlePoints(ctx, getHandles(norm));
}
};
const drawHandlePoints = (ctx, handles) => {
const size = 8 / state.zoom;
ctx.fillStyle = 'white';
ctx.strokeStyle = '#007acc';
ctx.lineWidth = 1 / state.zoom;
for (const key in handles) {
const p = handles[key];
ctx.fillRect(p.x - size/2, p.y - size/2, size, size);
ctx.strokeRect(p.x - size/2, p.y - size/2, size, size);
}
};
function handleMouseDown(e) {
if (e.button === CONSTANTS.PAN_BUTTON || (e.altKey && e.button === 0)) {
state.status.isPanning = true;
DOM.canvas.style.cursor = 'grabbing';
return;
}
if (e.button !== 0) return;
const pos = getMousePos(e);
state.mouse.startX = pos.x;
state.mouse.startY = pos.y;
state.mouse.isDown = true;
if (checkHandleClick(pos)) return;
if (state.currentTool === CONSTANTS.TOOLS.MOVE) {
checkLayerClick(pos);
} else if (state.currentTool === CONSTANTS.TOOLS.CROP) {
state.status.isCropping = true;
state.cropRect = { x: pos.x, y: pos.y, w: 0, h: 0 };
document.getElementById('crop-options').style.display = 'none';
}
}
function checkHandleClick(pos) {
const handleSize = 10 / state.zoom;
if (state.currentTool === CONSTANTS.TOOLS.CROP && state.cropRect.w !== 0) {
const handles = getHandles(getNormalizedRect(state.cropRect));
for (const name in handles) {
const h = handles[name];
if (Math.abs(pos.x - h.x) < handleSize && Math.abs(pos.y - h.y) < handleSize) {
state.status.isResizingCrop = true;
state.mouse.activeHandle = name;
state.mouse.originalLayerState = { ...state.cropRect };
return true;
}
}
const norm = getNormalizedRect(state.cropRect);
if (pos.x >= norm.x && pos.x <= norm.x + norm.w && pos.y >= norm.y && pos.y <= norm.y + norm.h) {
state.status.isMovingCrop = true;
state.mouse.dragOffsetX = pos.x - state.cropRect.x;
state.mouse.dragOffsetY = pos.y - state.cropRect.y;
return true;
}
}
if (state.currentTool === CONSTANTS.TOOLS.MOVE && state.activeLayerIndex !== -1) {
const layer = state.layers[state.activeLayerIndex];
if (layer) {
const handles = getHandles({x: layer.x, y: layer.y, w: layer.width, h: layer.height});
for (const name in handles) {
const h = handles[name];
if (Math.abs(pos.x - h.x) < handleSize && Math.abs(pos.y - h.y) < handleSize) {
state.status.isResizingLayer = true;
state.mouse.activeHandle = name;
state.mouse.originalLayerState = { ...layer };
return true;
}
}
}
}
return false;
}
function checkLayerClick(pos) {
for (let i = state.layers.length - 1; i >= 0; i--) {
const l = state.layers[i];
if (l.visible && pos.x >= l.x && pos.x <= l.x + l.width && pos.y >= l.y && pos.y <= l.y + l.height) {
state.activeLayerIndex = i;
state.status.isDragging = true;
state.mouse.dragOffsetX = pos.x - l.x;
state.mouse.dragOffsetY = pos.y - l.y;
updateLayersList();
redrawCanvas();
return;
}
}
state.activeLayerIndex = -1;
updateLayersList();
redrawCanvas();
}
function handleMouseMove(e) {
if (state.status.isPanning) {
state.panX += e.movementX;
state.panY += e.movementY;
redrawCanvas();
return;
}
const pos = getMousePos(e);
if (!state.mouse.isDown) {
updateCursor(pos);
return;
}
if (state.status.isResizingLayer) handleLayerResize(pos, e.shiftKey, e.altKey);
else if (state.status.isResizingCrop) handleCropResize(pos, e.clientX, e.clientY);
else if (state.status.isMovingCrop) handleCropMove(pos);
else if (state.status.isDragging) handleLayerDrag(pos);
else if (state.status.isCropping) handleCropDraw(pos, e.clientX, e.clientY);
}
function handleMouseUp() {
if (state.status.isCropping || state.status.isResizingCrop) {
state.cropRect = getNormalizedRect(state.cropRect);
if (state.cropRect.w > 5 && state.cropRect.h > 5) {
document.getElementById('crop-options').style.display = 'flex';
} else {
state.cropRect = { x: 0, y: 0, w: 0, h: 0 };
document.getElementById('crop-options').style.display = 'none';
}
}
state.status.isDragging = false;
state.status.isCropping = false;
state.status.isPanning = false;
state.status.isResizingLayer = false;
state.status.isMovingCrop = false;
state.status.isResizingCrop = false;
state.mouse.isDown = false;
DOM.cropInfo.style.display = 'none';
DOM.canvas.style.cursor = 'default';
updateExportPreview();
redrawCanvas();
}
function handleCropDraw(pos, cx, cy) {
const currentX = clamp(pos.x, 0, state.logicalWidth);
const currentY = clamp(pos.y, 0, state.logicalHeight);
const startX = clamp(state.mouse.startX, 0, state.logicalWidth);
const startY = clamp(state.mouse.startY, 0, state.logicalHeight);
state.cropRect.x = startX;
state.cropRect.y = startY;
state.cropRect.w = currentX - startX;
state.cropRect.h = currentY - startY;
updateCropInfoUI(state.cropRect, cx, cy);
redrawCanvas();
}
function handleCropResize(pos, cx, cy) {
const mouseX = clamp(pos.x, 0, state.logicalWidth);
const mouseY = clamp(pos.y, 0, state.logicalHeight);
const dx = mouseX - state.mouse.startX;
const dy = mouseY - state.mouse.startY;
let { x, y, w, h } = state.mouse.originalLayerState;
switch (state.mouse.activeHandle) {
case 'topLeft': w -= dx; h -= dy; x += dx; y += dy; break;
case 'topMiddle': h -= dy; y += dy; break;
case 'topRight': w += dx; h -= dy; y += dy; break;
case 'middleLeft': w -= dx; x += dx; break;
case 'middleRight': w += dx; break;
case 'bottomLeft': w -= dx; h += dy; x += dx; break;
case 'bottomMiddle': h += dy; break;
case 'bottomRight': w += dx; h += dy; break;
}
state.cropRect = { x, y, w, h };
updateCropInfoUI(state.cropRect, cx, cy);
redrawCanvas();
}
function updateCropInfoUI(rect, cx, cy) {
const norm = getNormalizedRect(rect);
DOM.cropInfo.style.display = 'block';
DOM.cropInfo.style.left = (cx + 15) + 'px';
DOM.cropInfo.style.top = (cy + 15) + 'px';
DOM.cropInfo.textContent = `${Math.round(norm.w)} x ${Math.round(norm.h)} px`;
}
function handleCropMove(pos) {
state.cropRect.x = pos.x - state.mouse.dragOffsetX;
state.cropRect.y = pos.y - state.mouse.dragOffsetY;
redrawCanvas();
}
function handleLayerDrag(pos) {
const layer = state.layers[state.activeLayerIndex];
layer.x = pos.x - state.mouse.dragOffsetX;
layer.y = pos.y - state.mouse.dragOffsetY;
redrawCanvas();
}
function handleLayerResize(pos, shiftKey, altKey) {
const layer = state.layers[state.activeLayerIndex];
const dx = pos.x - state.mouse.startX;
const dy = pos.y - state.mouse.startY;
let { x, y, width, height } = state.mouse.originalLayerState;
const aspect = width / height;
let newW = width, newH = height, newX = x, newY = y;
if (state.mouse.activeHandle.includes('Right')) newW = width + dx;
if (state.mouse.activeHandle.includes('Left')) { newW = width - dx; newX = x + dx; }
if (state.mouse.activeHandle.includes('bottom')) newH = height + dy;
if (state.mouse.activeHandle.includes('top')) { newH = height - dy; newY = y + dy; }
if (shiftKey) {
if (newW / newH !== aspect) {
newH = newW / aspect;
if (state.mouse.activeHandle.includes('top')) newY = y + (height - newH);
}
}
if (layer.type === 'text') {
const scale = newW / width;
layer.fontSize = Math.max(5, state.mouse.originalLayerState.fontSize * scale);
DOM.ctx.font = `${layer.fontSize}px ${layer.font}`;
const m = DOM.ctx.measureText(layer.content);
layer.width = m.width;
layer.height = layer.fontSize * 1.2;
layer.x = newX;
layer.y = newY;
} else {
if (newW > 5 && newH > 5) {
layer.x = newX; layer.y = newY;
layer.width = newW; layer.height = newH;
}
}
redrawCanvas();
}
function updateCursor(pos) {
DOM.canvas.style.cursor = 'default';
}
DOM.widthInput.addEventListener('input', () => {
if (DOM.keepRatio.checked) {
const val = parseFloat(DOM.widthInput.value);
if (!isNaN(val)) DOM.heightInput.value = Math.round(val / state.currentAspectRatio);
}
});
DOM.heightInput.addEventListener('input', () => {
if (DOM.keepRatio.checked) {
const val = parseFloat(DOM.heightInput.value);
if (!isNaN(val)) DOM.widthInput.value = Math.round(val * state.currentAspectRatio);
}
});
DOM.container.addEventListener('click', (e) => {
if (e.target.id === 'resize-btn') {
const w = Math.round(parseFloat(DOM.widthInput.value));
const h = Math.round(parseFloat(DOM.heightInput.value));
if (!w || !h) return alert("Invalid size");
const flattened = createFlattenedCanvas();
const tempCanvas = document.createElement('canvas');
tempCanvas.width = w;
tempCanvas.height = h;
const tCtx = tempCanvas.getContext('2d');
tCtx.drawImage(flattened, 0, 0, w, h);
state.logicalWidth = w;
state.logicalHeight = h;
state.currentAspectRatio = w / h;
const newImg = new Image();
newImg.onload = () => {
state.layers = [{
type: 'image', name: 'Resized Image', content: newImg,
x: 0, y: 0, width: w, height: h, visible: true, opacity: 1, blendMode: 'source-over',
adjustments: {...CONSTANTS.DEFAULTS_ADJ}
}];
state.activeLayerIndex = 0;
fitToScreen();
updateLayersList();
updateExportPreview();
};
newImg.src = tempCanvas.toDataURL();
}
});
document.getElementById('apply-crop-btn').addEventListener('click', () => {
const norm = getNormalizedRect(state.cropRect);
if (norm.w < 1 || norm.h < 1) return;
const flattened = createFlattenedCanvas();
const tempCanvas = document.createElement('canvas');
tempCanvas.width = norm.w;
tempCanvas.height = norm.h;
tempCanvas.getContext('2d').drawImage(flattened, norm.x, norm.y, norm.w, norm.h, 0, 0, norm.w, norm.h);
state.logicalWidth = norm.w;
state.logicalHeight = norm.h;
DOM.widthInput.value = norm.w;
DOM.heightInput.value = norm.h;
const newImg = new Image();
newImg.onload = () => {
state.layers = [{
type: 'image', name: 'Cropped Image', content: newImg,
x: 0, y: 0, width: norm.w, height: norm.h, visible: true, opacity: 1, blendMode: 'source-over',
adjustments: {...CONSTANTS.DEFAULTS_ADJ}
}];
state.activeLayerIndex = 0;
state.cropRect = {x:0,y:0,w:0,h:0};
switchTool(CONSTANTS.TOOLS.MOVE);
fitToScreen();
updateLayersList();
updateExportPreview();
};
newImg.src = tempCanvas.toDataURL();
});
const addLayer = (layerObj) => {
state.layers.push(layerObj);
state.activeLayerIndex = state.layers.length - 1;
updateLayersList();
redrawCanvas();
updateExportPreview();
};
const updateLayersList = () => {
DOM.layersList.innerHTML = '';
[...state.layers].reverse().forEach((layer, idx) => {
const realIdx = state.layers.length - 1 - idx;
const li = document.createElement('li');
li.innerHTML = `<span class="visibility-toggle">${layer.visible ? 'üëÅÔ∏è' : '‚ö™'}</span> ${layer.name}`;
if (realIdx === state.activeLayerIndex) li.classList.add('active');
li.querySelector('.visibility-toggle').onclick = (e) => {
e.stopPropagation();
layer.visible = !layer.visible;
updateLayersList();
redrawCanvas();
};
li.onclick = () => {
state.activeLayerIndex = realIdx;
updateLayersList();
updateAdjustmentPanel();
redrawCanvas();
};
DOM.layersList.appendChild(li);
});
updateAdjustmentPanel();
};
const updateAdjustmentPanel = () => {
const layer = state.layers[state.activeLayerIndex];
const isImg = layer && layer.type === 'image';
DOM.adjPanel.style.display = isImg ? 'block' : 'none';
DOM.filtersPanel.style.display = isImg ? 'block' : 'none';
if (layer) {
document.getElementById('layer-opacity').value = layer.opacity;
document.getElementById('layer-opacity-value').innerText = Math.round(layer.opacity*100)+'%';
document.getElementById('layer-blend-mode').value = layer.blendMode;
}
if (isImg && layer.adjustments) {
document.getElementById('adj-brightness').value = layer.adjustments.brightness || 0;
document.getElementById('brightness-value').innerText = layer.adjustments.brightness || 0;
document.getElementById('adj-contrast').value = layer.adjustments.contrast || 0;
document.getElementById('adj-saturation').value = layer.adjustments.saturation || 0;
document.getElementById('saturation-value').innerText = layer.adjustments.saturation || 0;
document.getElementById('filter-blur').value = layer.adjustments.blur || 0;
}
};
function init() {
const bg = document.createElement('canvas');
bg.width = 800; bg.height = 600;
bg.getContext('2d').fillStyle = 'white';
bg.getContext('2d').fillRect(0,0,800,600);
addLayer({
type: 'image', name: 'Background', content: bg,
x: 0, y: 0, width: 800, height: 600, visible: true, opacity: 1, blendMode: 'source-over',
adjustments: {...CONSTANTS.DEFAULTS_ADJ}
});
DOM.widthInput.value = 800;
DOM.heightInput.value = 600;
fitToScreen();
}
const switchTool = (t) => {
state.currentTool = t;
document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
document.getElementById(`tool-${t}`).classList.add('active');
document.getElementById('text-options').style.display = t === 'text' ? 'flex' : 'none';
document.getElementById('crop-options').style.display = (t === 'crop' && state.cropRect.w) ? 'flex' : 'none';
state.cropRect = {x:0, y:0, w:0, h:0};
redrawCanvas();
};
const fitToScreen = () => {
const rect = DOM.container.getBoundingClientRect();
const scale = Math.min((rect.width - 40) / state.logicalWidth, (rect.height - 40) / state.logicalHeight);
state.zoom = scale;
state.panX = 0;
state.panY = 0;
DOM.zoomDisplay.textContent = Math.round(scale * 100) + '%';
redrawCanvas();
};
const updateExportPreview = () => {
const canvas = createFlattenedCanvas();
const quality = parseFloat(document.getElementById('export-quality').value);
const format = document.getElementById('export-format').value;
DOM.exportPreview.src = canvas.toDataURL(format, quality);
canvas.toBlob(blob => {
DOM.fileSizeInfo.innerText = blob ? `~ ${(blob.size/1024).toFixed(1)} KB` : '';
}, format, quality);
};
window.addEventListener('resize', () => { updateCanvasSize(); fitToScreen(); });
DOM.canvas.addEventListener('mousedown', handleMouseDown);
DOM.canvas.addEventListener('mousemove', handleMouseMove);
window.addEventListener('mouseup', handleMouseUp);
DOM.canvas.addEventListener('wheel', (e) => {
e.preventDefault();
if (e.ctrlKey) {
const delta = e.deltaY > 0 ? 0.9 : 1.1;
state.zoom *= delta;
DOM.zoomDisplay.textContent = Math.round(state.zoom * 100) + '%';
} else {
state.panX -= e.deltaX;
state.panY -= e.deltaY;
}
redrawCanvas();
}, { passive: false });
document.getElementById('open-btn').addEventListener('click', () => DOM.fileInput.click());
DOM.fileInput.addEventListener('change', (e) => {
const file = e.target.files[0];
if(!file) return;
const reader = new FileReader();
reader.onload = (ev) => {
const img = new Image();
img.onload = () => {
state.layers = [];
state.logicalWidth = img.width;
state.logicalHeight = img.height;
state.currentAspectRatio = img.width / img.height;
DOM.widthInput.value = img.width;
DOM.heightInput.value = img.height;
addLayer({
type: 'image', name: file.name, content: img,
x: 0, y: 0, width: img.width, height: img.height, visible: true, opacity: 1, blendMode: 'source-over',
adjustments: {...CONSTANTS.DEFAULTS_ADJ}
});
fitToScreen();
};
img.src = ev.target.result;
};
reader.readAsDataURL(file);
});
document.getElementById('tool-move').onclick = () => switchTool(CONSTANTS.TOOLS.MOVE);
document.getElementById('tool-crop').onclick = () => switchTool(CONSTANTS.TOOLS.CROP);
document.getElementById('tool-text').onclick = () => switchTool(CONSTANTS.TOOLS.TEXT);
document.getElementById('zoom-in-btn').onclick = () => { state.zoom *= 1.2; redrawCanvas(); };
document.getElementById('zoom-out-btn').onclick = () => { state.zoom /= 1.2; redrawCanvas(); };
document.getElementById('fit-to-screen-btn').onclick = fitToScreen;
['brightness', 'contrast', 'saturation'].forEach(adj => {
document.getElementById(`adj-${adj}`).addEventListener('input', (e) => {
const l = state.layers[state.activeLayerIndex];
if(l && l.adjustments) {
l.adjustments[adj] = parseFloat(e.target.value);
document.getElementById(`${adj}-value`).innerText = e.target.value;
redrawCanvas();
}
});
document.getElementById(`adj-${adj}`).addEventListener('change', updateExportPreview);
});
document.getElementById('filter-blur').addEventListener('input', (e) => {
const l = state.layers[state.activeLayerIndex];
if(l && l.adjustments) {
l.adjustments.blur = parseFloat(e.target.value);
document.getElementById('blur-value').innerText = e.target.value;
redrawCanvas();
}
});
document.getElementById('export-btn').onclick = () => {
const link = document.createElement('a');
link.download = 'edited-image.png';
link.href = DOM.exportPreview.src;
link.click();
};
init();
});
</script>
</body>
</html>