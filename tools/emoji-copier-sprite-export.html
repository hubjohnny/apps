<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Emoji Sprite Generator</title>
<style>
:root {
--emoji-font: "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", sans-serif;
}
body {
font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
background-color: #121212;
color: #e0e0e0;
padding: 10px;
margin: 0;
}
.container {
max-width: 900px;
margin: 0 auto;
background-color: #252525;
padding: 15px;
border-radius: 8px;
box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}
p {
text-align: center;
color: #eeeeee;
margin-top: 0;
margin-bottom: 20px;
font-size: 0.95rem;
}
.controls {
display: flex;
gap: 10px;
margin-bottom: 20px;
flex-wrap: wrap;
}
#search {
flex-grow: 1;
min-width: 200px;
padding: 10px;
border: 1px solid #444;
background-color: #1a1a1a;
color: #e0e0e0;
border-radius: 6px;
font-size: 16px;
}
select {
padding: 10px;
border: 1px solid #444;
background-color: #1a1a1a;
color: #e0e0e0;
border-radius: 6px;
font-size: 16px;
cursor: pointer;
}
#size-select {
width: 120px;
}
#search:focus, select:focus {
outline: none;
border-color: #007bff;
}
#emoji-grid {
display: grid;
grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
gap: 10px;
justify-content: center;
max-height: 60vh;
overflow-y: auto;
padding: 5px;
}
.emoji {
font-size: 32px;
cursor: pointer;
text-align: center;
padding: 5px;
border-radius: 5px;
transition: background-color 0.2s, transform 0.2s;
user-select: none;
font-family: var(--emoji-font);
}
.emoji:hover {
background-color: rgba(255, 255, 255, 0.1);
transform: scale(1.1);
}
.toast {
position: fixed;
bottom: 30px;
left: 50%;
transform: translateX(-50%) translateY(20px);
background-color: #333;
color: white;
padding: 10px 20px;
border-radius: 25px;
font-size: 14px;
opacity: 0;
pointer-events: none;
z-index: 1000;
box-shadow: 0 4px 12px rgba(0,0,0,0.5);
border: 1px solid #444;
transition: opacity 0.3s ease, transform 0.3s ease;
}
.toast.visible {
opacity: 1;
transform: translateX(-50%) translateY(0);
}
</style>
</head>
<body>
<div class="container">
<p>Left-click: Copy emoji to clipboard ðŸ“‹ <br> <strong>Right-click: Download cropped sprite ðŸ’¾</strong></p>
<div class="controls">
<input type="text" id="search" placeholder="Search emojis...">
<select id="size-select" title="Select sprite size">
<option value="16">16 px</option>
<option value="32">32 px</option>
<option value="64" selected>64 px</option>
<option value="128">128 px</option>
<option value="256">256 px</option>
</select>
</div>
<div id="emoji-grid"></div>
</div>
<div class="toast" id="toast">Copied!</div>
<script>
document.addEventListener('DOMContentLoaded', () => {
const grid = document.getElementById('emoji-grid');
const searchInput = document.getElementById('search');
const sizeSelect = document.getElementById('size-select');
const toast = document.getElementById('toast');
let emojis = [];
const SYSTEM_FONT_STACK = '"Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", sans-serif';
let toastTimeout;
fetch('https://cdn.jsdelivr.net/npm/@emoji-mart/data')
.then(response => response.json())
.then(data => {
emojis = Object.values(data.emojis).map(e => ({
id: e.id,
native: e.skins[0].native,
keywords: e.keywords
}));
displayEmojis(emojis);
})
.catch(error => {
console.error('Error fetching emoji data:', error);
grid.innerHTML = '<p style="color: #ff8a80;">Could not load emojis. Check connection.</p>';
});
function displayEmojis(emojiList) {
grid.innerHTML = '';
const fragment = document.createDocumentFragment();
emojiList.forEach(emoji => {
const emojiSpan = document.createElement('span');
emojiSpan.className = 'emoji';
emojiSpan.textContent = emoji.native;
emojiSpan.addEventListener('mouseenter', () => {
const size = sizeSelect.value;
emojiSpan.title = `Left-click: Copy text\nRight-click: Download ${size}x${size} sprite`;
});
emojiSpan.addEventListener('click', () => {
navigator.clipboard.writeText(emoji.native).then(() => {
showToast('Emoji copied!');
});
});
emojiSpan.addEventListener('contextmenu', (e) => {
e.preventDefault();
downloadSprite(emoji.native, emoji.id);
});
fragment.appendChild(emojiSpan);
});
grid.appendChild(fragment);
}
searchInput.addEventListener('input', (e) => {
const query = e.target.value.toLowerCase();
const filteredEmojis = emojis.filter(emoji =>
emoji.id.includes(query) || emoji.keywords.some(kw => kw.includes(query))
);
displayEmojis(filteredEmojis);
});
function downloadSprite(emojiChar, filename) {
const targetSize = parseInt(sizeSelect.value);
const baseSize = Math.max(targetSize * 2, 128);
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');
canvas.width = baseSize;
canvas.height = baseSize;
const fontSize = Math.floor(baseSize * 0.85);
ctx.font = `${fontSize}px ${SYSTEM_FONT_STACK}`;
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText(emojiChar, baseSize / 2, baseSize / 2 + (fontSize * 0.1));
const trimmedData = trimCanvas(canvas);
if (!trimmedData) {
showToast('Could not generate image');
return;
}
const finalCanvas = resizeToMax(trimmedData, targetSize);
const dataUrl = finalCanvas.toDataURL('image/png');
const link = document.createElement('a');
link.download = `${filename}_${targetSize}px.png`;
link.href = dataUrl;
document.body.appendChild(link);
link.click();
document.body.removeChild(link);
showToast(`Saved ${targetSize}px sprite! ðŸ’¾`);
}
function trimCanvas(c) {
const ctx = c.getContext('2d');
const width = c.width;
const height = c.height;
const imageData = ctx.getImageData(0, 0, width, height);
const data = imageData.data;
let top = null, bottom = null, left = null, right = null;
for (let y = 0; y < height; y++) {
for (let x = 0; x < width; x++) {
if (data[(y * width + x) * 4 + 3] > 0) {
if (top === null) top = y;
if (left === null || x < left) left = x;
if (right === null || x > right) right = x;
if (bottom === null || y > bottom) bottom = y;
}
}
}
if (top === null) return null;
const padding = 1;
top = Math.max(0, top - padding);
left = Math.max(0, left - padding);
bottom = Math.min(height, bottom + padding);
right = Math.min(width, right + padding);
const trimmedWidth = right - left + 1;
const trimmedHeight = bottom - top + 1;
const trimmedCanvas = document.createElement('canvas');
trimmedCanvas.width = trimmedWidth;
trimmedCanvas.height = trimmedHeight;
trimmedCanvas.getContext('2d').drawImage(c, left, top, trimmedWidth, trimmedHeight, 0, 0, trimmedWidth, trimmedHeight);
return trimmedCanvas;
}
function resizeToMax(canvas, maxPixels) {
let width = canvas.width;
let height = canvas.height;
if (width > height) {
height *= maxPixels / width;
width = maxPixels;
} else {
width *= maxPixels / height;
height = maxPixels;
}
const newCanvas = document.createElement('canvas');
newCanvas.width = width;
newCanvas.height = height;
const ctx = newCanvas.getContext('2d');
ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = 'high';
ctx.drawImage(canvas, 0, 0, width, height);
return newCanvas;
}
function showToast(message) {
toast.textContent = message;
toast.classList.add('visible');
if (toastTimeout) clearTimeout(toastTimeout);
toastTimeout = setTimeout(() => {
toast.classList.remove('visible');
}, 2000);
}
});
</script>
</body>
</html>