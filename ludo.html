<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ludo</title>
<style>
:root {
--board-size: 94vmin;
--green: #009e00;
--blue: #0072b5;
--red: #e4001b;
--yellow: #ffed00;
--white: #ffffff;
--dark-bg: #303030;
--light-text: #f0f0f0;
--highlight-color: #00ffff;
}
body {
display: flex;
justify-content: center;
align-items: center;
flex-direction: column;
gap: 20px;
height: 100vh;
margin: 0;
background-color: var(--dark-bg);
font-family: sans-serif;
color: var(--light-text);
padding-top: 6px;
padding-bottom: 6px;
box-sizing: border-box;
}
#game-container {
display: flex;
align-items: center;
gap: 40px;
position: relative;
}
svg {
width: var(--board-size);
height: var(--board-size);
box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
border-radius: 12px;
box-shadow: 2px 2px 4px 2px rgba(0, 0, 0, 0.75);
}
#controls {
display: flex;
flex-direction: column;
align-items: center;
gap: 15px;
min-width: 300px;
background-color: #000000;
padding: 20px;
border-radius: 12px;
}
#dice {
width: 80px;
height: 80px;
border: 2px solid var(--light-text);
border-radius: 10px;
display: flex;
justify-content: center;
align-items: center;
font-size: 48px;
font-weight: bold;
transition: border-color 0.3s;
}
button {
width: 180px;
padding: 12px 24px;
font-size: 18px;
cursor: pointer;
border-radius: 8px;
border: none;
background-color: var(--blue);
color: var(--white);
transition: background-color 0.3s;
}
button:disabled {
background-color: #555;
cursor: not-allowed;
}
button:not(:disabled):hover {
background-color: #008fdd;
}
#autopilot-button {
background-color: #5a5a5a;
width: 180px;
}
#autopilot-button.active {
background-color: var(--green);
color: var(--white);
}
#message-box {
min-height: 20px;
text-align: center;
font-size: 1.1em;
font-weight: bold;
}
.shape {
stroke: #000000;
stroke-width: 0.5;
}
.pawn {
stroke: #000000;
stroke-width: 0.5;
cursor: pointer;
transition: transform 0.4s ease-in-out, r 0.2s ease-in-out;
}
.pawn.green {
fill: #009e00;
}
.pawn.blue {
fill: #0072b5;
}
.pawn.red {
fill: #e4001b;
}
.pawn.yellow {
fill: #ffed00;
}
@keyframes glow {
0% {
stroke: var(--highlight-color);
stroke-width: 1.5;
}
50% {
stroke: var(--white);
stroke-width: 2.5;
}
100% {
stroke: var(--highlight-color);
stroke-width: 1.5;
}
}
.pawn.movable {
animation: glow 1.2s infinite;
}
@keyframes explode {
0% {
transform: scale(1);
opacity: 1;
}
100% {
transform: scale(3.5) rotate(75deg);
opacity: 0;
}
}
.pawn.finished-animation {
animation: explode 0.5s ease-out forwards;
}
#winner-display {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
display: none;
justify-content: center;
align-items: center;
font-size: 10vmin;
font-weight: bold;
color: white;
text-shadow: 0 0 15px black, 0 0 10px black;
z-index: 1000;
pointer-events: none;
opacity: 0;
}
@keyframes fadeInOut {
0% {
opacity: 0;
transform: scale(0.8);
}
20% {
opacity: 1;
transform: scale(1);
}
80% {
opacity: 1;
transform: scale(1);
}
100% {
opacity: 0;
transform: scale(0.8);
}
}
.show-message {
display: flex !important;
animation: fadeInOut 2.5s ease-in-out forwards;
}
</style>
</head>
<body>
<div id="game-container">
<div id="winner-display"></div>
<div id="controls">
<div id="dice">?</div>
<button id="roll-button">Roll the dice</button>
<button id="autopilot-button">Autopilot</button>
<div id="message-box">Welcome! Green player starts.</div>
</div>
<svg viewBox="0 0 150 150" xmlns="http://www.w3.org/2000/svg">
<defs>
<style>
.green-bg {
fill: #009e00;
}
.blue-bg {
fill: #0072b5;
}
.red-bg {
fill: #e4001b;
}
.yellow-bg {
fill: #ffed00;
}
.white-bg {
fill: #ffffff;
}
</style>
</defs>
<g id="bases">
<rect class="white-bg shape" x="0" y="0" width="150" height="150" />
<rect class="green-bg" x="0" y="0" width="60" height="60" />
<rect class="blue-bg" x="90" y="0" width="60" height="60" />
<rect class="yellow-bg" x="0" y="90" width="60" height="60" />
<rect class="red-bg" x="90" y="90" width="60" height="60" />
</g>
<g id="yards">
<rect class="white-bg shape" x="10" y="10" width="40" height="40" />
<rect class="white-bg shape" x="100" y="10" width="40" height="40" />
<rect class="white-bg shape" x="10" y="100" width="40" height="40" />
<rect class="white-bg shape" x="100" y="100" width="40" height="40" />
</g>
<g id="game-path">
<rect class="white-bg shape" x="60" y="0" width="10" height="10" />
<rect class="white-bg shape" x="60" y="10" width="10" height="10" />
<rect class="white-bg shape" x="60" y="20" width="10" height="10" />
<rect class="white-bg shape" x="60" y="30" width="10" height="10" />
<rect class="white-bg shape" x="60" y="40" width="10" height="10" />
<rect class="white-bg shape" x="60" y="50" width="10" height="10" />
<rect class="white-bg shape" x="80" y="0" width="10" height="10" />
<rect class="blue-bg shape" x="80" y="10" width="10" height="10" />
<rect class="white-bg shape" x="80" y="20" width="10" height="10" />
<rect class="white-bg shape" x="80" y="30" width="10" height="10" />
<rect class="white-bg shape" x="80" y="40" width="10" height="10" />
<rect class="white-bg shape" x="80" y="50" width="10" height="10" />
<rect class="white-bg shape" x="90" y="60" width="10" height="10" />
<rect class="white-bg shape" x="100" y="60" width="10" height="10" />
<rect class="white-bg shape" x="110" y="60" width="10" height="10" />
<rect class="white-bg shape" x="120" y="60" width="10" height="10" />
<rect class="white-bg shape" x="130" y="60" width="10" height="10" />
<rect class="white-bg shape" x="140" y="60" width="10" height="10" />
<rect class="white-bg shape" x="90" y="80" width="10" height="10" />
<rect class="white-bg shape" x="100" y="80" width="10" height="10" />
<rect class="white-bg shape" x="110" y="80" width="10" height="10" />
<rect class="white-bg shape" x="120" y="80" width="10" height="10" />
<rect class="red-bg shape" x="130" y="80" width="10" height="10" />
<rect class="white-bg shape" x="140" y="80" width="10" height="10" />
<rect class="white-bg shape" x="60" y="90" width="10" height="10" />
<rect class="white-bg shape" x="60" y="100" width="10" height="10" />
<rect class="white-bg shape" x="60" y="110" width="10" height="10" />
<rect class="white-bg shape" x="60" y="120" width="10" height="10" />
<rect class="yellow-bg shape" x="60" y="130" width="10" height="10" />
<rect class="white-bg shape" x="60" y="140" width="10" height="10" />
<rect class="white-bg shape" x="80" y="90" width="10" height="10" />
<rect class="white-bg shape" x="80" y="100" width="10" height="10" />
<rect class="white-bg shape" x="80" y="110" width="10" height="10" />
<rect class="white-bg shape" x="80" y="120" width="10" height="10" />
<rect class="white-bg shape" x="80" y="130" width="10" height="10" />
<rect class="white-bg shape" x="80" y="140" width="10" height="10" />
<rect class="white-bg shape" x="0" y="60" width="10" height="10" />
<rect class="green-bg shape" x="10" y="60" width="10" height="10" />
<rect class="white-bg shape" x="20" y="60" width="10" height="10" />
<rect class="white-bg shape" x="30" y="60" width="10" height="10" />
<rect class="white-bg shape" x="40" y="60" width="10" height="10" />
<rect class="white-bg shape" x="50" y="60" width="10" height="10" />
<rect class="white-bg shape" x="0" y="80" width="10" height="10" />
<rect class="white-bg shape" x="10" y="80" width="10" height="10" />
<rect class="white-bg shape" x="20" y="80" width="10" height="10" />
<rect class="white-bg shape" x="30" y="80" width="10" height="10" />
<rect class="white-bg shape" x="40" y="80" width="10" height="10" />
<rect class="white-bg shape" x="50" y="80" width="10" height="10" />
</g>
<g id="home-stretch">
<rect class="blue-bg shape" x="70" y="10" width="10" height="10" />
<rect class="blue-bg shape" x="70" y="20" width="10" height="10" />
<rect class="blue-bg shape" x="70" y="30" width="10" height="10" />
<rect class="blue-bg shape" x="70" y="40" width="10" height="10" />
<rect class="blue-bg shape" x="70" y="50" width="10" height="10" />
<rect class="red-bg shape" x="90" y="70" width="10" height="10" />
<rect class="red-bg shape" x="100" y="70" width="10" height="10" />
<rect class="red-bg shape" x="110" y="70" width="10" height="10" />
<rect class="red-bg shape" x="120" y="70" width="10" height="10" />
<rect class="red-bg shape" x="130" y="70" width="10" height="10" />
<rect class="yellow-bg shape" x="70" y="90" width="10" height="10" />
<rect class="yellow-bg shape" x="70" y="100" width="10" height="10" />
<rect class="yellow-bg shape" x="70" y="110" width="10" height="10" />
<rect class="yellow-bg shape" x="70" y="120" width="10" height="10" />
<rect class="yellow-bg shape" x="70" y="130" width="10" height="10" />
<rect class="green-bg shape" x="10" y="70" width="10" height="10" />
<rect class="green-bg shape" x="20" y="70" width="10" height="10" />
<rect class="green-bg shape" x="30" y="70" width="10" height="10" />
<rect class="green-bg shape" x="40" y="70" width="10" height="10" />
<rect class="green-bg shape" x="50" y="70" width="10" height="10" />
</g>
<g id="finish-area">
<polygon class="blue-bg shape" points="60,60 90,60 75,75" />
<polygon class="red-bg shape" points="90,60 90,90 75,75" />
<polygon class="yellow-bg shape" points="90,90 60,90 75,75" />
<polygon class="green-bg shape" points="60,90 60,60 75,75" />
</g>
<g id="pawns-container">
<circle id="green-1" class="pawn green" cx="0" cy="0" r="4" />
<circle id="green-2" class="pawn green" cx="0" cy="0" r="4" />
<circle id="green-3" class="pawn green" cx="0" cy="0" r="4" />
<circle id="green-4" class="pawn green" cx="0" cy="0" r="4" />
<circle id="blue-1" class="pawn blue" cx="0" cy="0" r="4" />
<circle id="blue-2" class="pawn blue" cx="0" cy="0" r="4" />
<circle id="blue-3" class="pawn blue" cx="0" cy="0" r="4" />
<circle id="blue-4" class="pawn blue" cx="0" cy="0" r="4" />
<circle id="yellow-1" class="pawn yellow" cx="0" cy="0" r="4" />
<circle id="yellow-2" class="pawn yellow" cx="0" cy="0" r="4" />
<circle id="yellow-3" class="pawn yellow" cx="0" cy="0" r="4" />
<circle id="yellow-4" class="pawn yellow" cx="0" cy="0" r="4" />
<circle id="red-1" class="pawn red" cx="0" cy="0" r="4" />
<circle id="red-2" class="pawn red" cx="0" cy="0" r="4" />
<circle id="red-3" class="pawn red" cx="0" cy="0" r="4" />
<circle id="red-4" class="pawn red" cx="0" cy="0" r="4" />
</g>
</svg>
</div>
<script>
document.addEventListener('DOMContentLoaded', () => {
class LudoGame {
AI_THINK_TIME = 1500;
AI_MOVE_DELAY = 1000;
NO_MOVES_DELAY = 1500;
NEXT_TURN_DELAY = 500;
TEMP_MESSAGE_DURATION = 2500;
COLORS = ['green', 'blue', 'red', 'yellow'];
START_POSITIONS = { green: 1, blue: 14, red: 27, yellow: 40 };
HOME_STRETCH_LENGTH = 6;
MAIN_PATH_LENGTH = 52;
STEPS_TO_HOME_STRETCH = 51;
PATH_COORDS = [null, { x: 15, y: 65 }, { x: 25, y: 65 }, { x: 35, y: 65 }, { x: 45, y: 65 }, { x: 55, y: 65 }, { x: 65, y: 55 }, { x: 65, y: 45 }, { x: 65, y: 35 }, { x: 65, y: 25 }, { x: 65, y: 15 }, { x: 65, y: 5 }, { x: 75, y: 5 }, { x: 85, y: 5 }, { x: 85, y: 15 }, { x: 85, y: 25 }, { x: 85, y: 35 }, { x: 85, y: 45 }, { x: 85, y: 55 }, { x: 95, y: 65 }, { x: 105, y: 65 }, { x: 115, y: 65 }, { x: 125, y: 65 }, { x: 135, y: 65 }, { x: 145, y: 65 }, { x: 145, y: 75 }, { x: 145, y: 85 }, { x: 135, y: 85 }, { x: 125, y: 85 }, { x: 115, y: 85 }, { x: 105, y: 85 }, { x: 95, y: 85 }, { x: 85, y: 95 }, { x: 85, y: 105 }, { x: 85, y: 115 }, { x: 85, y: 125 }, { x: 85, y: 135 }, { x: 85, y: 145 }, { x: 75, y: 145 }, { x: 65, y: 145 }, { x: 65, y: 135 }, { x: 65, y: 125 }, { x: 65, y: 115 }, { x: 65, y: 105 }, { x: 65, y: 95 }, { x: 55, y: 85 }, { x: 45, y: 85 }, { x: 35, y: 85 }, { x: 25, y: 85 }, { x: 15, y: 85 }, { x: 5, y: 85 }, { x: 5, y: 75 }, { x: 5, y: 65 }];
HOME_STRETCH_COORDS = { green: [null, { x: 15, y: 75 }, { x: 25, y: 75 }, { x: 35, y: 75 }, { x: 45, y: 75 }, { x: 55, y: 75 }, { x: 65, y: 75 }], blue: [null, { x: 75, y: 15 }, { x: 75, y: 25 }, { x: 75, y: 35 }, { x: 75, y: 45 }, { x: 75, y: 55 }, { x: 75, y: 65 }], red: [null, { x: 135, y: 75 }, { x: 125, y: 75 }, { x: 115, y: 75 }, { x: 105, y: 75 }, { x: 95, y: 75 }, { x: 85, y: 75 }], yellow: [null, { x: 75, y: 135 }, { x: 75, y: 125 }, { x: 75, y: 115 }, { x: 75, y: 105 }, { x: 75, y: 95 }, { x: 75, y: 85 }] };
HOME_YARD_COORDS = { green: [{ x: 20, y: 20 }, { x: 40, y: 20 }, { x: 20, y: 40 }, { x: 40, y: 40 }], blue: [{ x: 110, y: 20 }, { x: 130, y: 20 }, { x: 110, y: 40 }, { x: 130, y: 40 }], yellow: [{ x: 20, y: 110 }, { x: 40, y: 110 }, { x: 20, y: 130 }, { x: 40, y: 130 }], red: [{ x: 110, y: 110 }, { x: 130, y: 110 }, { x: 110, y: 130 }, { x: 130, y: 130 }] };
constructor() {
this.rollButton = document.getElementById('roll-button');
this.diceDisplay = document.getElementById('dice');
this.messageBox = document.getElementById('message-box');
this.pawnsContainer = document.getElementById('pawns-container');
this.winnerDisplay = document.getElementById('winner-display');
this.autopilotButton = document.getElementById('autopilot-button');
this.state = { currentPlayerIndex: 0, diceValue: 0, pawns: {}, isRolling: false, isAITurn: false, isGameOver: false, isAutopilotOn: false };
this.init();
}
init() {
this.COLORS.forEach((color) => {
for (let i = 1; i <= 4; i++) {
const pawnId = `${color}-${i}`;
this.state.pawns[pawnId] = { id: pawnId, color: color, position: 'home', pathIndex: 0 };
}
});
this.updateAllPawnPositions();
this.adjustForStackedPawns();
this.updateTurnDisplay();
this.setupEventListeners();
}
setupEventListeners() {
this.rollButton.addEventListener('click', () => this.rollDice());
this.autopilotButton.addEventListener('click', () => this.toggleAutopilot());
this.pawnsContainer.addEventListener('click', (e) => {
if (this.state.isGameOver || this.state.isAITurn) return;
if (e.target.classList.contains('movable')) {
this.movePawn(e.target.id);
}
});
}
toggleAutopilot() {
this.state.isAutopilotOn = !this.state.isAutopilotOn;
this.autopilotButton.classList.toggle('active', this.state.isAutopilotOn);
this.autopilotButton.textContent = this.state.isAutopilotOn ? 'Autopilot ON' : 'Autopilot';
if (this.state.isAutopilotOn && this.COLORS[this.state.currentPlayerIndex] === 'green' && !this.state.isRolling) {
this.state.isAITurn = true;
this.rollButton.disabled = true;
this.messageBox.textContent = 'Green (AI) is thinking...';
setTimeout(() => this.playAITurn(), this.AI_THINK_TIME / 2);
}
}
updateAllPawnPositions() {
for (const pawnId in this.state.pawns) {
this.updatePawnPosition(pawnId);
}
}
updatePawnPosition(pawnId) {
const pawn = this.state.pawns[pawnId];
const el = document.getElementById(pawnId);
if (!el) return;
el.style.display = pawn.position === 'finished' ? 'none' : '';
const coords = this.getPawnCoords(pawn);
if (coords) {
el.style.transform = `translate(${coords.x}px, ${coords.y}px)`;
}
}
adjustForStackedPawns() {
Object.values(this.state.pawns).forEach(pawn => {
if (pawn.position !== 'finished' && pawn.position !== 'home') {
const el = document.getElementById(pawn.id);
if (el) {
const coords = this.getPawnCoords(pawn);
el.style.transform = `translate(${coords.x}px, ${coords.y}px)`;
}
}
});
const locations = new Map();
Object.values(this.state.pawns).forEach(pawn => {
if (pawn.position === 'finished' || pawn.position === 'home') return;
let key = pawn.position === 'in-stretch' ?
`${pawn.color}-${pawn.position}-${pawn.pathIndex}` :
`${pawn.position}-${pawn.pathIndex}`;
if (!locations.has(key)) {
locations.set(key, []);
}
locations.get(key).push(pawn.id);
});
for (const pawnIdsOnSquare of locations.values()) {
if (pawnIdsOnSquare.length > 1) {
const angleStep = (2 * Math.PI) / pawnIdsOnSquare.length;
const radius = 2.5;
pawnIdsOnSquare.forEach((pawnId, index) => {
const el = document.getElementById(pawnId);
const pawn = this.state.pawns[pawnId];
if (el) {
const baseCoords = this.getPawnCoords(pawn);
const dx = radius * Math.cos(index * angleStep);
const dy = radius * Math.sin(index * angleStep);
el.style.transform = `translate(${baseCoords.x}px, ${baseCoords.y}px) translate(${dx.toFixed(2)}px, ${dy.toFixed(2)}px)`;
}
});
}
}
}
getPawnCoords(pawn) {
switch (pawn.position) {
case 'home':
return this.HOME_YARD_COORDS[pawn.color][parseInt(pawn.id.split('-')[1]) - 1];
case 'in-play':
return this.PATH_COORDS[pawn.pathIndex];
case 'in-stretch':
return this.HOME_STRETCH_COORDS[pawn.color][pawn.pathIndex];
default:
return null;
}
}
updateTurnDisplay() {
if (this.state.isGameOver) return;
const color = this.COLORS[this.state.currentPlayerIndex];
const playerName = color.charAt(0).toUpperCase() + color.slice(1);
this.messageBox.textContent = `${playerName} is ready.`;
this.diceDisplay.style.borderColor = `var(--${color})`;
}
highlightMovablePawns(pawnIds, shouldHighlight) {
document.querySelectorAll('.pawn').forEach(p => p.classList.remove('movable'));
if (shouldHighlight) {
pawnIds.forEach(id => {
const el = document.getElementById(id);
if (el) {
el.classList.add('movable');
el.parentElement.appendChild(el);
}
});
}
}
showTemporaryMessage(message, color) {
this.winnerDisplay.textContent = message;
this.winnerDisplay.style.color = `var(--${color})`;
this.winnerDisplay.classList.add('show-message');
setTimeout(() => {
this.winnerDisplay.classList.remove('show-message');
}, this.TEMP_MESSAGE_DURATION);
}
switchPlayer() {
if (this.state.isGameOver) return;
if (this.state.diceValue !== 6) {
this.state.currentPlayerIndex = (this.state.currentPlayerIndex + 1) % this.COLORS.length;
}
this.updateTurnDisplay();
const currentPlayerColor = this.COLORS[this.state.currentPlayerIndex];
this.state.isAITurn = currentPlayerColor !== 'green' || this.state.isAutopilotOn;
this.rollButton.disabled = this.state.isAITurn || this.state.isRolling;
if (this.state.isAITurn) {
const playerName = currentPlayerColor.charAt(0).toUpperCase() + currentPlayerColor.slice(1);
this.messageBox.textContent = `${playerName} is thinking...`;
setTimeout(() => this.playAITurn(), this.AI_THINK_TIME);
}
}
rollDice() {
if (this.state.isRolling || this.state.isGameOver) return;
this.state.isRolling = true;
this.rollButton.disabled = true;
let rollCount = 0;
const interval = setInterval(() => {
this.diceDisplay.textContent = Math.floor(Math.random() * 6) + 1;
if (++rollCount > 10) {
clearInterval(interval);
this.state.diceValue = Math.floor(Math.random() * 6) + 1;
this.diceDisplay.textContent = this.state.diceValue;
this.state.isRolling = false;
this.handlePostRoll();
}
}, 100);
}
handlePostRoll() {
const color = this.COLORS[this.state.currentPlayerIndex];
const playerName = color.charAt(0).toUpperCase() + color.slice(1);
this.messageBox.textContent = `${playerName} rolled ${this.state.diceValue}.`;
const movablePawns = this.findMovablePawns(color, this.state.diceValue);
if (movablePawns.length === 0) {
setTimeout(() => {
this.messageBox.textContent += ' No moves possible.';
setTimeout(() => this.switchPlayer(), this.NO_MOVES_DELAY);
}, 1000);
} else if (this.state.isAITurn) {
const chosenPawnId = this.chooseAIPawn(movablePawns, this.state.diceValue, color);
setTimeout(() => this.movePawn(chosenPawnId), this.AI_MOVE_DELAY);
} else {
this.highlightMovablePawns(movablePawns, true);
}
}
calculateNewPosition(pawn, dice) {
if (pawn.position === 'home') {
return { position: 'in-play', pathIndex: this.START_POSITIONS[pawn.color] };
}
if (pawn.position === 'in-stretch') {
const newIndex = pawn.pathIndex + dice;
return { position: newIndex === this.HOME_STRETCH_LENGTH ? 'finished' : 'in-stretch', pathIndex: newIndex };
}
if (pawn.position === 'in-play') {
const currentRelativePos = this.getRelativeBoardPosition(pawn);
const newRelativePos = currentRelativePos + dice;
if (newRelativePos >= this.STEPS_TO_HOME_STRETCH) {
const stretchIndex = newRelativePos - this.STEPS_TO_HOME_STRETCH + 1;
return { position: stretchIndex === this.HOME_STRETCH_LENGTH ? 'finished' : 'in-stretch', pathIndex: stretchIndex };
} else {
let newAbsIndex = (pawn.pathIndex + dice - 1) % this.MAIN_PATH_LENGTH + 1;
return { position: 'in-play', pathIndex: newAbsIndex };
}
}
return { position: pawn.position, pathIndex: pawn.pathIndex };
}
chooseAIPawn(movablePawns, dice, color) {
if (movablePawns.length === 1) return movablePawns[0];
const otherPawnsInPlay = Object.values(this.state.pawns).some(p => p.color === color && p.position === 'in-play');
const scoredMoves = movablePawns.map(pawnId => {
const pawn = this.state.pawns[pawnId];
const { position: newPosition, pathIndex: newPathIndex } = this.calculateNewPosition(pawn, dice);
let score = 0;
if (newPosition === 'in-play') {
const pawnsToKnock = this.getPawnsOnSquare(newPathIndex, 'in-play').filter(p => {
const isPawnSafe = this.START_POSITIONS[p.color] === p.pathIndex;
return p.color !== pawn.color && !isPawnSafe;
});
if (pawnsToKnock.length > 0) {
score += 750 * pawnsToKnock.length;
}
const opponentColors = this.COLORS.filter(c => c !== color);
const opponentStartPositions = opponentColors.map(c => this.START_POSITIONS[c]);
if (opponentStartPositions.includes(newPathIndex)) {
score -= 1000;
}
}
if (newPosition === 'finished') {
score += 800;
}
if (pawn.position === 'home') {
score += 250;
}
if (pawn.position === 'in-play' && newPosition === 'in-stretch') {
score += 350;
}
if (newPosition === 'in-play' && newPathIndex === this.START_POSITIONS[pawn.color]) {
score += 70;
}
if (pawn.position === 'in-stretch' && otherPawnsInPlay) {
score -= 400;
}
if (newPosition === 'in-play') {
for (let i = 1; i <= 6; i++) {
const checkIndex = (newPathIndex - i - 1 + this.MAIN_PATH_LENGTH) % this.MAIN_PATH_LENGTH + 1;
const potentialThreats = this.getPawnsOnSquare(checkIndex, 'in-play').filter(p => p.color !== pawn.color);
if (potentialThreats.length > 0) {
const isThreatOnSafeArea = this.START_POSITIONS[potentialThreats[0].color] === potentialThreats[0].pathIndex;
if (!isThreatOnSafeArea) {
score -= (150 / i);
break;
}
}
}
}
score += this.getRelativeBoardPosition(pawn) * 1.5;
return { pawnId, score };
});
scoredMoves.sort((a, b) => b.score - a.score);
return scoredMoves[0].pawnId;
}
movePawn(pawnId) {
this.highlightMovablePawns([], false);
this.rollButton.disabled = true;
const pawn = this.state.pawns[pawnId];
const { position: newPosition, pathIndex: newPathIndex } = this.calculateNewPosition(pawn, this.state.diceValue);
pawn.position = newPosition;
pawn.pathIndex = newPathIndex;
if (pawn.position === 'finished') {
pawn.pathIndex = 0;
this.showTemporaryMessage('Finished!', pawn.color);
const el = document.getElementById(pawnId);
if (el) {
const finalStretchCoords = this.HOME_STRETCH_COORDS[pawn.color][this.HOME_STRETCH_LENGTH];
el.setAttribute('cx', finalStretchCoords.x);
el.setAttribute('cy', finalStretchCoords.y);
el.classList.add('finished-animation');
}
} else {
this.updatePawnPosition(pawnId);
}
if (pawn.position === 'in-play') {
this.handleLanding(pawn);
}
this.adjustForStackedPawns();
if (this.checkWinner(pawn.color)) {
this.state.isGameOver = true;
this.rollButton.disabled = true;
this.messageBox.innerHTML = `Game Over! <a href="ludo.html">üîÅ</a>`;
const winnerName = pawn.color.charAt(0).toUpperCase() + pawn.color.slice(1);
this.showTemporaryMessage(`${winnerName} is the winner!`, pawn.color);
} else {
setTimeout(() => this.switchPlayer(), this.NEXT_TURN_DELAY);
}
}
findMovablePawns(color, dice) {
return Object.values(this.state.pawns)
.filter(p => p.color === color && p.position !== 'finished')
.filter(pawn => {
if (pawn.position === 'home') {
if (dice !== 6) return false;
const startPos = this.START_POSITIONS[color];
const pawnsOnStart = this.getPawnsOnSquare(startPos, 'in-play');
return pawnsOnStart.filter(p => p.color === color).length < 2;
}
const { position: newPos, pathIndex: newIndex } = this.calculateNewPosition(pawn, dice);
if (newPos === 'finished') return true;
if (pawn.position === 'in-stretch' && newIndex > this.HOME_STRETCH_LENGTH) return false;
if (newPos === 'in-stretch' && newIndex > this.HOME_STRETCH_LENGTH) return false;
const occupyingPawns = this.getPawnsOnSquare(newIndex, newPos);
return occupyingPawns.filter(p => p.color === color).length < 2;
})
.map(p => p.id);
}
getRelativeBoardPosition(pawn) {
if (pawn.position !== 'in-play') return -1;
const startPoint = this.START_POSITIONS[pawn.color];
return (pawn.pathIndex - startPoint + this.MAIN_PATH_LENGTH) % this.MAIN_PATH_LENGTH;
}
getPawnsOnSquare(pathIndex, position) {
return Object.values(this.state.pawns).filter(p => p.position === position && p.pathIndex === pathIndex);
}
handleLanding(movedPawn) {
const pawnsToKnock = this.getPawnsOnSquare(movedPawn.pathIndex, 'in-play')
.filter(p => p.id !== movedPawn.id && p.color !== movedPawn.color);
if (pawnsToKnock.length > 0) {
let knockedOutMessage = false;
pawnsToKnock.forEach(pawnToKnock => {
const isPawnSafe = this.START_POSITIONS[pawnToKnock.color] === pawnToKnock.pathIndex;
if (!isPawnSafe) {
pawnToKnock.position = 'home';
pawnToKnock.pathIndex = 0;
this.updatePawnPosition(pawnToKnock.id);
if (!knockedOutMessage) {
const movedPlayerName = movedPawn.color.charAt(0).toUpperCase() + movedPawn.color.slice(1);
const knockedPlayerName = pawnToKnock.color.charAt(0).toUpperCase() + pawnToKnock.color.slice(1);
this.messageBox.textContent = `${movedPlayerName} knocked out ${knockedPlayerName}!`;
knockedOutMessage = true;
}
}
});
}
}
checkWinner(color) {
return Object.values(this.state.pawns)
.filter(p => p.color === color)
.every(p => p.position === 'finished');
}
playAITurn() {
if (this.state.isGameOver) return;
this.rollDice();
}
}
new LudoGame();
});
</script>
</body>
</html>