<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Coder 2</title>
<script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","author":{"@type":"Person","name":"Johnny Heggelund"}}</script>
<style>
:root {
--bg-color: #0d1117;
--text-color: #c9d1d9;
--accent-color: #61afef;
--border-color: #30363d;
--caret-color: #61afef;
--selection-bg: rgba(97, 175, 239, 0.2);
--font-mono: 'Fira Code', 'JetBrains Mono', 'Menlo', 'Monaco', 'Courier New', monospace;
--font-size: 15px;
--c-comment: #8b949e;
--c-tag: #7ee787;
--c-entity: #79c0ff;
--c-attr: #d2a8ff;
--c-string: #a5d6ff;
--c-keyword: #ff7b72;
--c-number: #d2a8ff;
--c-func: #d2a8ff;
--c-class: #f0883e;
--c-trailing: rgba(255, 100, 100, 0.3);
}
html, body {
margin: 0; padding: 0;
width: 100%; height: 100%;
background-color: var(--bg-color);
color: var(--text-color);
font-family: var(--font-mono);
overflow: hidden;
}
.editor-container {
display: flex;
height: 100vh;
width: 100vw;
}
#line-numbers {
border-right: 1px solid var(--border-color);
min-width: 65px;
padding: 15px 15px 100px 15px;
box-sizing: border-box;
text-align: right;
color: #484f58;
user-select: none;
pointer-events: none;
overflow: hidden;
font-size: var(--font-size);
line-height: 1.5;
background-color: var(--bg-color);
white-space: pre;
}
.line-numbers-hidden #line-numbers {
width: 0; min-width: 0; border: none; padding: 15px 0; overflow: hidden;
}
.editor-wrapper {
position: relative;
flex-grow: 1;
height: 100%;
}
.editor-textarea {
position: absolute;
top: 0; left: 0;
width: 100%; height: 100%;
box-sizing: border-box;
border: none;
outline: none;
resize: none;
white-space: pre;
overflow-wrap: normal;
font-family: var(--font-mono);
font-size: var(--font-size);
padding: 15px 15px 100px 15px;
line-height: 1.5;
margin: 0;
background-color: transparent;
}
#highlight-layer {
z-index: 1;
pointer-events: none;
overflow: hidden;
color: var(--text-color);
}
textarea#editor {
z-index: 2;
color: transparent;
caret-color: var(--caret-color);
overflow: auto;
}
textarea::selection {
background-color: var(--selection-bg);
color: transparent;
}
.token.comment { color: var(--c-comment); font-style: italic; }
.token.tag { color: var(--c-tag); }
.token.attr-name { color: var(--c-entity); }
.token.attr-value { color: var(--c-string); }
.token.string { color: var(--c-string); }
.token.keyword { color: var(--c-keyword); }
.token.number { color: var(--c-number); }
.token.function { color: var(--c-func); }
.token.selector { color: var(--c-tag); }
.token.property { color: var(--c-entity); }
.token.class { color: var(--c-class); }
.token.trailing-space { background-color: var(--c-trailing); border-radius: 2px; }
.modal {
display: none;
position: fixed;
background-color: #161b22;
border: 1px solid var(--border-color);
color: var(--text-color);
z-index: 100;
padding: 10px;
box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
max-height: 90vh;
overflow-y: auto;
border-radius: 6px;
}
#help-modal { top: 50%; left: 50%; transform: translate(-50%, -50%); width: 450px; }
#search-modal { top: 20px; right: 20px; width: 350px; }
.modal h1 { margin: 0 0 15px 0; color: var(--accent-color); font-weight: normal; font-size: 1.8em; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
.modal h2 { margin: 0 0 15px 0; color: var(--accent-color); font-weight: normal; font-size: 0.9em; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
.modal ul { list-style-type: none; padding-left: 0; }
.modal li { margin-bottom: 6px; font-size: 0.9em; display: flex; justify-content: space-between; }
.modal li strong { color: var(--accent-color); font-family: var(--font-mono); font-size: 0.9em; }
.modal-close-btn { position: absolute; top: 5px; right: 8px; font-size: 20px; color: #8b949e; cursor: pointer; background: none; border: none; }
.modal-close-btn:hover { color: var(--text-color); }
#search-modal .input-group { margin-bottom: 15px; }
#search-modal label { display: block; margin-bottom: 5px; font-size: 0.9em; }
#search-modal #match-count { float: right; font-size: 0.9em; color: #8b949e; }
#search-modal input {
width: 100%; background-color: #0d1117; border: 1px solid var(--border-color);
color: var(--text-color); padding: 8px; box-sizing: border-box; font-family: inherit; font-size: 0.9em; border-radius: 4px;
}
#search-modal .button-group { display: flex; justify-content: space-between; gap: 10px; }
#search-modal button {
flex-grow: 1; background-color: #21262d; border: 1px solid var(--border-color);
color: var(--text-color); padding: 6px 12px; cursor: pointer; border-radius: 4px; font-size: 0.9em;
}
#search-modal button:hover { background-color: #30363d; border-color: #8b949e; }
#toast-notification {
position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
background-color: #21262d; color: var(--text-color); padding: 8px 16px;
border-radius: 6px; border: 1px solid var(--border-color);
z-index: 200; opacity: 0; visibility: hidden;
transition: opacity 0.3s, visibility 0.3s; font-size: 0.9em;
}
#toast-notification.show { opacity: 1; visibility: visible; }
hr.separator { border: 0; border-top: 1px solid var(--border-color); margin: 8px 0; }
</style>
</head>
<body>
<div id="editor-container" class="editor-container">
<div id="line-numbers">1</div>
<div class="editor-wrapper">
<pre id="highlight-layer" class="editor-textarea" aria-hidden="true"></pre>
<textarea id="editor" class="editor-textarea" spellcheck="false" draggable="false"></textarea>
</div>
</div>
<div id="help-modal" class="modal">
<button id="help-modal-close-btn" class="modal-close-btn" aria-label="Close">×</button>
<h1 id="help-main-title">Coder 2 Beta</h1>
<h2 id="help-title">Shortcuts</h2>
<ul id="help-list">
<li><span>Open File</span> <strong>Ctrl + O</strong></li>
<li><span>Save File</span> <strong>Ctrl + S</strong></li>
<li><span>New File</span> <strong>Alt + N</strong></li>
<hr class="separator">
<li><span>Search & Replace</span> <strong>Alt + F</strong></li>
<li><span>Preview (New Tab)</span> <strong>Alt + P</strong></li>
<li><span>Toggle Help</span> <strong>Alt + H</strong></li>
<li><span>Toggle Line Num</span> <strong>Alt + I</strong></li>
<hr class="separator">
<li><span>Check Whitespace</span> <strong>Alt + W</strong></li>
<li><span>Strip Empty Lines</span> <strong>Alt + L</strong></li>
<hr class="separator">
<li><span>Jump to &lt;style&gt;</span> <strong>Ctrl + Shift + 1</strong></li>
<li><span>Next Function</span> <strong>Ctrl + Shift + 2</strong></li>
<li><span>Jump to &lt;body&gt;</span> <strong>Ctrl + Shift + 3</strong></li>
<li><span>Next Comment</span> <strong>Ctrl + Shift + 4</strong></li>
<hr class="separator">
<li><span>Open in New Tab</span> <strong>Alt + T</strong></li>
<li><span>Indent</span> <strong>Tab</strong></li>
<li><span>Outdent</span> <strong>Shift + Tab</strong></li>
</ul>
</div>
<div id="search-modal" class="modal">
<button id="search-modal-close-btn" class="modal-close-btn" style="top: 10px; right: 10px;">×</button>
<div class="input-group">
<label for="find-input">Find: <span id="match-count"></span></label>
<input type="text" id="find-input" placeholder="Type to search...">
</div>
<div class="input-group">
<label for="replace-input">Replace with:</label>
<input type="text" id="replace-input" placeholder="Replacement text...">
</div>
<div class="button-group">
<button id="find-next-btn">Next</button>
<button id="replace-btn">Replace</button>
<button id="replace-all-btn">All</button>
</div>
</div>
<div id="toast-notification"></div>
<script>
const CodeEditor = {
config: {
debounceDelay: 50,
indentUnit: '  ',
toastDuration: 2500,
},
state: {
fileHandle: null,
fileName: 'Untitled',
hasUnsavedChanges: false,
searchResults: { term: '', indices: [], currentIndex: -1 },
toastTimer: null,
lastLineCount: 0,
lastMatchPosition: 0,
},
elements: {},
debouncedUpdate: null,
init() {
this.cacheDOMElements();
this.bindEventListeners();
this.debouncedUpdate = this.utils.debounce(() => {
this.updateLineNumbers();
this.highlight();
}, this.config.debounceDelay);
this.updateLineNumbers();
this.highlight();
if (localStorage.getItem('lineNumbersHidden') === 'true') {
this.elements.editorContainer.classList.add('line-numbers-hidden');
}
const urlParams = new URLSearchParams(window.location.search);
if (!urlParams.has('quiet')) {
this.toggleModal('help');
}
},
cacheDOMElements() {
this.elements = {
editorContainer: document.getElementById('editor-container'),
editor: document.getElementById('editor'),
lineNumbers: document.getElementById('line-numbers'),
highlightLayer: document.getElementById('highlight-layer'),
helpModal: document.getElementById('help-modal'),
helpModalCloseBtn: document.getElementById('help-modal-close-btn'),
searchModal: document.getElementById('search-modal'),
searchModalCloseBtn: document.getElementById('search-modal-close-btn'),
findInput: document.getElementById('find-input'),
replaceInput: document.getElementById('replace-input'),
findNextBtn: document.getElementById('find-next-btn'),
replaceBtn: document.getElementById('replace-btn'),
replaceAllBtn: document.getElementById('replace-all-btn'),
matchCountSpan: document.getElementById('match-count'),
toast: document.getElementById('toast-notification'),
};
},
bindEventListeners() {
const { editor, findInput, helpModalCloseBtn, searchModalCloseBtn, findNextBtn, replaceBtn, replaceAllBtn } = this.elements;
editor.addEventListener('scroll', this.handleEditorScroll.bind(this));
editor.addEventListener('input', this.handleEditorInput.bind(this));
editor.addEventListener('keydown', this.handleEditorKeyDown.bind(this));
findInput.addEventListener('input', this.utils.debounce(this.updateSearchResults.bind(this), 200));
helpModalCloseBtn.addEventListener('click', () => this.toggleModal('help'));
searchModalCloseBtn.addEventListener('click', () => this.toggleModal('search'));
findNextBtn.addEventListener('click', this.findNext.bind(this));
replaceBtn.addEventListener('click', this.replaceCurrent.bind(this));
replaceAllBtn.addEventListener('click', this.replaceAll.bind(this));
document.addEventListener('keydown', this.handleGlobalKeyDown.bind(this));
window.addEventListener('beforeunload', this.handleBeforeUnload.bind(this));
window.addEventListener('focus', () => {
if (this.elements.helpModal.style.display !== 'block' && this.elements.searchModal.style.display !== 'block') {
editor.focus();
}
});
},
handleEditorScroll() {
const editor = this.elements.editor;
const lineNumbers = this.elements.lineNumbers;
lineNumbers.scrollTop = editor.scrollTop;
this.elements.highlightLayer.scrollTop = editor.scrollTop;
this.elements.highlightLayer.scrollLeft = editor.scrollLeft;
},
highlight() {
const code = this.elements.editor.value;
this.elements.highlightLayer.innerHTML = this.highlightHTML(code);
},
escapeHTML(str) {
return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
},
highlightHTML(code) {
let output = this.escapeHTML(code);
output = output.replace(/(&lt;!--[\s\S]*?--&gt;)/g, '<span class="token comment">$1</span>');
output = output.replace(/(&lt;script.*?&gt;)([\s\S]*?)(&lt;\/script&gt;)/gi, (m, open, content, close) => {
return open + this.highlightJS(content) + close;
});
output = output.replace(/(&lt;style.*?&gt;)([\s\S]*?)(&lt;\/style&gt;)/gi, (m, open, content, close) => {
return open + this.highlightCSS(content) + close;
});
output = output.replace(/(&lt;\/?)(\w+)([^&]*?)(&gt;)/g, (m, bracket, tag, attrs, close) => {
const styledAttrs = attrs.replace(/([a-zA-Z-]+)(=)(".*?"|'.*?')/g,
'<span class="token attr-name">$1</span>=$3'
);
return `${bracket}<span class="token tag">${tag}</span>${styledAttrs}${close}`;
});
output = output.replace(/([ \t]+)(\n|$)/g, '<span class="token trailing-space">$1</span>$2');
if (code.endsWith('\n')) output += '\n';
return output;
},
highlightJS(code) {
const p = /(".*?"|'.*?'|`[\s\S]*?`|\/\/.*|\/\*[\s\S]*?\*\/)|(\b(?:const|let|var|function|return|if|else|for|while|class|new|this|async|await|import|export|from)\b)|(\b\d+\.?\d*\b)|(\b[a-zA-Z_$][a-zA-Z0-9_$]*(?=\())/g;
return code.replace(p, (m, s, k, n, f) => {
if (s) return (s.startsWith('/')) ? `<span class="token comment">${s}</span>` : `<span class="token string">${s}</span>`;
if (k) return `<span class="token keyword">${k}</span>`;
if (n) return `<span class="token number">${n}</span>`;
if (f) return `<span class="token function">${f}</span>`;
return m;
});
},
highlightCSS(code) {
const p = /(\/\*[\s\S]*?\*\/)|(".*?"|'.*?')|([\.#][\w-]+)|([a-zA-Z-]+)(?=:)|(@[\w-]+)/g;
return code.replace(p, (m, c, s, sel, prop, at) => {
if (c) return `<span class="token comment">${c}</span>`;
if (s) return `<span class="token string">${s}</span>`;
if (sel) return `<span class="token selector">${sel}</span>`;
if (prop) return `<span class="token property">${prop}</span>`;
if (at) return `<span class="token keyword">${at}</span>`;
return m;
});
},
checkWhitespace() {
const lines = this.elements.editor.value.split('\n');
const regex = /[ \t]+$/;
const count = lines.filter(line => regex.test(line)).length;
if (count === 0) {
this.showToast("No trailing whitespace found. ✨");
} else {
this.showToast(`${count} lines have trailing whitespace.`);
}
},
toggleModal(modalName) {
const modal = this.elements[`${modalName}Modal`];
const isVisible = modal.style.display === 'block';
modal.style.display = isVisible ? 'none' : 'block';
if (!isVisible && modalName === 'search') {
this.elements.findInput.focus();
this.elements.findInput.select();
this.updateSearchResults();
} else if (isVisible) {
this.elements.editor.focus();
}
},
showToast(message) {
clearTimeout(this.state.toastTimer);
this.elements.toast.textContent = message;
this.elements.toast.classList.add('show');
this.state.toastTimer = setTimeout(() => {
this.elements.toast.classList.remove('show');
}, this.config.toastDuration);
},
updateLineNumbers() {
const text = this.elements.editor.value;
const lineCount = (text.match(/\n/g) || []).length + 1;
if (lineCount !== this.state.lastLineCount) {
this.state.lastLineCount = lineCount;
this.elements.lineNumbers.textContent = Array.from({ length: lineCount }, (_, i) => i + 1).join('\n');
}
},
handleEditorInput() {
if (!this.state.hasUnsavedChanges) this.setUnsavedChanges(true);
this.state.searchResults.term = '';
this.debouncedUpdate();
},
handleEditorKeyDown(e) {
const isCtrl = e.ctrlKey || e.metaKey;
const isAlt = e.altKey;
const pairs = { '(': ')', '[': ']', '{': '}', '"': '"', "'": "'" };
const { selectionStart, selectionEnd, value } = this.elements.editor;
if (Object.values(pairs).includes(e.key) && selectionStart === selectionEnd && !isCtrl && !isAlt) {
if (value.charAt(selectionStart) === e.key) {
e.preventDefault();
this.elements.editor.setSelectionRange(selectionStart + 1, selectionStart + 1);
return;
}
}
if (e.key === 'Enter' && !isCtrl && !isAlt && !e.shiftKey) {
e.preventDefault();
const lineStart = value.lastIndexOf('\n', selectionStart - 1) + 1;
const currentLine = value.substring(lineStart, selectionStart);
const match = currentLine.match(/^[ \t]*/);
const indent = match ? match[0] : '';
this.insertText('\n' + indent);
return;
}
if (Object.keys(pairs).includes(e.key) && !isCtrl && !isAlt) {
e.preventDefault();
const close = pairs[e.key];
if (selectionStart !== selectionEnd) {
const text = value.substring(selectionStart, selectionEnd);
this.insertText(e.key + text + close, true);
} else {
this.insertText(e.key + close);
this.elements.editor.setSelectionRange(selectionStart + 1, selectionStart + 1);
}
return;
}
if (e.key === 'Tab') {
e.preventDefault();
const indent = this.config.indentUnit;
if (selectionStart !== selectionEnd) {
const lineStart = value.lastIndexOf('\n', selectionStart - 1) + 1;
let lineEnd = value.indexOf('\n', selectionEnd);
if (lineEnd === -1) lineEnd = value.length;
const text = value.substring(lineStart, lineEnd);
const lines = text.split('\n');
const newLines = e.shiftKey
? lines.map(l => l.startsWith(indent) ? l.slice(indent.length) : l)
: lines.map(l => indent + l);
this.elements.editor.setRangeText(newLines.join('\n'), lineStart, lineEnd, 'select');
} else {
if (e.shiftKey) {
const lineStart = value.lastIndexOf('\n', selectionStart - 1) + 1;
if (value.substr(lineStart, indent.length) === indent) {
this.elements.editor.setRangeText('', lineStart, lineStart + indent.length, 'end');
}
} else {
this.insertText(indent);
}
}
this.handleEditorInput();
}
},
insertText(text, select = false) {
const { selectionStart, selectionEnd } = this.elements.editor;
this.elements.editor.setRangeText(text, selectionStart, selectionEnd, select ? 'select' : 'end');
this.handleEditorInput();
},
handleGlobalKeyDown(e) {
const isModalOpen = this.elements.helpModal.style.display === 'block' || this.elements.searchModal.style.display === 'block';
const isCtrl = e.ctrlKey || e.metaKey;
const key = e.key.toLowerCase();
if (isCtrl && key === 's') { e.preventDefault(); this.saveFile(); return; }
if (e.altKey && key === 'h') { e.preventDefault(); this.toggleModal('help'); }
if (e.altKey && key === 'f') { e.preventDefault(); this.toggleModal('search'); }
if (isCtrl) {
if (key === 'o') { e.preventDefault(); this.openFile(); }
if (e.shiftKey) {
if (e.code === 'Digit1') { e.preventDefault(); this.jumpToSection('style'); }
if (e.code === 'Digit2') {
e.preventDefault();
if(this.elements.editor.value.indexOf('<script') > -1 && this.elements.editor.selectionStart < this.elements.editor.value.indexOf('<script')) {
this.jumpToSection('script');
} else {
this.jumpToNextDefinition();
}
}
if (e.code === 'Digit3') { e.preventDefault(); this.jumpToSection('body'); }
if (e.code === 'Digit4') { e.preventDefault(); this.jumpToComment(); }
}
} else if (e.altKey) {
if (key === 'n') { e.preventDefault(); this.newFile(); }
if (key === 'w') { e.preventDefault(); this.checkWhitespace(); }
if (key === 'l') { e.preventDefault(); this.removeEmptyLines(); }
if (key === 'p') { e.preventDefault(); this.previewInNewTab(); }
if (key === 'i') { e.preventDefault(); this.toggleLineNumbers(); }
if (key === 't') {
e.preventDefault();
const url = window.location.href.split('?')[0] + '?quiet=true';
window.open(url, '_blank');
}
}
if (isModalOpen && key === 'escape') {
this.elements.searchModal.style.display = 'none';
this.elements.helpModal.style.display = 'none';
this.elements.editor.focus();
}
},
setUnsavedChanges(isUnsaved) {
this.state.hasUnsavedChanges = isUnsaved;
document.title = isUnsaved ? `* ${this.state.fileName}` : this.state.fileName;
},
_safeModifyOutsideScript(regex, replacement) {
const editor = this.elements.editor;
const originalValue = editor.value;
const parts = originalValue.split(/(<script[\s\S]*?>[\s\S]*?<\/script>)/gi);
let newValue = "";
for (let i = 0; i < parts.length; i++) {
newValue += (i % 2 === 0) ? parts[i].replace(regex, replacement) : parts[i];
}
if (originalValue !== newValue) {
editor.value = newValue;
this.handleEditorInput();
return { linesRemoved: (originalValue.match(/\n/g)||[]).length - (newValue.match(/\n/g)||[]).length };
}
return { linesRemoved: 0 };
},
removeEmptyLines() {
const result = this._safeModifyOutsideScript(/(\r?\n){2,}/g, '\n');
if (result.linesRemoved > 0) this.showToast(`Removed ${result.linesRemoved} empty lines`);
},
previewInNewTab() {
const win = window.open();
if(win) { win.document.write(this.elements.editor.value); win.document.close(); }
},
async openFile() {
if (this.state.hasUnsavedChanges && !confirm("Lose unsaved changes?")) return;
try {
const [handle] = await window.showOpenFilePicker();
this.state.fileHandle = handle;
const file = await handle.getFile();
this.elements.editor.value = await file.text();
this.state.fileName = file.name;
this.setUnsavedChanges(false);
this.handleEditorInput();
} catch (e) {}
},
async saveFile() {
try {
if (!this.state.fileHandle) {
this.state.fileHandle = await window.showSaveFilePicker({ suggestedName: this.state.fileName });
this.state.fileName = this.state.fileHandle.name;
}
const w = await this.state.fileHandle.createWritable();
await w.write(this.elements.editor.value); await w.close();
this.setUnsavedChanges(false);
this.showToast('Saved!');
} catch (e) {}
},
newFile() {
if (this.state.hasUnsavedChanges && !confirm("Lose unsaved changes?")) return;
this.elements.editor.value = '';
this.state.fileHandle = null;
this.state.fileName = 'Untitled';
this.setUnsavedChanges(false);
this.handleEditorInput();
},
jumpToSection(tag) {
const val = this.elements.editor.value;
const idx = val.indexOf(`<${tag}`, this.elements.editor.selectionStart + 1) > -1
? val.indexOf(`<${tag}`, this.elements.editor.selectionStart + 1)
: val.indexOf(`<${tag}`);
if(idx > -1) this.jumpTo(idx);
},
jumpToNextDefinition() {
const regex = /(^\s*(?!if|for|while|switch|catch)\w+\s*\(.*?\)\s*\{|^\s*function\s+\w+)/gm;
this.regexJump(regex);
},
jumpToComment() {
const regex = /(^\s*\/\*[\s\S]*?\*\/|^\s*\/\/.*)/gm;
this.regexJump(regex);
},
regexJump(regex) {
const val = this.elements.editor.value;
const current = this.elements.editor.selectionStart;
let match, next = -1, first = -1;
while ((match = regex.exec(val)) !== null) {
if (first === -1) first = match.index;
if (match.index > current) { next = match.index; break; }
}
this.jumpTo(next > -1 ? next : first);
},
jumpTo(idx) {
if(idx === -1) return;
const editor = this.elements.editor;
editor.focus();
editor.setSelectionRange(idx, idx);
const lines = editor.value.substr(0, idx).split('\n').length;
const lineHeight = 22.5;
editor.scrollTo({ top: (lines * lineHeight) - (editor.clientHeight / 3), behavior: 'smooth' });
},
updateSearchResults() {
const term = this.elements.findInput.value;
if (!term) { this.state.searchResults = { term: '', indices: [], currentIndex: -1 }; this.elements.matchCountSpan.textContent=''; return; }
const indices = [];
const regex = new RegExp(this.utils.escapeRegExp(term), 'gi');
let match;
while ((match = regex.exec(this.elements.editor.value)) !== null) indices.push(match.index);
this.state.searchResults = { term, indices, currentIndex: -1 };
this.elements.matchCountSpan.textContent = `${indices.length} matches`;
},
findNext() {
if(!this.state.searchResults.indices.length) this.updateSearchResults();
const { indices } = this.state.searchResults;
if(!indices.length) return;
this.state.searchResults.currentIndex = (this.state.searchResults.currentIndex + 1) % indices.length;
const idx = indices[this.state.searchResults.currentIndex];
this.elements.editor.focus();
this.elements.editor.setSelectionRange(idx, idx + this.state.searchResults.term.length);
this.jumpTo(idx);
},
replaceCurrent() {
const { selectionStart, selectionEnd } = this.elements.editor;
if(selectionStart === selectionEnd) { this.findNext(); return; }
this.insertText(this.elements.replaceInput.value);
this.findNext();
},
replaceAll() {
const term = this.elements.findInput.value;
if(!term) return;
const newVal = this.elements.editor.value.replace(new RegExp(this.utils.escapeRegExp(term), 'gi'), this.elements.replaceInput.value);
this.elements.editor.value = newVal;
this.handleEditorInput();
},
toggleLineNumbers() {
this.elements.editorContainer.classList.toggle('line-numbers-hidden');
localStorage.setItem('lineNumbersHidden', this.elements.editorContainer.classList.contains('line-numbers-hidden'));
},
handleBeforeUnload(e) {
if(this.state.hasUnsavedChanges) { e.preventDefault(); e.returnValue = ''; }
},
utils: {
debounce(func, delay) {
let timeout;
return function(...args) {
clearTimeout(timeout);
timeout = setTimeout(() => func.apply(this, args), delay);
};
},
escapeRegExp(string) {
return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
}
};
window.addEventListener('load', () => CodeEditor.init());
</script>
</body>
</html>