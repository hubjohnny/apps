<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chromebook Screen Recorder</title>
<script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","author":{"@type":"Person","name":"Johnny Heggelund"}}</script>
<script>
(function (name, definition) {
if (typeof define === 'function' && define.amd) { define(definition); }
else if (typeof module !== 'undefined' && module.exports) { module.exports = definition(); }
else { window.ysFixWebmDuration = definition(); }
})('fix-webm-duration', function () {
var sections = { 0xa45dfa3: { name: 'EBML', type: 'Container' }, 0x286: { name: 'EBMLVersion', type: 'Uint' }, 0x2f7: { name: 'EBMLReadVersion', type: 'Uint' }, 0x2f2: { name: 'EBMLMaxIDLength', type: 'Uint' }, 0x2f3: { name: 'EBMLMaxSizeLength', type: 'Uint' }, 0x282: { name: 'DocType', type: 'String' }, 0x287: { name: 'DocTypeVersion', type: 'Uint' }, 0x285: { name: 'DocTypeReadVersion', type: 'Uint' }, 0x6c: { name: 'Void', type: 'Binary' }, 0x3f: { name: 'CRC-32', type: 'Binary' }, 0xb538667: { name: 'SignatureSlot', type: 'Container' }, 0x3e8a: { name: 'SignatureAlgo', type: 'Uint' }, 0x3e9a: { name: 'SignatureHash', type: 'Uint' }, 0x3ea5: { name: 'SignaturePublicKey', type: 'Binary' }, 0x3eb5: { name: 'Signature', type: 'Binary' }, 0x3e5b: { name: 'SignatureElements', type: 'Container' }, 0x3e7b: { name: 'SignatureElementList', type: 'Container' }, 0x2532: { name: 'SignedElement', type: 'Binary' }, 0x8538067: { name: 'Segment', type: 'Container' }, 0x14d9b74: { name: 'SeekHead', type: 'Container' }, 0xdbb: { name: 'Seek', type: 'Container' }, 0x13ab: { name: 'SeekID', type: 'Binary' }, 0x13ac: { name: 'SeekPosition', type: 'Uint' }, 0x549a966: { name: 'Info', type: 'Container' }, 0x33a4: { name: 'SegmentUID', type: 'Binary' }, 0x3384: { name: 'SegmentFilename', type: 'String' }, 0x1cb923: { name: 'PrevUID', type: 'Binary' }, 0x1c83ab: { name: 'PrevFilename', type: 'String' }, 0x1eb923: { name: 'NextUID', type: 'Binary' }, 0x1e83bb: { name: 'NextFilename', type: 'String' }, 0x444: { name: 'SegmentFamily', type: 'Binary' }, 0x2924: { name: 'ChapterTranslate', type: 'Container' }, 0x29fc: { name: 'ChapterTranslateEditionUID', type: 'Uint' }, 0x29bf: { name: 'ChapterTranslateCodec', type: 'Uint' }, 0x29a5: { name: 'ChapterTranslateID', type: 'Binary' }, 0xad7b1: { name: 'TimecodeScale', type: 'Uint' }, 0x489: { name: 'Duration', type: 'Float' }, 0x461: { name: 'DateUTC', type: 'Date' }, 0x3ba9: { name: 'Title', type: 'String' }, 0xd80: { name: 'MuxingApp', type: 'String' }, 0x1741: { name: 'WritingApp', type: 'String' }, 0x67: { name: 'Timecode', type: 'Uint' }, 0x1854: { name: 'SilentTracks', type: 'Container' }, 0x18d7: { name: 'SilentTrackNumber', type: 'Uint' }, 0x27: { name: 'Position', type: 'Uint' }, 0x2b: { name: 'PrevSize', type: 'Uint' }, 0x23: { name: 'SimpleBlock', type: 'Binary' }, 0x20: { name: 'BlockGroup', type: 'Container' }, 0x21: { name: 'Block', type: 'Binary' }, 0x22: { name: 'BlockVirtual', type: 'Binary' }, 0x35a1: { name: 'BlockAdditions', type: 'Container' }, 0x26: { name: 'BlockMore', type: 'Container' }, 0x6e: { name: 'BlockAddID', type: 'Uint' }, 0x25: { name: 'BlockAdditional', type: 'Binary' }, 0x1b: { name: 'BlockDuration', type: 'Uint' }, 0x7a: { name: 'ReferencePriority', type: 'Uint' }, 0x7b: { name: 'ReferenceBlock', type: 'Int' }, 0x7d: { name: 'ReferenceVirtual', type: 'Int' }, 0x24: { name: 'CodecState', type: 'Binary' }, 0x35a2: { name: 'DiscardPadding', type: 'Int' }, 0xe: { name: 'Slices', type: 'Container' }, 0x68: { name: 'TimeSlice', type: 'Container' }, 0x4c: { name: 'LaceNumber', type: 'Uint' }, 0x4d: { name: 'FrameNumber', type: 'Uint' }, 0x4b: { name: 'BlockAdditionID', type: 'Uint' }, 0x4e: { name: 'Delay', type: 'Uint' }, 0x4f: { name: 'SliceDuration', type: 'Uint' }, 0x48: { name: 'ReferenceFrame', type: 'Container' }, 0x49: { name: 'ReferenceOffset', type: 'Uint' }, 0x4a: { name: 'ReferenceTimeCode', type: 'Uint' }, 0x2f: { name: 'EncryptedBlock', type: 'Binary' }, 0x654ae6b: { name: 'Tracks', type: 'Container' }, 0x2e: { name: 'TrackEntry', type: 'Container' }, 0x57: { name: 'TrackNumber', type: 'Uint' }, 0x33c5: { name: 'TrackUID', type: 'Uint' }, 0x3: { name: 'TrackType', type: 'Uint' }, 0x39: { name: 'FlagEnabled', type: 'Uint' }, 0x8: { name: 'FlagDefault', type: 'Uint' }, 0x15aa: { name: 'FlagForced', type: 'Uint' }, 0x1c: { name: 'FlagLacing', type: 'Uint' }, 0x2de7: { name: 'MinCache', type: 'Uint' }, 0x2df8: { name: 'MaxCache', type: 'Uint' }, 0x3e383: { name: 'DefaultDuration', type: 'Uint' }, 0x34e7a: { name: 'DefaultDecodedFieldDuration', type: 'Uint' }, 0x3314f: { name: 'TrackTimecodeScale', type: 'Float' }, 0x137f: { name: 'TrackOffset', type: 'Int' }, 0x15ee: { name: 'MaxBlockAdditionID', type: 'Uint' }, 0x136e: { name: 'Name', type: 'String' }, 0x2b59c: { name: 'Language', type: 'String' }, 0x6: { name: 'CodecID', type: 'String' }, 0x23a2: { name: 'CodecPrivate', type: 'Binary' }, 0x58688: { name: 'CodecName', type: 'String' }, 0x3446: { name: 'AttachmentLink', type: 'Uint' }, 0x1a9697: { name: 'CodecSettings', type: 'String' }, 0x1b4040: { name: 'CodecInfoURL', type: 'String' }, 0x6b240: { name: 'CodecDownloadURL', type: 'String' }, 0x2a: { name: 'CodecDecodeAll', type: 'Uint' }, 0x2fab: { name: 'TrackOverlay', type: 'Uint' }, 0x16aa: { name: 'CodecDelay', type: 'Uint' }, 0x16bb: { name: 'SeekPreRoll', type: 'Uint' }, 0x2624: { name: 'TrackTranslate', type: 'Container' }, 0x26fc: { name: 'TrackTranslateEditionUID', type: 'Uint' }, 0x26bf: { name: 'TrackTranslateCodec', type: 'Uint' }, 0x26a5: { name: 'TrackTranslateTrackID', type: 'Binary' }, 0x60: { name: 'Video', type: 'Container' }, 0x1a: { name: 'FlagInterlaced', type: 'Uint' }, 0x13b8: { name: 'StereoMode', type: 'Uint' }, 0x13c0: { name: 'AlphaMode', type: 'Uint' }, 0x13b9: { name: 'OldStereoMode', type: 'Uint' }, 0x30: { name: 'PixelWidth', type: 'Uint' }, 0x3a: { name: 'PixelHeight', type: 'Uint' }, 0x14aa: { name: 'PixelCropBottom', type: 'Uint' }, 0x14bb: { name: 'PixelCropTop', type: 'Uint' }, 0x14cc: { name: 'PixelCropLeft', type: 'Uint' }, 0x14dd: { name: 'PixelCropRight', type: 'Uint' }, 0x14b0: { name: 'DisplayWidth', type: 'Uint' }, 0x14ba: { name: 'DisplayHeight', type: 'Uint' }, 0x14b2: { name: 'DisplayUnit', type: 'Uint' }, 0x14b3: { name: 'AspectRatioType', type: 'Uint' }, 0xeb524: { name: 'ColourSpace', type: 'Binary' }, 0xfb523: { name: 'GammaValue', type: 'Float' }, 0x383e3: { name: 'FrameRate', type: 'Float' }, 0x61: { name: 'Audio', type: 'Container' }, 0x35: { name: 'SamplingFrequency', type: 'Float' }, 0x38b5: { name: 'OutputSamplingFrequency', type: 'Float' }, 0x1f: { name: 'Channels', type: 'Uint' }, 0x3d7b: { name: 'ChannelPositions', type: 'Binary' }, 0x2264: { name: 'BitDepth', type: 'Uint' }, 0x62: { name: 'TrackOperation', type: 'Container' }, 0x63: { name: 'TrackCombinePlanes', type: 'Container' }, 0x64: { name: 'TrackPlane', type: 'Container' }, 0x65: { name: 'TrackPlaneUID', type: 'Uint' }, 0x66: { name: 'TrackPlaneType', type: 'Uint' }, 0x69: { name: 'TrackJoinBlocks', type: 'Container' }, 0x6d: { name: 'TrackJoinUID', type: 'Uint' }, 0x40: { name: 'TrickTrackUID', type: 'Uint' }, 0x41: { name: 'TrickTrackSegmentUID', type: 'Binary' }, 0x46: { name: 'TrickTrackFlag', type: 'Uint' }, 0x47: { name: 'TrickMasterTrackUID', type: 'Uint' }, 0x44: { name: 'TrickMasterTrackSegmentUID', type: 'Binary' }, 0x2d80: { name: 'ContentEncodings', type: 'Container' }, 0x2240: { name: 'ContentEncoding', type: 'Container' }, 0x1031: { name: 'ContentEncodingOrder', type: 'Uint' }, 0x1032: { name: 'ContentEncodingScope', type: 'Uint' }, 0x1033: { name: 'ContentEncodingType', type: 'Uint' }, 0x1034: { name: 'ContentCompression', type: 'Container' }, 0x254: { name: 'ContentCompAlgo', type: 'Uint' }, 0x255: { name: 'ContentCompSettings', type: 'Binary' }, 0x1035: { name: 'ContentEncryption', type: 'Container' }, 0x7e1: { name: 'ContentEncAlgo', type: 'Uint' }, 0x7e2: { name: 'ContentEncKeyID', type: 'Binary' }, 0x7e3: { name: 'ContentSignature', type: 'Binary' }, 0x7e4: { name: 'ContentSigKeyID', type: 'Binary' }, 0x7e5: { name: 'ContentSigAlgo', type: 'Uint' }, 0x7e6: { name: 'ContentSigHashAlgo', type: 'Uint' }, 0xc53bb6b: { name: 'Cues', type: 'Container' }, 0x3b: { name: 'CuePoint', type: 'Container' }, 0x33: { name: 'CueTime', type: 'Uint' }, 0x37: { name: 'CueTrackPositions', type: 'Container' }, 0x77: { name: 'CueTrack', type: 'Uint' }, 0x71: { name: 'CueClusterPosition', type: 'Uint' }, 0x70: { name: 'CueRelativePosition', type: 'Uint' }, 0x32: { name: 'CueDuration', type: 'Uint' }, 0x1378: { name: 'CueBlockNumber', type: 'Uint' }, 0x6a: { name: 'CueCodecState', type: 'Uint' }, 0x5b: { name: 'CueReference', type: 'Container' }, 0x16: { name: 'CueRefTime', type: 'Uint' }, 0x17: { name: 'CueRefCluster', type: 'Uint' }, 0x135f: { name: 'CueRefNumber', type: 'Uint' }, 0x6b: { name: 'CueRefCodecState', type: 'Uint' }, 0x941a469: { name: 'Attachments', type: 'Container' }, 0x21a7: { name: 'AttachedFile', type: 'Container' }, 0x67e: { name: 'FileDescription', type: 'String' }, 0x66e: { name: 'FileName', type: 'String' }, 0x660: { name: 'FileMimeType', type: 'String' }, 0x65c: { name: 'FileData', type: 'Binary' }, 0x6ae: { name: 'FileUID', type: 'Uint' }, 0x675: { name: 'FileReferral', type: 'Binary' }, 0x661: { name: 'FileUsedStartTime', type: 'Uint' }, 0x662: { name: 'FileUsedEndTime', type: 'Uint' }, 0x43a770: { name: 'Chapters', type: 'Container' }, 0x5b9: { name: 'EditionEntry', type: 'Container' }, 0x5bc: { name: 'EditionUID', type: 'Uint' }, 0x5bd: { name: 'EditionFlagHidden', type: 'Uint' }, 0x5db: { name: 'EditionFlagDefault', type: 'Uint' }, 0x5dd: { name: 'EditionFlagOrdered', type: 'Uint' }, 0x36: { name: 'ChapterAtom', type: 'Container' }, 0x33c4: { name: 'ChapterUID', type: 'Uint' }, 0x1654: { name: 'ChapterStringUID', type: 'String' }, 0x11: { name: 'ChapterTimeStart', type: 'Uint' }, 0x12: { name: 'ChapterTimeEnd', type: 'Uint' }, 0x18: { name: 'ChapterFlagHidden', type: 'Uint' }, 0x598: { name: 'ChapterFlagEnabled', type: 'Uint' }, 0x2e67: { name: 'ChapterSegmentUID', type: 'Binary' }, 0x2ebc: { name: 'ChapterSegmentEditionUID', type: 'Uint' }, 0x23c3: { name: 'ChapterPhysicalEquiv', type: 'Uint' },
0xf: { name: 'ChapterTrack', type: 'Container' }, 0x9: { name: 'ChapterTrackNumber', type: 'Uint' }, 0x0: { name: 'ChapterDisplay', type: 'Container' }, 0x5: { name: 'ChapString', type: 'String' }, 0x37c: { name: 'ChapLanguage', type: 'String' }, 0x37e: { name: 'ChapCountry', type: 'String' }, 0x2944: { name: 'ChapProcess', type: 'Container' }, 0x2955: { name: 'ChapProcessCodecID', type: 'Uint' }, 0x50d: { name: 'ChapProcessPrivate', type: 'Binary' }, 0x2911: { name: 'ChapProcessCommand', type: 'Container' }, 0x2922: { name: 'ChapProcessTime', type: 'Uint' }, 0x2933: { name: 'ChapProcessData', type: 'Binary' }, 0x254c367: { name: 'Tags', type: 'Container' }, 0x3373: { name: 'Tag', type: 'Container' }, 0x23c0: { name: 'Targets', type: 'Container' }, 0x28ca: { name: 'TargetTypeValue', type: 'Uint' }, 0x23ca: { name: 'TargetType', type: 'String' }, 0x23c5: { name: 'TagTrackUID', type: 'Uint' }, 0x23c9: { name: 'TagEditionUID', type: 'Uint' }, 0x23c4: { name: 'TagChapterUID', type: 'Uint' }, 0x23c6: { name: 'TagAttachmentUID', type: 'Uint' }, 0x27c8: { name: 'SimpleTag', type: 'Container' }, 0x5a3: { name: 'TagName', type: 'String' }, 0x47a: { name: 'TagLanguage', type: 'String' }, 0x484: { name: 'TagDefault', type: 'Uint' }, 0x487: { name: 'TagString', type: 'String' }, 0x485: { name: 'TagBinary', type: 'Binary' }
};
function doInherit(newClass, baseClass) { newClass.prototype = Object.create(baseClass.prototype); newClass.prototype.constructor = newClass; }
function WebmBase(name, type) { this.name = name || 'Unknown'; this.type = type || 'Unknown'; }
WebmBase.prototype.updateBySource = function() { }; WebmBase.prototype.setSource = function(source) { this.source = source; this.updateBySource(); };
WebmBase.prototype.updateByData = function() { }; WebmBase.prototype.setData = function(data) { this.data = data; this.updateByData(); };
function WebmUint(name, type) { WebmBase.call(this, name, type || 'Uint'); } doInherit(WebmUint, WebmBase);
function padHex(hex) { return hex.length % 2 === 1 ? '0' + hex : hex; }
WebmUint.prototype.updateBySource = function() { this.data = ''; for (var i = 0; i < this.source.length; i++) { var hex = this.source[i].toString(16); this.data += padHex(hex); } };
WebmUint.prototype.updateByData = function() { var length = this.data.length / 2; this.source = new Uint8Array(length); for (var i = 0; i < length; i++) { var hex = this.data.substr(i * 2, 2); this.source[i] = parseInt(hex, 16); } };
WebmUint.prototype.getValue = function() { return parseInt(this.data, 16); }; WebmUint.prototype.setValue = function(value) { this.setData(padHex(value.toString(16))); };
function WebmFloat(name, type) { WebmBase.call(this, name, type || 'Float'); } doInherit(WebmFloat, WebmBase);
WebmFloat.prototype.getFloatArrayType = function() { return this.source && this.source.length === 4 ? Float32Array : Float64Array; };
WebmFloat.prototype.updateBySource = function() { var byteArray = this.source.reverse(); var floatArrayType = this.getFloatArrayType(); var floatArray = new floatArrayType(byteArray.buffer); this.data = floatArray[0]; };
WebmFloat.prototype.updateByData = function() { var floatArrayType = this.getFloatArrayType(); var floatArray = new floatArrayType([ this.data ]); var byteArray = new Uint8Array(floatArray.buffer); this.source = byteArray.reverse(); };
WebmFloat.prototype.getValue = function() { return this.data; }; WebmFloat.prototype.setValue = function(value) { this.setData(value); };
function WebmContainer(name, type) { WebmBase.call(this, name, type || 'Container'); } doInherit(WebmContainer, WebmBase);
WebmContainer.prototype.readByte = function() { return this.source[this.offset++]; };
WebmContainer.prototype.readUint = function() { var firstByte = this.readByte(); var bytes = 8 - firstByte.toString(2).length; var value = firstByte - (1 << (7 - bytes)); for (var i = 0; i < bytes; i++) { value *= 256; value += this.readByte(); } return value; };
WebmContainer.prototype.updateBySource = function() { this.data = []; for (this.offset = 0; this.offset < this.source.length; this.offset = end) { var id = this.readUint(); var len = this.readUint(); var end = Math.min(this.offset + len, this.source.length); var data = this.source.slice(this.offset, end); var info = sections[id] || { name: 'Unknown', type: 'Unknown' }; var ctr = WebmBase; switch (info.type) { case 'Container': ctr = WebmContainer; break; case 'Uint': ctr = WebmUint; break; case 'Float': ctr = WebmFloat; break; } var section = new ctr(info.name, info.type); section.setSource(data); this.data.push({ id: id, idHex: id.toString(16), data: section }); } };
WebmContainer.prototype.writeUint = function(x, draft) { for (var bytes = 1, flag = 0x80; x >= flag && bytes < 8; bytes++, flag *= 0x80) { } if (!draft) { var value = flag + x; for (var i = bytes - 1; i >= 0; i--) { var c = value % 256; this.source[this.offset + i] = c; value = (value - c) / 256; } } this.offset += bytes; };
WebmContainer.prototype.writeSections = function(draft) { this.offset = 0; for (var i = 0; i < this.data.length; i++) { var section = this.data[i], content = section.data.source, contentLength = content.length; this.writeUint(section.id, draft); this.writeUint(contentLength, draft); if (!draft) { this.source.set(content, this.offset); } this.offset += contentLength; } return this.offset; };
WebmContainer.prototype.updateByData = function() { var length = this.writeSections('draft'); this.source = new Uint8Array(length); this.writeSections(); };
WebmContainer.prototype.getSectionById = function(id) { for (var i = 0; i < this.data.length; i++) { var section = this.data[i]; if (section.id === id) { return section.data; } } return null; };
function WebmFile(source) { WebmContainer.call(this, 'File', 'File'); this.setSource(source); } doInherit(WebmFile, WebmContainer);
WebmFile.prototype.fixDuration = function(duration, options) { var logger = options && options.logger; if (logger === undefined) { logger = function(message) { console.log(message); }; } else if (!logger) { logger = function() { }; } var segmentSection = this.getSectionById(0x8538067); if (!segmentSection) { logger('[fix-webm-duration] Segment section is missing'); return false; } var infoSection = segmentSection.getSectionById(0x549a966); if (!infoSection) { logger('[fix-webm-duration] Info section is missing'); return false; } var timeScaleSection = infoSection.getSectionById(0xad7b1); if (!timeScaleSection) { logger('[fix-webm-duration] TimecodeScale section is missing'); return false; } var durationSection = infoSection.getSectionById(0x489); if (durationSection) { if (durationSection.getValue() <= 0) { logger(`[fix-webm-duration] Duration section is present, but the value is ${durationSection.getValue()}`); durationSection.setValue(duration); } else { logger(`[fix-webm-duration] Duration section is present, and the value is ${durationSection.getValue()}`); return false; } } else { logger('[fix-webm-duration] Duration section is missing'); durationSection = new WebmFloat('Duration', 'Float'); durationSection.setValue(duration); infoSection.data.push({ id: 0x489, data: durationSection }); } timeScaleSection.setValue(1000000); infoSection.updateByData(); segmentSection.updateByData(); this.updateByData(); return true; };
WebmFile.prototype.toBlob = function(mimeType) { return new Blob([ this.source.buffer ], { type: mimeType || 'video/webm' }); };
function fixWebmDuration(blob, duration, callback, options) { if (typeof callback === "object") { options = callback; callback = undefined; } if (!callback) { return new Promise(function(resolve) { fixWebmDuration(blob, duration, resolve, options); }); } try { var reader = new FileReader(); reader.onloadend = function() { try { var file = new WebmFile(new Uint8Array(reader.result)); if (file.fixDuration(duration, options)) { blob = file.toBlob(blob.type); } } catch (ex) { } callback(blob); }; reader.readAsArrayBuffer(blob); } catch (ex) { callback(blob); } } fixWebmDuration.default = fixWebmDuration; return fixWebmDuration;
});
</script>
<style>
:root {
--primary: #3498db;
--danger: #e74c3c;
--dark: #121212;
--panel: #252525;
--text: #ffffff;
--radius: 20px;
}
body {
margin: 0;
background-color: var(--dark);
color: var(--text);
font-family: system-ui, -apple-system, sans-serif;
height: 100vh;
display: flex;
justify-content: center;
align-items: center;
overflow: hidden;
}
.app-container {
width: 90%;
max-width: 1200px;
max-height: 95vh;
display: flex;
flex-direction: column;
gap: 25px;
}
#video-wrapper {
position: relative;
width: 100%;
max-height: 55vh;
aspect-ratio: 16 / 9;
background: #000;
border-radius: var(--radius);
box-shadow: 0 15px 40px rgba(0,0,0,0.5);
overflow: hidden;
margin: 0 auto;
}
video {
width: 100%;
height: 100%;
object-fit: contain;
display: block;
cursor: none;
}
#timer-display {
display: none;
position: absolute;
top: 10px;
left: 50%;
transform: translateX(-50%);
font-size: 16px;
font-weight: bold;
color: var(--text);
background: #2ecc71;
padding: 4px 15px;
border-radius: 50px;
box-shadow: 0 5px 15px rgba(0, 0, 0, 0.8);
z-index: 100;
font-variant-numeric: tabular-nums;
}
#countdown-overlay {
position: absolute;
inset: 0;
background: rgba(0,0,0,0.85);
display: none;
justify-content: center;
align-items: center;
flex-direction: column;
z-index: 200;
backdrop-filter: blur(5px);
}
#countdown-text {
font-size: 120px;
font-weight: bold;
color: var(--primary);
text-shadow: 0 0 30px var(--primary);
}
.status-badge {
position: absolute;
top: 15px;
right: 15px;
display: flex;
align-items: center;
gap: 10px;
background: rgba(0,0,0,0.7);
padding: 8px 15px;
border-radius: 30px;
backdrop-filter: blur(5px);
}
.rec-dot {
width: 12px;
height: 12px;
background-color: var(--danger);
border-radius: 50%;
display: none;
box-shadow: 0 0 15px var(--danger);
animation: pulse 1.5s infinite;
}
@keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.4; } 100% { opacity: 1; }}
.controls-wrapper {
background: var(--panel);
padding: 25px;
border-radius: var(--radius);
box-shadow: 0 10px 30px rgba(0,0,0,0.2);
display: flex;
flex-direction: column;
gap: 20px;
z-index: 50;
}
.settings-grid {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
gap: 10px;
}
.setting-group {
display: flex;
flex-direction: column;
gap: 4px;
}
label {
font-size: 11px;
color: #aaa;
font-weight: 700;
text-transform: uppercase;
letter-spacing: 1px;
}
select {
padding: 12px;
border-radius: 10px;
border: 1px solid #3a3a3a;
background-color: #1a1a1a;
color: white;
font-size: 14px;
outline: none;
transition: all 0.2s;
cursor: pointer;
}
select:focus, select:hover {
border-color: var(--primary);
background-color: #222;
}
.action-bar {
display: flex;
justify-content: center;
gap: 20px;
padding-top: 10px;
border-top: 1px solid #333;
}
button {
padding: 14px 40px;
border: none;
border-radius: 12px;
font-size: 16px;
font-weight: 700;
cursor: pointer;
transition: all 0.2s;
text-transform: uppercase;
letter-spacing: 0.5px;
}
button:hover { filter: brightness(1.1); transform: translateY(-2px); }
button:active { transform: translateY(0px) scale(0.98); }
#btn-start { background-color: var(--primary); color: white; box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3); }
#btn-stop { background-color: var(--danger); color: white; display: none; box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3); }
</style>
</head>
<body>
<main class="app-container">
<div id="video-wrapper">
<video id="preview" autoplay muted></video>
<div id="timer-display">00:00:00</div>
<div class="status-badge">
<div class="rec-dot" id="rec-dot"></div>
<span id="status-text" style="font-size: 13px; font-weight: 500;">Ready</span>
</div>
<div id="countdown-overlay">
<div id="countdown-text">5</div>
</div>
</div>
<div class="controls-wrapper">
<div class="settings-grid" id="settings-panel">
<div class="setting-group">
<label>Resolution</label>
<select id="opt-resolution">
<option value="1080">1080p (FHD)</option>
<option value="720" selected>720p (HD)</option>
<option value="screen">Native (Max)</option>
</select>
</div>
<div class="setting-group">
<label>Quality (Bitrate)</label>
<select id="opt-quality">
<option value="2000000">Low (Laptop/Slow)</option>
<option value="4000000" selected>Standard (Balanced)</option>
<option value="10000000">High (Gaming/Action)</option>
<option value="25000000">Ultra (Lossless-ish)</option>
</select>
</div>
<div class="setting-group">
<label>Framerate</label>
<select id="opt-fps">
<option value="24" selected>24 FPS</option>
<option value="30">30 FPS</option>
<option value="60">60 FPS</option>
</select>
</div>
<div class="setting-group">
<label>Audio Source</label>
<select id="opt-audio">
<option value="system">System Sound</option>
<option value="mic">Microphone</option>
<option value="both">Mix (Both)</option>
<option value="none">No Audio</option>
</select>
</div>
<div class="setting-group">
<label>Cursor</label>
<select id="opt-cursor">
<option value="always">Visible</option>
<option value="never" selected>Hidden</option>
</select>
</div>
<div class="setting-group">
<label>Auto-Stop</label>
<select id="opt-autostop">
<option value="0" selected>Manual</option>
<option value="30">30 Mins</option>
<option value="60">1 Hour</option>
<option value="120">2 Hours</option>
</select>
</div>
</div>
<div class="action-bar">
<button id="btn-start">Start Recording</button>
<button id="btn-stop">Stop & Save</button>
</div>
</div>
</main>
<script>
const preview = document.getElementById('preview');
const timerDisplay = document.getElementById('timer-display');
const statusText = document.getElementById('status-text');
const recDot = document.getElementById('rec-dot');
const countdownOverlay = document.getElementById('countdown-overlay');
const countdownText = document.getElementById('countdown-text');
const settingsPanel = document.getElementById('settings-panel');
const startBtn = document.getElementById('btn-start');
const stopBtn = document.getElementById('btn-stop');
let mediaRecorder, mixedStream, fileHandle, writableStream, timerInterval, startTime, autoStopTimeout, audioContext;
let screenStream = null;
function getConstraints() {
const resVal = document.getElementById('opt-resolution').value;
const fpsVal = parseInt(document.getElementById('opt-fps').value);
let width, height;
if (resVal === '1080') { width = 1920; height = 1080; }
else if (resVal === '720') { width = 1280; height = 720; }
else { width = 9999; height = 9999; }
return {
video: { width: { ideal: width }, height: { ideal: height }, frameRate: { ideal: fpsVal }, cursor: document.getElementById('opt-cursor').value, resizeMode: "none" },
audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false, sampleRate: 48000 }
};
}
function getBitrate(fps) {
const base = parseInt(document.getElementById('opt-quality').value);
const multiplier = (fps >= 60) ? 1.5 : 1;
return Math.floor(base * multiplier);
}
startBtn.addEventListener('click', async () => {
try {
const constraints = getConstraints();
const audioChoice = document.getElementById('opt-audio').value;
const captureSystemAudio = audioChoice !== 'mic' && audioChoice !== 'none';
screenStream = await navigator.mediaDevices.getDisplayMedia({
video: constraints.video,
audio: captureSystemAudio ? constraints.audio : false
});
mixedStream = new MediaStream();
screenStream.getVideoTracks().forEach(track => mixedStream.addTrack(track));
if (audioChoice !== 'none') {
audioContext = new AudioContext();
const destination = audioContext.createMediaStreamDestination();
let hasAudio = false;
if (screenStream.getAudioTracks().length > 0) {
audioContext.createMediaStreamSource(screenStream).connect(destination);
hasAudio = true;
}
if (audioChoice === 'mic' || audioChoice === 'both') {
try {
const micStream = await navigator.mediaDevices.getUserMedia({
audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
});
audioContext.createMediaStreamSource(micStream).connect(destination);
hasAudio = true;
} catch (e) { console.warn("Mic failed:", e); }
}
if (hasAudio) destination.stream.getAudioTracks().forEach(track => mixedStream.addTrack(track));
}
const now = new Date();
const filename = `rec_${constraints.video.height.ideal}p_${constraints.video.frameRate.ideal}fps_${now.toISOString().slice(0,19).replace(/:/g,"-")}.webm`;
fileHandle = await window.showSaveFilePicker({ suggestedName: filename, types: [{ description: 'WebM Video', accept: {'video/webm': ['.webm']} }] });
writableStream = await fileHandle.createWritable();
preview.srcObject = screenStream;
preview.muted = true;
screenStream.getVideoTracks()[0].onended = () => stopRecording();
startCountdown();
} catch (err) { console.error("Startup failed:", err); }
});
function startCountdown() {
settingsPanel.style.pointerEvents = 'none';
settingsPanel.style.opacity = '0.5';
startBtn.style.display = 'none';
countdownOverlay.style.display = 'flex';
let timeLeft = 5;
countdownText.innerText = timeLeft;
const timer = setInterval(() => {
timeLeft--;
if (timeLeft > 0) {
countdownText.innerText = timeLeft;
} else {
clearInterval(timer);
countdownOverlay.style.display = 'none';
beginRecording();
}
}, 1000);
}
function beginRecording() {
const fps = document.getElementById('opt-fps').value;
const mimeType = MediaRecorder.isTypeSupported("video/webm;codecs=vp9") ? "video/webm;codecs=vp9" : "video/webm";
mediaRecorder = new MediaRecorder(mixedStream, {
mimeType: mimeType,
videoBitsPerSecond: getBitrate(fps)
});
mediaRecorder.ondataavailable = async (e) => {
if (e.data.size > 0 && writableStream) await writableStream.write(e.data);
};
mediaRecorder.start(1000);
stopBtn.style.display = 'block';
recDot.style.display = 'block';
timerDisplay.style.display = 'block';
statusText.innerText = "Recording";
statusText.style.color = "#e74c3c";
startTimer();
const autoStopMins = parseInt(document.getElementById('opt-autostop').value);
if (autoStopMins > 0) {
autoStopTimeout = setTimeout(() => {
stopRecording();
alert(`Auto-stopped after ${autoStopMins} mins.`);
}, autoStopMins * 60 * 1000);
}
}
stopBtn.addEventListener('click', stopRecording);
async function stopRecording() {
if (!mediaRecorder || mediaRecorder.state === "inactive") return;
const actualDurationMs = Date.now() - startTime;
clearTimeout(autoStopTimeout);
clearInterval(timerInterval);
mediaRecorder.stop();
if (mixedStream) mixedStream.getTracks().forEach(track => track.stop());
if (audioContext) audioContext.close();
recDot.style.animation = "none";
recDot.style.backgroundColor = "#f1c40f";
recDot.style.opacity = "1";
statusText.style.color = "#f1c40f";
let progress = 0;
statusText.innerText = `Finalizing: ${progress}%`;
const progressTimer = setInterval(() => {
if (progress < 90) {
progress += Math.floor(Math.random() * 5) + 1;
statusText.innerText = `Finalizing: ${progress}%`;
}
}, 200);
if (writableStream) await writableStream.close();
try {
const file = await fileHandle.getFile();
const headerBlob = file.slice(0, 10 * 1024 * 1024, 'video/webm');
const rawBlob = await headerBlob.arrayBuffer().then(buffer => new Blob([buffer], { type: "video/webm" }));
const fixedHeaderBlob = await new Promise((resolve) => {
ysFixWebmDuration(rawBlob, actualDurationMs, (fixed) => {
resolve(fixed);
});
});
const newWritable = await fileHandle.createWritable({ keepExistingData: true });
await newWritable.seek(0);
await newWritable.write(fixedHeaderBlob);
await newWritable.close();
console.log("WebM duration successfully fixed using header-only approach.");
} catch (err) {
console.error("Klarte ikke Ã¥ fikse tidsstempel med ny metode. Mulig filen er ufiksbar:", err);
}
clearInterval(progressTimer);
statusText.innerText = "Finalizing: 100%";
await new Promise(r => setTimeout(r, 500));
recDot.style.display = 'none';
stopBtn.style.display = 'none';
startBtn.style.display = 'block';
timerDisplay.style.display = 'none';
settingsPanel.style.pointerEvents = 'all';
settingsPanel.style.opacity = '1';
statusText.innerText = "Saved!";
statusText.style.color = "#2ecc71";
setTimeout(() => location.reload(), 2000);
}
function startTimer() {
startTime = Date.now();
timerInterval = setInterval(() => {
timerDisplay.innerText = formatTime(Date.now() - startTime);
}, 1000);
}
function formatTime(ms) {
const s = Math.floor(ms / 1000);
return `${pad(Math.floor(s / 3600))}:${pad(Math.floor((s % 3600) / 60))}:${pad(s % 60)}`;
}
function pad(n) { return n.toString().padStart(2, '0'); }
</script>
</body>
</html>